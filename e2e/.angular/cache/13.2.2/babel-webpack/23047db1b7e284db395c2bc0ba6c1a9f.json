{"ast":null,"code":"/**\n * @license\n * Copyright (c) Dominic Carretto\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://github.com/trimox/angular-mdc-web/blob/master/LICENSE\n */\nimport { Directive, ElementRef, Input, InjectionToken, EventEmitter, Component, ViewEncapsulation, ChangeDetectionStrategy, ChangeDetectorRef, Optional, Self, Inject, Output, ViewChild, ContentChild, NgModule } from '@angular/core';\nimport { CommonModule } from '@angular/common';\nimport { MdcFloatingLabel, MdcFloatingLabelModule } from '@angular-mdc/web/floating-label';\nimport { MdcLineRipple, MdcLineRippleModule } from '@angular-mdc/web/line-ripple';\nimport { MdcNotchedOutline, MdcNotchedOutlineModule } from '@angular-mdc/web/notched-outline';\nimport { mixinErrorState, MdcFormFieldControl, ErrorStateMatcher, MdcFormField, MdcFormFieldModule } from '@angular-mdc/web/form-field';\nimport { MdcMenu, MdcMenuModule } from '@angular-mdc/web/menu';\nimport { MdcListModule } from '@angular-mdc/web/list';\nimport { __awaiter } from 'tslib';\nimport { NgControl, NgForm, FormGroupDirective } from '@angular/forms';\nimport { coerceBooleanProperty } from '@angular/cdk/coercion';\nimport { Platform } from '@angular/cdk/platform';\nimport { Subject } from 'rxjs';\nimport { takeUntil } from 'rxjs/operators';\nimport { MDCComponent } from '@angular-mdc/web/base';\nimport { MdcRipple } from '@angular-mdc/web/ripple';\nimport { MDCRippleFoundation } from '@material/ripple';\nimport { MDCSelectFoundation, strings, MDCSelectHelperTextFoundation } from '@material/select';\n/**\n * @fileoverview added by tsickle\n * Generated from: select/select-directives.ts\n * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n\nimport * as ɵngcc0 from '@angular/core';\nimport * as ɵngcc1 from '@angular/cdk/platform';\nimport * as ɵngcc2 from '@angular-mdc/web/form-field';\nimport * as ɵngcc3 from '@angular-mdc/web/ripple';\nimport * as ɵngcc4 from '@angular/forms';\nimport * as ɵngcc5 from '@angular/common';\nimport * as ɵngcc6 from '@angular-mdc/web/floating-label';\nimport * as ɵngcc7 from '@angular-mdc/web/line-ripple';\nimport * as ɵngcc8 from '@angular-mdc/web/notched-outline';\n\nfunction MdcSelect_label_4_Template(rf, ctx) {\n  if (rf & 1) {\n    ɵngcc0.ɵɵelementStart(0, \"label\", 6);\n    ɵngcc0.ɵɵtext(1);\n    ɵngcc0.ɵɵelementEnd();\n  }\n\n  if (rf & 2) {\n    const ctx_r0 = ɵngcc0.ɵɵnextContext();\n    ɵngcc0.ɵɵproperty(\"for\", ctx_r0.id);\n    ɵngcc0.ɵɵadvance(1);\n    ɵngcc0.ɵɵtextInterpolate(ctx_r0.placeholder);\n  }\n}\n\nfunction MdcSelect_mdc_line_ripple_5_Template(rf, ctx) {\n  if (rf & 1) {\n    ɵngcc0.ɵɵelement(0, \"mdc-line-ripple\");\n  }\n}\n\nfunction MdcSelect_mdc_notched_outline_6_Template(rf, ctx) {\n  if (rf & 1) {\n    ɵngcc0.ɵɵelement(0, \"mdc-notched-outline\", 7);\n  }\n\n  if (rf & 2) {\n    const ctx_r2 = ɵngcc0.ɵɵnextContext();\n    ɵngcc0.ɵɵproperty(\"label\", ctx_r2.placeholder)(\"for\", ctx_r2.id);\n  }\n}\n\nconst _c0 = [[[\"mdc-icon\"]], [[\"mdc-menu\"]]];\nconst _c1 = [\"mdc-icon\", \"mdc-menu\"];\nconst _c2 = [\"*\"];\nlet MdcSelectIcon = /*#__PURE__*/(() => {\n  class MdcSelectIcon {}\n\n  MdcSelectIcon.ɵfac = function MdcSelectIcon_Factory(t) {\n    return new (t || MdcSelectIcon)();\n  };\n\n  MdcSelectIcon.ɵdir = /*@__PURE__*/ɵngcc0.ɵɵdefineDirective({\n    type: MdcSelectIcon,\n    selectors: [[\"\", \"mdcSelectIcon\", \"\"]],\n    hostAttrs: [1, \"mdc-select__icon\"],\n    exportAs: [\"mdcSelectIcon\"]\n  });\n  return MdcSelectIcon;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\nlet MdcSelectAnchor = /*#__PURE__*/(() => {\n  class MdcSelectAnchor {\n    /**\n     * @param {?} elementRef\n     */\n    constructor(elementRef) {\n      this.elementRef = elementRef;\n    }\n    /**\n     * @return {?}\n     */\n\n\n    get root() {\n      return this.elementRef.nativeElement;\n    }\n\n  }\n\n  MdcSelectAnchor.ɵfac = function MdcSelectAnchor_Factory(t) {\n    return new (t || MdcSelectAnchor)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef));\n  };\n\n  MdcSelectAnchor.ɵdir = /*@__PURE__*/ɵngcc0.ɵɵdefineDirective({\n    type: MdcSelectAnchor,\n    selectors: [[\"\", \"mdcSelectAnchor\", \"\"]],\n    hostAttrs: [1, \"mdc-select__anchor\"],\n    exportAs: [\"mdcSelectAnchor\"]\n  });\n  /** @nocollapse */\n\n  return MdcSelectAnchor;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\nlet MdcSelectedText = /*#__PURE__*/(() => {\n  class MdcSelectedText {\n    /**\n     * @param {?} elementRef\n     */\n    constructor(elementRef) {\n      this.elementRef = elementRef;\n    }\n    /**\n     * @return {?}\n     */\n\n\n    get root() {\n      return this.elementRef.nativeElement;\n    }\n\n  }\n\n  MdcSelectedText.ɵfac = function MdcSelectedText_Factory(t) {\n    return new (t || MdcSelectedText)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef));\n  };\n\n  MdcSelectedText.ɵdir = /*@__PURE__*/ɵngcc0.ɵɵdefineDirective({\n    type: MdcSelectedText,\n    selectors: [[\"\", \"mdcSelectedText\", \"\"]],\n    hostAttrs: [\"role\", \"button\", \"aria-haspopup\", \"listbox\", 1, \"mdc-select__selected-text\"],\n    hostVars: 2,\n    hostBindings: function MdcSelectedText_HostBindings(rf, ctx) {\n      if (rf & 2) {\n        ɵngcc0.ɵɵattribute(\"aria-labelledby\", ctx.ariaLabelledby)(\"aria-required\", ctx.ariaRequired);\n      }\n    },\n    inputs: {\n      ariaLabelledby: \"ariaLabelledby\",\n      ariaRequired: \"ariaRequired\"\n    },\n    exportAs: [\"mdcSelectedText\"]\n  });\n  /** @nocollapse */\n\n  return MdcSelectedText;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n/**\n * @fileoverview added by tsickle\n * Generated from: select/select.ts\n * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n\n/**\n * Injection token that can be used to configure the default options for all\n * mdc-select usage within an app.\n * @type {?}\n */\n\n\nconst MDC_SELECT_DEFAULT_OPTIONS = new InjectionToken('MDC_SELECT_DEFAULT_OPTIONS');\n\nclass MdcSelectBase extends MDCComponent {\n  /**\n   * @param {?} _elementRef\n   * @param {?} _defaultErrorStateMatcher\n   * @param {?} _parentForm\n   * @param {?} _parentFormGroup\n   * @param {?} ngControl\n   */\n  constructor(_elementRef, _defaultErrorStateMatcher, _parentForm, _parentFormGroup, ngControl) {\n    super(_elementRef);\n    this._elementRef = _elementRef;\n    this._defaultErrorStateMatcher = _defaultErrorStateMatcher;\n    this._parentForm = _parentForm;\n    this._parentFormGroup = _parentFormGroup;\n    this.ngControl = ngControl;\n  }\n\n}\n/** @type {?} */\n\n\nconst _MdcSelectMixinBase = mixinErrorState(MdcSelectBase);\n\nclass MdcSelectChange {\n  /**\n   * @param {?} source\n   * @param {?} index\n   * @param {?} value\n   */\n  constructor(source, index, value) {\n    this.source = source;\n    this.index = index;\n    this.value = value;\n  }\n\n}\n/** @type {?} */\n\n\nlet nextUniqueId = 0;\nlet MdcSelect = /*#__PURE__*/(() => {\n  class MdcSelect extends _MdcSelectMixinBase {\n    /**\n     * @param {?} _platform\n     * @param {?} _changeDetectorRef\n     * @param {?} elementRef\n     * @param {?} _defaultErrorStateMatcher\n     * @param {?} _parentFormField\n     * @param {?} _ripple\n     * @param {?} ngControl\n     * @param {?} _parentForm\n     * @param {?} _parentFormGroup\n     * @param {?=} _defaults\n     */\n    constructor(_platform, _changeDetectorRef, elementRef, _defaultErrorStateMatcher, _parentFormField, _ripple, ngControl, _parentForm, _parentFormGroup, _defaults) {\n      super(elementRef, _defaultErrorStateMatcher, _parentForm, _parentFormGroup, ngControl);\n      this._platform = _platform;\n      this._changeDetectorRef = _changeDetectorRef;\n      this.elementRef = elementRef;\n      this._defaultErrorStateMatcher = _defaultErrorStateMatcher;\n      this._parentFormField = _parentFormField;\n      this._ripple = _ripple;\n      this.ngControl = ngControl;\n      this._defaults = _defaults;\n      /**\n       * Emits whenever the component is destroyed.\n       */\n\n      this._destroyed = new Subject();\n      this._uniqueId = `mdc-select-${++nextUniqueId}`;\n      this._initialized = false;\n      this.id = this._uniqueId;\n      this._disabled = false;\n      this._floatLabel = true;\n      this._outlined = false;\n      this._required = false;\n\n      this.compareWith =\n      /**\n      * @param {?} a1\n      * @param {?} a2\n      * @return {?}\n      */\n      (a1, a2) => a1 === a2;\n      /**\n       * Event emitted when the selected value has been changed by the user.\n       */\n\n\n      this.selectionChange = new EventEmitter();\n      /**\n       * Event that emits whenever the raw value of the select changes. This is here primarily\n       * to facilitate the two-way binding for the `value` input.\n       */\n\n      this.valueChange = new EventEmitter();\n      this.blur = new EventEmitter();\n      this._onFocus = new EventEmitter();\n      /**\n       * View to model callback called when value changes\n       */\n\n      this._onChange =\n      /**\n      * @return {?}\n      */\n      () => {};\n      /**\n       * View to model callback called when select has been touched\n       */\n\n\n      this._onTouched =\n      /**\n      * @return {?}\n      */\n      () => {};\n\n      this._root = this.elementRef.nativeElement;\n\n      if (this.ngControl) {\n        // Note: we provide the value accessor through here, instead of\n        // the `providers` to avoid running into a circular import.\n        this.ngControl.valueAccessor = this;\n      }\n\n      if (this._parentFormField) {\n        _parentFormField.elementRef.nativeElement.classList.add('ngx-form-field-select');\n      } // Force setter to be called in case id was not specified.\n\n\n      this.id = this.id;\n\n      this._setDefaultGlobalOptions();\n    }\n    /**\n     * @return {?}\n     */\n\n\n    get disabled() {\n      return this._disabled;\n    }\n    /**\n     * @param {?} value\n     * @return {?}\n     */\n\n\n    set disabled(value) {\n      this.setDisabledState(value);\n    }\n    /**\n     * @return {?}\n     */\n\n\n    get floatLabel() {\n      return this._floatLabel;\n    }\n    /**\n     * @param {?} value\n     * @return {?}\n     */\n\n\n    set floatLabel(value) {\n      /** @type {?} */\n      const newValue = coerceBooleanProperty(value);\n\n      if (newValue !== this._floatLabel) {\n        this._floatLabel = newValue;\n        this.layout();\n      }\n    }\n    /**\n     * @return {?}\n     */\n\n\n    get outlined() {\n      return this._outlined;\n    }\n    /**\n     * @param {?} value\n     * @return {?}\n     */\n\n\n    set outlined(value) {\n      /** @type {?} */\n      const newValue = coerceBooleanProperty(value);\n      this._outlined = newValue;\n      this.layout();\n    }\n    /**\n     * @return {?}\n     */\n\n\n    get required() {\n      return this._required;\n    }\n    /**\n     * @param {?} value\n     * @return {?}\n     */\n\n\n    set required(value) {\n      /** @type {?} */\n      const newValue = coerceBooleanProperty(value);\n\n      if (newValue !== this._required) {\n        this._required = newValue;\n\n        if (this._initialized && !this._required) {\n          this.valid = true;\n\n          this._changeDetectorRef.markForCheck();\n        }\n      }\n    }\n    /**\n     * @return {?}\n     */\n\n\n    get valid() {\n      return this._valid;\n    }\n    /**\n     * @param {?} value\n     * @return {?}\n     */\n\n\n    set valid(value) {\n      var _a;\n      /** @type {?} */\n\n\n      const newValue = coerceBooleanProperty(value);\n      this._valid = newValue;\n      (_a = this._foundation) === null || _a === void 0 ? void 0 : _a.setValid(this._valid);\n    }\n    /**\n     * Value of the select\n     * @return {?}\n     */\n\n\n    get value() {\n      return this._value;\n    }\n    /**\n     * @param {?} newValue\n     * @return {?}\n     */\n\n\n    set value(newValue) {\n      if (newValue !== this._value) {\n        this.setSelectionByValue(newValue);\n      }\n    }\n    /**\n     * @return {?}\n     */\n\n\n    get helperText() {\n      return this._helperText;\n    }\n    /**\n     * @param {?} helperText\n     * @return {?}\n     */\n\n\n    set helperText(helperText) {\n      var _a;\n\n      this._helperText = helperText;\n      (_a = this.helperText) === null || _a === void 0 ? void 0 : _a.init();\n    }\n    /**\n     * @return {?}\n     */\n\n\n    get _hasPlaceholder() {\n      return this.placeholder ? this.placeholder.length > 0 : false;\n    }\n    /**\n     * @return {?}\n     */\n\n\n    getDefaultFoundation() {\n      // Do not initialize foundation until ngAfterViewInit runs\n      if (!this._initialized) {\n        return undefined;\n      }\n      /** @type {?} */\n\n\n      const adapter = Object.assign(Object.assign(Object.assign(Object.assign({}, this._getSelectAdapterMethods()), this._getCommonAdapterMethods()), this._getOutlineAdapterMethods()), this._getLabelAdapterMethods());\n      return new MDCSelectFoundation(adapter, this._getFoundationMap());\n    }\n    /**\n     * @private\n     * @return {?}\n     */\n\n\n    _getSelectAdapterMethods() {\n      return {\n        getSelectedMenuItem:\n        /**\n        * @return {?}\n        */\n        () =>\n        /** @type {?} */\n        this._menu.elementRef.nativeElement.querySelector(strings.SELECTED_ITEM_SELECTOR),\n        getMenuItemAttr:\n        /**\n        * @param {?} menuItem\n        * @param {?} attr\n        * @return {?}\n        */\n        (menuItem, attr) => menuItem.getAttribute(attr),\n        setSelectedText:\n        /**\n        * @param {?} text\n        * @return {?}\n        */\n        text => this._selectedText.root.textContent = text,\n        isSelectedTextFocused:\n        /**\n        * @return {?}\n        */\n        () => this._platform.isBrowser ? document.activeElement === this._selectedText.root : false,\n        getSelectedTextAttr:\n        /**\n        * @param {?} attr\n        * @return {?}\n        */\n        attr => this._selectedText.root.getAttribute(attr),\n        setSelectedTextAttr:\n        /**\n        * @param {?} attr\n        * @param {?} value\n        * @return {?}\n        */\n        (attr, value) => this._selectedText.root.setAttribute(attr, value),\n        openMenu:\n        /**\n        * @return {?}\n        */\n        () => this._menu.open = true,\n        closeMenu:\n        /**\n        * @return {?}\n        */\n        () => this._menu.open = false,\n        getAnchorElement:\n        /**\n        * @return {?}\n        */\n        () => this._selectAnchor.root,\n        setMenuAnchorElement:\n        /**\n        * @param {?} anchorEl\n        * @return {?}\n        */\n        anchorEl => this._menu.anchorElement = anchorEl,\n        setMenuAnchorCorner:\n        /**\n        * @param {?} anchorCorner\n        * @return {?}\n        */\n        anchorCorner => this._menu.anchorCorner = anchorCorner,\n        setMenuWrapFocus:\n        /**\n        * @param {?} wrapFocus\n        * @return {?}\n        */\n        wrapFocus => this._menu.wrapFocus = wrapFocus,\n        setAttributeAtIndex:\n        /**\n        * @param {?} index\n        * @param {?} attributeName\n        * @param {?} attributeValue\n        * @return {?}\n        */\n        (index, attributeName, attributeValue) =>\n        /** @type {?} */\n        this._menu._list.items.toArray()[index].getListItemElement().setAttribute(attributeName, attributeValue),\n        removeAttributeAtIndex:\n        /**\n        * @param {?} index\n        * @param {?} attributeName\n        * @return {?}\n        */\n        (index, attributeName) =>\n        /** @type {?} */\n        this._menu._list.items.toArray()[index].getListItemElement().removeAttribute(attributeName),\n        focusMenuItemAtIndex:\n        /**\n        * @param {?} index\n        * @return {?}\n        */\n        index =>\n        /** @type {?} */\n        this._menu._list.items.toArray()[index].focus(),\n        getMenuItemCount:\n        /**\n        * @return {?}\n        */\n        () =>\n        /** @type {?} */\n        this._menu._list.items.length,\n        getMenuItemValues:\n        /**\n        * @return {?}\n        */\n        () => {\n          var _a;\n\n          return _a =\n          /** @type {?} */\n          this._menu._list.items.map(\n          /**\n          * @param {?} el\n          * @return {?}\n          */\n          el => el.getListItemElement().getAttribute(strings.VALUE_ATTR) || ''), _a !== null && _a !== void 0 ? _a : [];\n        },\n        getMenuItemTextAtIndex:\n        /**\n        * @param {?} index\n        * @return {?}\n        */\n        index => {\n          var _a;\n\n          return _a =\n          /** @type {?} */\n          this._menu._list.items.toArray()[index].getListItemElement().textContent, _a !== null && _a !== void 0 ? _a : '';\n        },\n        addClassAtIndex:\n        /**\n        * @param {?} index\n        * @param {?} className\n        * @return {?}\n        */\n        (index, className) =>\n        /** @type {?} */\n        this._menu._list.items.toArray()[index].getListItemElement().classList.add(className),\n        removeClassAtIndex:\n        /**\n        * @param {?} index\n        * @param {?} className\n        * @return {?}\n        */\n        (index, className) =>\n        /** @type {?} */\n        this._menu._list.items.toArray()[index].getListItemElement().classList.remove(className)\n      };\n    }\n    /**\n     * @private\n     * @return {?}\n     */\n\n\n    _getCommonAdapterMethods() {\n      return {\n        addClass:\n        /**\n        * @param {?} className\n        * @return {?}\n        */\n        className => this._root.classList.add(className),\n        removeClass:\n        /**\n        * @param {?} className\n        * @return {?}\n        */\n        className => this._root.classList.remove(className),\n        hasClass:\n        /**\n        * @param {?} className\n        * @return {?}\n        */\n        className => this._root.classList.contains(className),\n        setRippleCenter:\n        /**\n        * @param {?} normalizedX\n        * @return {?}\n        */\n        normalizedX => {\n          var _a;\n\n          return (_a = this._lineRipple) === null || _a === void 0 ? void 0 : _a.setRippleCenter(normalizedX);\n        },\n        activateBottomLine:\n        /**\n        * @return {?}\n        */\n        () => {\n          var _a;\n\n          return (_a = this._lineRipple) === null || _a === void 0 ? void 0 : _a.activate();\n        },\n        deactivateBottomLine:\n        /**\n        * @return {?}\n        */\n        () => {\n          var _a;\n\n          return (_a = this._lineRipple) === null || _a === void 0 ? void 0 : _a.deactivate();\n        },\n        notifyChange:\n        /**\n        * @return {?}\n        */\n        () => {}\n      };\n    }\n    /**\n     * @private\n     * @return {?}\n     */\n\n\n    _getOutlineAdapterMethods() {\n      return {\n        hasOutline:\n        /**\n        * @return {?}\n        */\n        () => !!this._notchedOutline,\n        notchOutline:\n        /**\n        * @param {?} labelWidth\n        * @return {?}\n        */\n        labelWidth => {\n          var _a;\n\n          return (_a = this._notchedOutline) === null || _a === void 0 ? void 0 : _a.notch(labelWidth);\n        },\n        closeOutline:\n        /**\n        * @return {?}\n        */\n        () => {\n          var _a;\n\n          return (_a = this._notchedOutline) === null || _a === void 0 ? void 0 : _a.closeNotch();\n        }\n      };\n    }\n    /**\n     * @private\n     * @return {?}\n     */\n\n\n    _getLabelAdapterMethods() {\n      return {\n        hasLabel:\n        /**\n        * @return {?}\n        */\n        () => this._hasPlaceholder,\n        floatLabel:\n        /**\n        * @param {?} shouldFloat\n        * @return {?}\n        */\n        shouldFloat => this._getFloatingLabel().float(shouldFloat),\n        getLabelWidth:\n        /**\n        * @return {?}\n        */\n        () => {\n          var _a;\n\n          return (_a = this._getFloatingLabel()) === null || _a === void 0 ? void 0 : _a.getWidth();\n        }\n      };\n    }\n    /**\n     * Returns a map of all subcomponents to subfoundations.\n     * @private\n     * @return {?}\n     */\n\n\n    _getFoundationMap() {\n      var _a;\n\n      return {\n        helperText: (_a = this._helperText) === null || _a === void 0 ? void 0 : _a.foundation\n      };\n    }\n    /**\n     * @return {?}\n     */\n\n\n    ngAfterViewInit() {\n      this._initialized = true;\n\n      this._asyncBuildFoundation().then(\n      /**\n      * @return {?}\n      */\n      () => {\n        this._selectBuilder();\n      });\n\n      this._initializeSelection();\n\n      this._subscribeToMenuEvents();\n    }\n    /**\n     * @return {?}\n     */\n\n\n    ngOnDestroy() {\n      this.destroy();\n    }\n    /**\n     * Override MdcSelectBase destroy method\n     * @return {?}\n     */\n\n\n    destroy() {\n      var _a;\n\n      this._destroyed.next();\n\n      this._destroyed.complete();\n\n      (_a = this._lineRipple) === null || _a === void 0 ? void 0 : _a.destroy();\n\n      this._ripple.destroy();\n\n      this._foundation.destroy();\n    }\n    /**\n     * @return {?}\n     */\n\n\n    ngDoCheck() {\n      if (this.ngControl) {\n        // We need to re-evaluate this on every change detection cycle, because there are some\n        // error triggers that we can't subscribe to (e.g. parent form submissions). This means\n        // that whatever logic is in here has to be super lean or we risk destroying the performance.\n        this.updateErrorState();\n      }\n    }\n    /**\n     * @param {?} value\n     * @return {?}\n     */\n\n\n    writeValue(value) {\n      if (this._initialized) {\n        this.setSelectionByValue(value, false);\n      }\n    }\n    /**\n     * @param {?} fn\n     * @return {?}\n     */\n\n\n    registerOnChange(fn) {\n      this._onChange = fn;\n    }\n    /**\n     * @param {?} fn\n     * @return {?}\n     */\n\n\n    registerOnTouched(fn) {\n      this._onTouched = fn;\n    }\n    /**\n     * @return {?}\n     */\n\n\n    onFocus() {\n      if (!this.disabled) {\n        this._foundation.handleFocus();\n\n        this._onFocus.emit(true);\n      }\n    }\n    /**\n     * @return {?}\n     */\n\n\n    onBlur() {\n      this._foundation.handleBlur();\n    }\n    /**\n     * @param {?} evt\n     * @return {?}\n     */\n\n\n    onClick(evt) {\n      this._foundation.handleClick(this._getNormalizedXCoordinate(evt));\n    }\n    /**\n     * @param {?} evt\n     * @return {?}\n     */\n\n\n    onKeydown(evt) {\n      this._foundation.handleKeydown(evt);\n    }\n    /**\n     * @return {?}\n     */\n\n\n    getSelectedIndex() {\n      var _a, _b;\n\n      return _b = (_a = this._foundation) === null || _a === void 0 ? void 0 : _a.getSelectedIndex(), _b !== null && _b !== void 0 ? _b : -1;\n    }\n    /**\n     * @return {?}\n     */\n\n\n    focus() {\n      this._selectedText.root.focus();\n    }\n    /**\n     * @param {?} index\n     * @return {?}\n     */\n\n\n    setSelectedIndex(index) {\n      var _a, _b;\n\n      this.setSelectionByValue((_b = (_a = this._menu._list) === null || _a === void 0 ? void 0 : _a.getListItemByIndex(index)) === null || _b === void 0 ? void 0 : _b.value, true, index);\n    }\n    /**\n     * @param {?} value\n     * @param {?=} isUserInput\n     * @param {?=} index\n     * @return {?}\n     */\n\n\n    setSelectionByValue(value, isUserInput = true, index) {\n      var _a;\n\n      if (!this._value && !value) {\n        return;\n      }\n\n      if (!index) {\n        index = (_a = this._menu._list) === null || _a === void 0 ? void 0 : _a.getListItemIndexByValue(value);\n      }\n\n      this._value = value;\n\n      this._foundation.setSelectedIndex(index !== null && index !== void 0 ? index : -1, this._menu.closeSurfaceOnSelection);\n\n      if (isUserInput) {\n        this._onChange(this._value);\n\n        this.selectionChange.emit(new MdcSelectChange(this, this.getSelectedIndex(), value));\n      }\n\n      this.valueChange.emit({\n        index: this.getSelectedIndex(),\n        value: this._value\n      });\n\n      this._foundation.handleChange();\n\n      this._changeDetectorRef.markForCheck();\n    } // Implemented as part of ControlValueAccessor.\n\n    /**\n     * @param {?} disabled\n     * @return {?}\n     */\n\n\n    setDisabledState(disabled) {\n      var _a;\n\n      this._disabled = coerceBooleanProperty(disabled);\n      (_a = this._foundation) === null || _a === void 0 ? void 0 : _a.setDisabled(this._disabled);\n\n      this._changeDetectorRef.markForCheck();\n    }\n    /**\n     * @return {?}\n     */\n\n\n    get _hasValue() {\n      var _a;\n\n      return ((_a = this._value) === null || _a === void 0 ? void 0 : _a.length) > 0;\n    }\n    /**\n     * Initialize Select internal state based on the environment state\n     * @private\n     * @return {?}\n     */\n\n\n    layout() {\n      if (this._initialized) {\n        this._asyncBuildFoundation().then(\n        /**\n        * @return {?}\n        */\n        () => {\n          this._selectBuilder();\n\n          this._foundation.layout();\n        });\n      }\n    }\n    /**\n     * @private\n     * @return {?}\n     */\n\n\n    _initializeSelection() {\n      // Defer setting the value in order to avoid the \"Expression\n      // has changed after it was checked\" errors from Angular.\n      Promise.resolve().then(\n      /**\n      * @return {?}\n      */\n      () => {\n        var _a, _b;\n        /** @type {?} */\n\n\n        const value = (_b = (_a = this.ngControl) === null || _a === void 0 ? void 0 : _a.value, _b !== null && _b !== void 0 ? _b : this._value);\n\n        if (value) {\n          this.setSelectionByValue(value, false);\n        }\n      });\n    }\n    /**\n     * Set the default options.\n     * @private\n     * @return {?}\n     */\n\n\n    _setDefaultGlobalOptions() {\n      if (this._defaults) {\n        if (this._defaults.outlined != null) {\n          this.outlined = this._defaults.outlined;\n        }\n      }\n    }\n    /**\n     * @return {?}\n     */\n\n\n    _asyncBuildFoundation() {\n      return __awaiter(this, void 0, void 0, function* () {\n        this._foundation = this.getDefaultFoundation();\n      });\n    }\n    /**\n     * @return {?}\n     */\n\n\n    _asyncInitFoundation() {\n      return __awaiter(this, void 0, void 0, function* () {\n        this._foundation.init();\n      });\n    }\n    /**\n     * @private\n     * @return {?}\n     */\n\n\n    _selectBuilder() {\n      this._changeDetectorRef.detectChanges(); // initialize after running a detectChanges()\n\n\n      this._asyncInitFoundation().then(\n      /**\n      * @return {?}\n      */\n      () => {\n        if (!this.outlined) {\n          this._ripple = this._createRipple();\n\n          this._ripple.init();\n        }\n\n        this._menu.wrapFocus = false;\n\n        this._menu.elementRef.nativeElement.setAttribute('role', 'listbox');\n\n        this._menu.elementRef.nativeElement.classList.add('mdc-select__menu');\n\n        if (this._menu._list) {\n          this._menu._list.useSelectedClass = true;\n          this._menu._list.singleSelection = true;\n        }\n      });\n    }\n    /**\n     * @private\n     * @return {?}\n     */\n\n\n    _subscribeToMenuEvents() {\n      // When the list items change, re-subscribe\n\n      /** @type {?} */\n      this._menu._list.items.changes.pipe(takeUntil(this._destroyed)).subscribe(\n      /**\n      * @return {?}\n      */\n      () => this._initializeSelection()); // Subscribe to menu opened event\n\n\n      this._menu.opened.pipe(takeUntil(this._destroyed)).subscribe(\n      /**\n      * @return {?}\n      */\n      () => this._foundation.handleMenuOpened()); // Subscribe to menu closed event\n\n\n      this._menu.closed.pipe(takeUntil(this._destroyed)).subscribe(\n      /**\n      * @return {?}\n      */\n      () => {\n        this._foundation.handleMenuClosed();\n\n        this._blur();\n      }); // Subscribe to list-item action event\n\n\n      this._menu.selected.pipe(takeUntil(this._destroyed)).subscribe(\n      /**\n      * @param {?} evt\n      * @return {?}\n      */\n      evt => this.setSelectedIndex(evt.index));\n    }\n    /**\n     * @private\n     * @return {?}\n     */\n\n\n    _blur() {\n      this._onTouched();\n\n      this.blur.emit(this.value);\n\n      this._onFocus.emit(false);\n    }\n    /**\n     * @private\n     * @return {?}\n     */\n\n\n    _getFloatingLabel() {\n      var _a;\n\n      return _a = this._floatingLabel, _a !== null && _a !== void 0 ? _a :\n      /** @type {?} */\n      this._notchedOutline.floatingLabel;\n    }\n    /**\n     * Calculates where the line ripple should start based on the x coordinate within the component.\n     * @private\n     * @param {?} evt\n     * @return {?}\n     */\n\n\n    _getNormalizedXCoordinate(evt) {\n      /** @type {?} */\n      const targetClientRect =\n      /** @type {?} */\n      evt.target.getBoundingClientRect();\n\n      if (evt instanceof MouseEvent) {\n        return evt.clientX - targetClientRect.left;\n      }\n      /** @type {?} */\n\n\n      const clientX = evt.touches[0] && evt.touches[0].clientX;\n      return clientX - targetClientRect.left;\n    }\n    /**\n     * @private\n     * @return {?}\n     */\n\n\n    _createRipple() {\n      /** @type {?} */\n      const adapter = Object.assign(Object.assign({}, MdcRipple.createAdapter({\n        _root: this._selectAnchor.root\n      })), {\n        registerInteractionHandler:\n        /**\n        * @param {?} evtType\n        * @param {?} handler\n        * @return {?}\n        */\n        (evtType, handler) => this._selectedText.root.addEventListener(evtType, handler),\n        deregisterInteractionHandler:\n        /**\n        * @param {?} evtType\n        * @param {?} handler\n        * @return {?}\n        */\n        (evtType, handler) => this._selectedText.root.removeEventListener(evtType, handler)\n      });\n      return new MdcRipple(this._selectAnchor.elementRef, new MDCRippleFoundation(adapter));\n    }\n\n  }\n\n  MdcSelect.ɵfac = function MdcSelect_Factory(t) {\n    return new (t || MdcSelect)(ɵngcc0.ɵɵdirectiveInject(ɵngcc1.Platform), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ChangeDetectorRef), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef), ɵngcc0.ɵɵdirectiveInject(ɵngcc2.ErrorStateMatcher), ɵngcc0.ɵɵdirectiveInject(ɵngcc2.MdcFormField, 8), ɵngcc0.ɵɵdirectiveInject(ɵngcc3.MdcRipple, 8), ɵngcc0.ɵɵdirectiveInject(ɵngcc4.NgControl, 10), ɵngcc0.ɵɵdirectiveInject(ɵngcc4.NgForm, 8), ɵngcc0.ɵɵdirectiveInject(ɵngcc4.FormGroupDirective, 8), ɵngcc0.ɵɵdirectiveInject(MDC_SELECT_DEFAULT_OPTIONS, 8));\n  };\n\n  MdcSelect.ɵcmp = /*@__PURE__*/ɵngcc0.ɵɵdefineComponent({\n    type: MdcSelect,\n    selectors: [[\"mdc-select\"]],\n    contentQueries: function MdcSelect_ContentQueries(rf, ctx, dirIndex) {\n      if (rf & 1) {\n        ɵngcc0.ɵɵcontentQuery(dirIndex, MdcMenu, 5);\n        ɵngcc0.ɵɵcontentQuery(dirIndex, MdcSelectIcon, 5);\n      }\n\n      if (rf & 2) {\n        let _t;\n\n        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx._menu = _t.first);\n        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.leadingIcon = _t.first);\n      }\n    },\n    viewQuery: function MdcSelect_Query(rf, ctx) {\n      if (rf & 1) {\n        ɵngcc0.ɵɵviewQuery(MdcFloatingLabel, 5);\n        ɵngcc0.ɵɵviewQuery(MdcLineRipple, 5);\n        ɵngcc0.ɵɵviewQuery(MdcNotchedOutline, 5);\n        ɵngcc0.ɵɵviewQuery(MdcSelectAnchor, 5);\n        ɵngcc0.ɵɵviewQuery(MdcSelectedText, 5);\n      }\n\n      if (rf & 2) {\n        let _t;\n\n        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx._floatingLabel = _t.first);\n        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx._lineRipple = _t.first);\n        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx._notchedOutline = _t.first);\n        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx._selectAnchor = _t.first);\n        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx._selectedText = _t.first);\n      }\n    },\n    hostAttrs: [1, \"mdc-select\"],\n    hostVars: 13,\n    hostBindings: function MdcSelect_HostBindings(rf, ctx) {\n      if (rf & 2) {\n        ɵngcc0.ɵɵhostProperty(\"id\", ctx.id);\n        ɵngcc0.ɵɵclassProp(\"mdc-select--disabled\", ctx.disabled)(\"mdc-select--outlined\", ctx.outlined)(\"mdc-select--required\", ctx.required)(\"mdc-select--no-label\", !ctx._hasPlaceholder)(\"mdc-select--with-leading-icon\", ctx.leadingIcon)(\"mdc-select--invalid\", ctx.errorState);\n      }\n    },\n    inputs: {\n      id: \"id\",\n      compareWith: \"compareWith\",\n      disabled: \"disabled\",\n      floatLabel: \"floatLabel\",\n      outlined: \"outlined\",\n      required: \"required\",\n      valid: \"valid\",\n      value: \"value\",\n      helperText: \"helperText\",\n      name: \"name\",\n      placeholder: \"placeholder\",\n      errorStateMatcher: \"errorStateMatcher\"\n    },\n    outputs: {\n      selectionChange: \"selectionChange\",\n      valueChange: \"valueChange\",\n      blur: \"blur\",\n      _onFocus: \"focus\"\n    },\n    exportAs: [\"mdcSelect\"],\n    features: [ɵngcc0.ɵɵProvidersFeature([MdcRipple, {\n      provide: MdcFormFieldControl,\n      useExisting: MdcSelect\n    }]), ɵngcc0.ɵɵInheritDefinitionFeature],\n    ngContentSelectors: _c1,\n    decls: 8,\n    vars: 6,\n    consts: [[\"mdcSelectAnchor\", \"\"], [1, \"mdc-select__dropdown-icon\"], [\"mdcSelectedText\", \"\", 3, \"tabindex\", \"ariaRequired\", \"ariaLabelledby\", \"focus\", \"blur\", \"keydown\", \"click\"], [\"mdcFloatingLabel\", \"\", 3, \"for\", 4, \"ngIf\"], [4, \"ngIf\"], [3, \"label\", \"for\", 4, \"ngIf\"], [\"mdcFloatingLabel\", \"\", 3, \"for\"], [3, \"label\", \"for\"]],\n    template: function MdcSelect_Template(rf, ctx) {\n      if (rf & 1) {\n        ɵngcc0.ɵɵprojectionDef(_c0);\n        ɵngcc0.ɵɵelementStart(0, \"div\", 0);\n        ɵngcc0.ɵɵprojection(1);\n        ɵngcc0.ɵɵelement(2, \"i\", 1);\n        ɵngcc0.ɵɵelementStart(3, \"div\", 2);\n        ɵngcc0.ɵɵlistener(\"focus\", function MdcSelect_Template_div_focus_3_listener() {\n          return ctx.onFocus();\n        })(\"blur\", function MdcSelect_Template_div_blur_3_listener() {\n          return ctx.onBlur();\n        })(\"keydown\", function MdcSelect_Template_div_keydown_3_listener($event) {\n          return ctx.onKeydown($event);\n        })(\"click\", function MdcSelect_Template_div_click_3_listener($event) {\n          return ctx.onClick($event);\n        });\n        ɵngcc0.ɵɵelementEnd();\n        ɵngcc0.ɵɵtemplate(4, MdcSelect_label_4_Template, 2, 2, \"label\", 3);\n        ɵngcc0.ɵɵtemplate(5, MdcSelect_mdc_line_ripple_5_Template, 1, 0, \"mdc-line-ripple\", 4);\n        ɵngcc0.ɵɵtemplate(6, MdcSelect_mdc_notched_outline_6_Template, 1, 2, \"mdc-notched-outline\", 5);\n        ɵngcc0.ɵɵelementEnd();\n        ɵngcc0.ɵɵprojection(7, 1);\n      }\n\n      if (rf & 2) {\n        ɵngcc0.ɵɵadvance(3);\n        ɵngcc0.ɵɵproperty(\"tabindex\", ctx.disabled ? \"-1\" : \"0\")(\"ariaRequired\", ctx.required)(\"ariaLabelledby\", ctx.id);\n        ɵngcc0.ɵɵadvance(1);\n        ɵngcc0.ɵɵproperty(\"ngIf\", !ctx.outlined);\n        ɵngcc0.ɵɵadvance(1);\n        ɵngcc0.ɵɵproperty(\"ngIf\", !ctx.outlined);\n        ɵngcc0.ɵɵadvance(1);\n        ɵngcc0.ɵɵproperty(\"ngIf\", ctx.outlined);\n      }\n    },\n    directives: [MdcSelectAnchor, MdcSelectedText, ɵngcc5.NgIf, ɵngcc6.MdcFloatingLabel, ɵngcc7.MdcLineRipple, ɵngcc8.MdcNotchedOutline],\n    encapsulation: 2,\n    changeDetection: 0\n  });\n  /** @nocollapse */\n\n  return MdcSelect;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n/**\n * @fileoverview added by tsickle\n * Generated from: select/select-helper-text.ts\n * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n\n\nlet MDCSelectHelperText = /*#__PURE__*/(() => {\n  class MDCSelectHelperText extends MDCComponent {\n    /**\n     * @param {?} elementRef\n     */\n    constructor(elementRef) {\n      super(elementRef);\n      this.elementRef = elementRef;\n      this._persistent = false;\n      this._validation = false;\n    }\n    /**\n     * @return {?}\n     */\n\n\n    get persistent() {\n      return this._persistent;\n    }\n    /**\n     * @param {?} value\n     * @return {?}\n     */\n\n\n    set persistent(value) {\n      this._persistent = coerceBooleanProperty(value);\n\n      this._foundation.setPersistent(this._persistent);\n    }\n    /**\n     * @return {?}\n     */\n\n\n    get validation() {\n      return this._validation;\n    }\n    /**\n     * @param {?} value\n     * @return {?}\n     */\n\n\n    set validation(value) {\n      this._validation = coerceBooleanProperty(value);\n\n      this._foundation.setValidation(this._validation);\n    }\n    /**\n     * @return {?}\n     */\n\n\n    get foundation() {\n      return this._foundation;\n    }\n    /**\n     * @return {?}\n     */\n\n\n    getDefaultFoundation() {\n      /** @type {?} */\n      const adapter = {\n        addClass:\n        /**\n        * @param {?} className\n        * @return {?}\n        */\n        className => this.elementRef.nativeElement.classList.add(className),\n        removeClass:\n        /**\n        * @param {?} className\n        * @return {?}\n        */\n        className => this.elementRef.nativeElement.classList.remove(className),\n        hasClass:\n        /**\n        * @param {?} className\n        * @return {?}\n        */\n        className => this.elementRef.nativeElement.classList.contains(className),\n        setAttr:\n        /**\n        * @param {?} attr\n        * @param {?} value\n        * @return {?}\n        */\n        (attr, value) => this.elementRef.nativeElement.setAttribute(attr, value),\n        removeAttr:\n        /**\n        * @param {?} attr\n        * @return {?}\n        */\n        attr => this.elementRef.nativeElement.removeAttribute(attr),\n        setContent:\n        /**\n        * @return {?}\n        */\n        () => {}\n      };\n      return new MDCSelectHelperTextFoundation(adapter);\n    }\n    /**\n     * Sets the validity of the helper text.\n     * @param {?} inputIsValid\n     * @return {?}\n     */\n\n\n    setValidity(inputIsValid) {\n      this._foundation.setValidity(inputIsValid);\n    }\n    /**\n     * Makes the helper text visible to the screen reader.\n     * @return {?}\n     */\n\n\n    showToScreenReader() {\n      this._foundation.showToScreenReader();\n    }\n    /**\n     * @return {?}\n     */\n\n\n    init() {\n      this._foundation.setPersistent(this.persistent);\n\n      this._foundation.setValidation(this.validation);\n    }\n\n  }\n\n  MDCSelectHelperText.ɵfac = function MDCSelectHelperText_Factory(t) {\n    return new (t || MDCSelectHelperText)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef));\n  };\n\n  MDCSelectHelperText.ɵcmp = /*@__PURE__*/ɵngcc0.ɵɵdefineComponent({\n    type: MDCSelectHelperText,\n    selectors: [[\"mdc-select-helper-text\"], [\"\", \"mdcSelectHelperText\", \"\"]],\n    hostAttrs: [1, \"mdc-select-helper-text\"],\n    inputs: {\n      persistent: \"persistent\",\n      validation: \"validation\",\n      id: \"id\"\n    },\n    exportAs: [\"mdcSelectHelperText\"],\n    features: [ɵngcc0.ɵɵInheritDefinitionFeature],\n    ngContentSelectors: _c2,\n    decls: 1,\n    vars: 0,\n    template: function MDCSelectHelperText_Template(rf, ctx) {\n      if (rf & 1) {\n        ɵngcc0.ɵɵprojectionDef();\n        ɵngcc0.ɵɵprojection(0);\n      }\n    },\n    encapsulation: 2,\n    changeDetection: 0\n  });\n  /** @nocollapse */\n\n  return MDCSelectHelperText;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n/**\n * @fileoverview added by tsickle\n * Generated from: select/module.ts\n * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n\n/** @type {?} */\n\n\nconst SELECT_DECLARATIONS = [MdcSelect, MdcSelectAnchor, MDCSelectHelperText, MdcSelectIcon, MdcSelectedText];\nlet MdcSelectModule = /*#__PURE__*/(() => {\n  class MdcSelectModule {}\n\n  MdcSelectModule.ɵfac = function MdcSelectModule_Factory(t) {\n    return new (t || MdcSelectModule)();\n  };\n\n  MdcSelectModule.ɵmod = /*@__PURE__*/ɵngcc0.ɵɵdefineNgModule({\n    type: MdcSelectModule\n  });\n  MdcSelectModule.ɵinj = /*@__PURE__*/ɵngcc0.ɵɵdefineInjector({\n    imports: [[CommonModule, MdcMenuModule, MdcListModule, MdcFormFieldModule, MdcFloatingLabelModule, MdcNotchedOutlineModule, MdcLineRippleModule], MdcMenuModule, MdcListModule, MdcFormFieldModule]\n  });\n  return MdcSelectModule;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\n(function () {\n  (typeof ngJitMode === \"undefined\" || ngJitMode) && ɵngcc0.ɵɵsetNgModuleScope(MdcSelectModule, {\n    declarations: function () {\n      return [MdcSelect, MdcSelectAnchor, MDCSelectHelperText, MdcSelectIcon, MdcSelectedText];\n    },\n    imports: function () {\n      return [CommonModule, MdcMenuModule, MdcListModule, MdcFormFieldModule, MdcFloatingLabelModule, MdcNotchedOutlineModule, MdcLineRippleModule];\n    },\n    exports: function () {\n      return [MdcMenuModule, MdcListModule, MdcFormFieldModule, MdcSelect, MdcSelectAnchor, MDCSelectHelperText, MdcSelectIcon, MdcSelectedText];\n    }\n  });\n})();\n\nexport { MDCSelectHelperText, MDC_SELECT_DEFAULT_OPTIONS, MdcSelect, MdcSelectAnchor, MdcSelectChange, MdcSelectIcon, MdcSelectModule, MdcSelectedText }; //# sourceMappingURL=select.js.map","map":null,"metadata":{},"sourceType":"module"}