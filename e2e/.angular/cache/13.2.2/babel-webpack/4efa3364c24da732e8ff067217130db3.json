{"ast":null,"code":"/**\n * @license\n * Copyright (c) Dominic Carretto\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://github.com/trimox/angular-mdc-web/blob/master/LICENSE\n */\nimport { Directive, ElementRef, Input, Component, ViewEncapsulation, ChangeDetectionStrategy, NgZone, ContentChild, ContentChildren, Optional, Inject, ViewChild, InjectionToken, TemplateRef, Injectable, Injector, SkipSelf, NgModule } from '@angular/core';\nimport { Overlay, OverlayModule } from '@angular/cdk/overlay';\nimport { BasePortalOutlet, CdkPortalOutlet, PortalInjector, ComponentPortal, TemplatePortal, PortalModule } from '@angular/cdk/portal';\nimport { Platform } from '@angular/cdk/platform';\nimport { Subject, merge, fromEvent, defer } from 'rxjs';\nimport { takeUntil, startWith } from 'rxjs/operators';\nimport { MDCComponent } from '@angular-mdc/web/base';\nimport { coerceBooleanProperty } from '@angular/cdk/coercion';\nimport { MdcButton } from '@angular-mdc/web/button';\nimport { MdcRipple } from '@angular-mdc/web/ripple';\nimport { matches, closest } from '@angular-mdc/web/dom';\nimport { MDCDialogFoundation, util, strings } from '@material/dialog';\nimport { DOCUMENT } from '@angular/common';\nimport { FocusTrapFactory } from '@angular/cdk/a11y';\n/**\n * @fileoverview added by tsickle\n * Generated from: dialog/dialog-directives.ts\n * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n\nimport * as ɵngcc0 from '@angular/core';\nimport * as ɵngcc1 from '@angular/cdk/platform';\nimport * as ɵngcc2 from '@angular/cdk/a11y';\nimport * as ɵngcc3 from '@angular/cdk/portal';\nimport * as ɵngcc4 from '@angular/cdk/overlay';\nconst _c0 = [\"*\"];\nconst _c1 = [\"mdcDialogButton\", \"\"];\n\nfunction MdcDialogPortal_ng_template_0_Template(rf, ctx) {}\n\nlet MdcDialogAction = /*#__PURE__*/(() => {\n  class MdcDialogAction {\n    /**\n     * @param {?} elementRef\n     */\n    constructor(elementRef) {\n      this.elementRef = elementRef;\n      this._action = '';\n    }\n    /**\n     * @return {?}\n     */\n\n\n    get action() {\n      return this._action;\n    }\n    /**\n     * @param {?} action\n     * @return {?}\n     */\n\n\n    set action(action) {\n      // If the directive is set without a name (updated programatically), then this setter will\n      // trigger with an empty string and should not overwrite the programatically set value.\n      if (!action) {\n        return;\n      }\n\n      this._action = action;\n      this.elementRef.nativeElement.setAttribute('data-mdc-dialog-action', this._action);\n    }\n\n  }\n\n  MdcDialogAction.ɵfac = function MdcDialogAction_Factory(t) {\n    return new (t || MdcDialogAction)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef));\n  };\n\n  MdcDialogAction.ɵdir = /*@__PURE__*/ɵngcc0.ɵɵdefineDirective({\n    type: MdcDialogAction,\n    selectors: [[\"\", \"mdcDialogAction\", \"\"]],\n    inputs: {\n      action: [\"mdcDialogAction\", \"action\"]\n    }\n  });\n  /** @nocollapse */\n\n  return MdcDialogAction;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\nlet MdcDialogScrim = /*#__PURE__*/(() => {\n  class MdcDialogScrim {\n    /**\n     * @param {?} elementRef\n     */\n    constructor(elementRef) {\n      this.elementRef = elementRef;\n    }\n\n  }\n\n  MdcDialogScrim.ɵfac = function MdcDialogScrim_Factory(t) {\n    return new (t || MdcDialogScrim)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef));\n  };\n\n  MdcDialogScrim.ɵdir = /*@__PURE__*/ɵngcc0.ɵɵdefineDirective({\n    type: MdcDialogScrim,\n    selectors: [[\"mdc-dialog-scrim\"]],\n    hostAttrs: [1, \"mdc-dialog__scrim\"]\n  });\n  /** @nocollapse */\n\n  return MdcDialogScrim;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\nlet MdcDialogContainer = /*#__PURE__*/(() => {\n  class MdcDialogContainer {\n    /**\n     * @param {?} elementRef\n     */\n    constructor(elementRef) {\n      this.elementRef = elementRef;\n    }\n\n  }\n\n  MdcDialogContainer.ɵfac = function MdcDialogContainer_Factory(t) {\n    return new (t || MdcDialogContainer)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef));\n  };\n\n  MdcDialogContainer.ɵdir = /*@__PURE__*/ɵngcc0.ɵɵdefineDirective({\n    type: MdcDialogContainer,\n    selectors: [[\"\", \"mdcDialogContainer\", \"\"], [\"mdc-dialog-container\"]],\n    hostAttrs: [1, \"mdc-dialog__container\"]\n  });\n  /** @nocollapse */\n\n  return MdcDialogContainer;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\nlet MdcDialogSurface = /*#__PURE__*/(() => {\n  class MdcDialogSurface {\n    /**\n     * @param {?} elementRef\n     */\n    constructor(elementRef) {\n      this.elementRef = elementRef;\n    }\n\n  }\n\n  MdcDialogSurface.ɵfac = function MdcDialogSurface_Factory(t) {\n    return new (t || MdcDialogSurface)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef));\n  };\n\n  MdcDialogSurface.ɵdir = /*@__PURE__*/ɵngcc0.ɵɵdefineDirective({\n    type: MdcDialogSurface,\n    selectors: [[\"\", \"mdcDialogSurface\", \"\"], [\"mdc-dialog-surface\"]],\n    hostAttrs: [1, \"mdc-dialog__surface\"]\n  });\n  /** @nocollapse */\n\n  return MdcDialogSurface;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\nlet MdcDialogTitle = /*#__PURE__*/(() => {\n  class MdcDialogTitle {\n    /**\n     * @param {?} elementRef\n     */\n    constructor(elementRef) {\n      this.elementRef = elementRef;\n    }\n\n  }\n\n  MdcDialogTitle.ɵfac = function MdcDialogTitle_Factory(t) {\n    return new (t || MdcDialogTitle)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef));\n  };\n\n  MdcDialogTitle.ɵdir = /*@__PURE__*/ɵngcc0.ɵɵdefineDirective({\n    type: MdcDialogTitle,\n    selectors: [[\"\", \"mdcDialogTitle\", \"\"], [\"mdc-dialog-title\"]],\n    hostAttrs: [1, \"mdc-dialog__title\"]\n  });\n  /** @nocollapse */\n\n  return MdcDialogTitle;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\nlet MdcDialogContent = /*#__PURE__*/(() => {\n  class MdcDialogContent {\n    /**\n     * @param {?} elementRef\n     */\n    constructor(elementRef) {\n      this.elementRef = elementRef;\n    }\n\n  }\n\n  MdcDialogContent.ɵfac = function MdcDialogContent_Factory(t) {\n    return new (t || MdcDialogContent)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef));\n  };\n\n  MdcDialogContent.ɵdir = /*@__PURE__*/ɵngcc0.ɵɵdefineDirective({\n    type: MdcDialogContent,\n    selectors: [[\"\", \"mdcDialogContent\", \"\"], [\"mdc-dialog-content\"]],\n    hostAttrs: [1, \"mdc-dialog__content\"]\n  });\n  /** @nocollapse */\n\n  return MdcDialogContent;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\nlet MdcDialogActions = /*#__PURE__*/(() => {\n  class MdcDialogActions {\n    /**\n     * @param {?} elementRef\n     */\n    constructor(elementRef) {\n      this.elementRef = elementRef;\n      this._stacked = false;\n    }\n    /**\n     * @return {?}\n     */\n\n\n    get stacked() {\n      return this._stacked;\n    }\n    /**\n     * @param {?} value\n     * @return {?}\n     */\n\n\n    set stacked(value) {\n      this._stacked = coerceBooleanProperty(value);\n    }\n\n  }\n\n  MdcDialogActions.ɵfac = function MdcDialogActions_Factory(t) {\n    return new (t || MdcDialogActions)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef));\n  };\n\n  MdcDialogActions.ɵcmp = /*@__PURE__*/ɵngcc0.ɵɵdefineComponent({\n    type: MdcDialogActions,\n    selectors: [[\"mdc-dialog-actions\"], [\"\", \"mdcDialogActions\", \"\"]],\n    hostAttrs: [1, \"mdc-dialog__actions\"],\n    hostVars: 2,\n    hostBindings: function MdcDialogActions_HostBindings(rf, ctx) {\n      if (rf & 2) {\n        ɵngcc0.ɵɵclassProp(\"mdc-dialog--stacked\", ctx.stacked);\n      }\n    },\n    inputs: {\n      stacked: \"stacked\"\n    },\n    exportAs: [\"mdcDialogActions\"],\n    ngContentSelectors: _c0,\n    decls: 1,\n    vars: 0,\n    template: function MdcDialogActions_Template(rf, ctx) {\n      if (rf & 1) {\n        ɵngcc0.ɵɵprojectionDef();\n        ɵngcc0.ɵɵprojection(0);\n      }\n    },\n    encapsulation: 2,\n    changeDetection: 0\n  });\n  /** @nocollapse */\n\n  return MdcDialogActions;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\nlet MdcDialogButton = /*#__PURE__*/(() => {\n  class MdcDialogButton extends MdcButton {\n    constructor() {\n      super(...arguments);\n      this._default = false;\n    }\n    /**\n     * @return {?}\n     */\n\n\n    get default() {\n      return this._default;\n    }\n    /**\n     * @param {?} value\n     * @return {?}\n     */\n\n\n    set default(value) {\n      this._default = coerceBooleanProperty(value);\n    }\n\n  }\n\n  MdcDialogButton.ɵfac = /*@__PURE__*/function () {\n    let ɵMdcDialogButton_BaseFactory;\n    return function MdcDialogButton_Factory(t) {\n      return (ɵMdcDialogButton_BaseFactory || (ɵMdcDialogButton_BaseFactory = ɵngcc0.ɵɵgetInheritedFactory(MdcDialogButton)))(t || MdcDialogButton);\n    };\n  }();\n\n  MdcDialogButton.ɵcmp = /*@__PURE__*/ɵngcc0.ɵɵdefineComponent({\n    type: MdcDialogButton,\n    selectors: [[\"\", \"mdcDialogButton\", \"\"]],\n    hostAttrs: [1, \"mdc-dialog__button\"],\n    hostVars: 4,\n    hostBindings: function MdcDialogButton_HostBindings(rf, ctx) {\n      if (rf & 2) {\n        ɵngcc0.ɵɵclassProp(\"mdc-button\", true)(\"mdc-dialog__button--default\", ctx.default);\n      }\n    },\n    inputs: {\n      default: \"default\"\n    },\n    exportAs: [\"mdcDialogButton\"],\n    features: [ɵngcc0.ɵɵProvidersFeature([MdcRipple]), ɵngcc0.ɵɵInheritDefinitionFeature],\n    attrs: _c1,\n    ngContentSelectors: _c0,\n    decls: 2,\n    vars: 0,\n    consts: [[1, \"mdc-button__ripple\"]],\n    template: function MdcDialogButton_Template(rf, ctx) {\n      if (rf & 1) {\n        ɵngcc0.ɵɵprojectionDef();\n        ɵngcc0.ɵɵelement(0, \"div\", 0);\n        ɵngcc0.ɵɵprojection(1);\n      }\n    },\n    encapsulation: 2,\n    changeDetection: 0\n  });\n  return MdcDialogButton;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n/**\n * @fileoverview added by tsickle\n * Generated from: dialog/dialog-ref.ts\n * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n\n/**\n * Unique id for the created dialog.\n * @type {?}\n */\n\n\nlet uniqueId = 0;\n/**\n * Reference to a dialog dispatched from the MdcDialog service.\n * @template T, R\n */\n\nclass MdcDialogRef {\n  /**\n   * @param {?} _overlayRef\n   * @param {?} _portalInstance\n   * @param {?=} id\n   */\n  constructor(_overlayRef, _portalInstance, id = `mdc-dialog-${uniqueId++}`) {\n    this._overlayRef = _overlayRef;\n    this._portalInstance = _portalInstance;\n    this.id = id;\n    /**\n     * Subject for notifying the user that the dialog has finished opening.\n     */\n\n    this._afterOpened = new Subject();\n    /**\n     * Subject for notifying the user that the dialog has started closing.\n     */\n\n    this._beforeClosed = new Subject();\n    /**\n     * Subject for notifying the user that the dialog has finished closing.\n     */\n\n    this._afterClosed = new Subject(); // Pass the id along to the portal.\n\n    _portalInstance._id = id;\n\n    _overlayRef.detachments().subscribe(\n    /**\n    * @return {?}\n    */\n    () => {\n      this._beforeClosed.next(this._result);\n\n      this._beforeClosed.complete();\n\n      this._afterClosed.next(this._result);\n\n      this._afterClosed.complete();\n\n      this.componentInstance =\n      /** @type {?} */\n      null;\n\n      this._overlayRef.dispose();\n    });\n  }\n  /**\n   * Close the dialog.\n   * @param {?=} dialogResult Optional result to return to the dialog opener.\n   * @return {?}\n   */\n\n\n  close(dialogResult) {\n    this._result = dialogResult;\n\n    this._overlayRef.dispose();\n  }\n  /**\n   * Marks the dialog as opened.\n   * @return {?}\n   */\n\n\n  opened() {\n    if (!this._afterOpened.closed) {\n      this._afterOpened.next();\n\n      this._afterOpened.complete();\n    }\n  }\n  /**\n   * Gets an observable that is notified when the dialog is finished opening.\n   * @return {?}\n   */\n\n\n  afterOpened() {\n    return this._afterOpened.asObservable();\n  }\n  /**\n   * Gets an observable that is notified when the dialog has started closing.\n   * @return {?}\n   */\n\n\n  beforeClosed() {\n    return this._beforeClosed.asObservable();\n  }\n  /**\n   * Gets an observable that is notified when the dialog is finished closing.\n   * @return {?}\n   */\n\n\n  afterClosed() {\n    return this._afterClosed.asObservable();\n  }\n\n}\n/**\n * @fileoverview added by tsickle\n * Generated from: dialog/dialog.component.ts\n * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n\n/** @type {?} */\n\n\nconst LAYOUT_EVENTS = ['resize', 'orientationchange'];\nlet MdcDialogComponent = /*#__PURE__*/(() => {\n  class MdcDialogComponent extends MDCComponent {\n    /**\n     * @param {?} _ngZone\n     * @param {?} _platform\n     * @param {?} elementRef\n     * @param {?} dialogRef\n     */\n    constructor(_ngZone, _platform, elementRef, dialogRef) {\n      super(elementRef);\n      this._ngZone = _ngZone;\n      this._platform = _platform;\n      this.elementRef = elementRef;\n      this.dialogRef = dialogRef;\n      /**\n       * Emits whenever the component is destroyed.\n       */\n\n      this._destroy = new Subject();\n      this._scrollable = true;\n      this._layoutEventSubscription = null;\n      this.config = dialogRef._portalInstance._config;\n    }\n    /**\n     * Combined stream of all of the dialog layout events.\n     * @return {?}\n     */\n\n\n    get layoutEvents() {\n      return merge(...LAYOUT_EVENTS.map(\n      /**\n      * @param {?} evt\n      * @return {?}\n      */\n      evt => fromEvent(window, evt)));\n    }\n    /**\n     * @return {?}\n     */\n\n\n    getDefaultFoundation() {\n      /** @type {?} */\n      const adapter = {\n        addClass:\n        /**\n        * @param {?} className\n        * @return {?}\n        */\n        className => this._getDialog().classList.add(className),\n        removeClass:\n        /**\n        * @param {?} className\n        * @return {?}\n        */\n        className => this._getDialog().classList.remove(className),\n        getInitialFocusEl:\n        /**\n        * @return {?}\n        */\n        () => this._platform.isBrowser ?\n        /** @type {?} */\n        document.querySelector(`[cdkFocusInitial]`) : null,\n        hasClass:\n        /**\n        * @param {?} className\n        * @return {?}\n        */\n        className => this._getDialog().classList.contains(className),\n        addBodyClass:\n        /**\n        * @param {?} className\n        * @return {?}\n        */\n        className => {\n          if (this._platform.isBrowser) {\n            /** @type {?} */\n            document.body.classList.add(className);\n          }\n        },\n        removeBodyClass:\n        /**\n        * @param {?} className\n        * @return {?}\n        */\n        className => {\n          if (this._platform.isBrowser) {\n            /** @type {?} */\n            document.body.classList.remove(className);\n          }\n        },\n        eventTargetMatches:\n        /**\n        * @param {?} target\n        * @param {?} selector\n        * @return {?}\n        */\n        (target, selector) => matches(\n        /** @type {?} */\n        target, selector),\n        trapFocus:\n        /**\n        * @return {?}\n        */\n        () => {},\n        releaseFocus:\n        /**\n        * @return {?}\n        */\n        () => {},\n        isContentScrollable:\n        /**\n        * @return {?}\n        */\n        () => !!this._content && this._scrollable && util.isScrollable(this._content.elementRef.nativeElement),\n        areButtonsStacked:\n        /**\n        * @return {?}\n        */\n        () => util.areTopsMisaligned(\n        /** @type {?} */\n        this._buttons),\n        getActionFromEvent:\n        /**\n        * @param {?} event\n        * @return {?}\n        */\n        event => {\n          /** @type {?} */\n          const element = closest(\n          /** @type {?} */\n          event.target, `[${strings.ACTION_ATTRIBUTE}]`);\n          return element && element.getAttribute(strings.ACTION_ATTRIBUTE);\n        },\n        clickDefaultButton:\n        /**\n        * @return {?}\n        */\n        () => {\n          var _a, _b, _c;\n          /** @type {?} */\n\n\n          const defaultBtn = this._buttons.find(\n          /**\n          * @param {?} _\n          * @return {?}\n          */\n          _ => _.default);\n\n          (_c = (_b = (_a = defaultBtn) === null || _a === void 0 ? void 0 : _a.elementRef) === null || _b === void 0 ? void 0 : _b.nativeElement) === null || _c === void 0 ? void 0 : _c.click();\n        },\n        reverseButtons:\n        /**\n        * @return {?}\n        */\n        () => {\n          this._buttons.toArray().reverse();\n\n          this._buttons.forEach(\n          /**\n          * @param {?} button\n          * @return {?}\n          */\n          button =>\n          /** @type {?} */\n          button.getHostElement().parentElement.appendChild(button.getHostElement()));\n        },\n        notifyOpened:\n        /**\n        * @return {?}\n        */\n        () => this.dialogRef.opened(),\n        notifyOpening:\n        /**\n        * @return {?}\n        */\n        () => {},\n        notifyClosed:\n        /**\n        * @param {?} action\n        * @return {?}\n        */\n        action => this._closeDialogByRef(action),\n        notifyClosing:\n        /**\n        * @return {?}\n        */\n        () => {}\n      };\n      return new MDCDialogFoundation(adapter);\n    }\n    /**\n     * @return {?}\n     */\n\n\n    ngAfterViewInit() {\n      this._foundation = this.getDefaultFoundation();\n\n      this._initialize();\n\n      this._loadListeners();\n\n      this._foundation.open();\n    }\n    /**\n     * @private\n     * @return {?}\n     */\n\n\n    _initialize() {\n      this._scrollable = !!this.config.scrollable;\n\n      if (!this.config.clickOutsideToClose) {\n        this._foundation.setScrimClickAction('');\n      }\n\n      if (!this.config.escapeToClose) {\n        this._foundation.setEscapeKeyAction('');\n      }\n\n      if (!this.config.buttonsStacked) {\n        this._foundation.setAutoStackButtons(false);\n      }\n    }\n    /**\n     * @return {?}\n     */\n\n\n    ngOnDestroy() {\n      var _a, _b;\n\n      this._destroy.next();\n\n      this._destroy.complete();\n\n      (_a = this._layoutEventSubscription) === null || _a === void 0 ? void 0 : _a.unsubscribe();\n      (_b = this._foundation) === null || _b === void 0 ? void 0 : _b.destroy();\n    }\n    /**\n     * Recalculates layout and automatically adds/removes modifier classes like --scrollable.\n     * @return {?}\n     */\n\n\n    layout() {\n      this._foundation.layout();\n    }\n    /**\n     * @param {?} evt\n     * @return {?}\n     */\n\n\n    _onKeydown(evt) {\n      this._foundation.handleKeydown(evt);\n    }\n    /**\n     * @param {?} evt\n     * @return {?}\n     */\n\n\n    _onClick(evt) {\n      this._foundation.handleClick(evt);\n    }\n    /**\n     * @private\n     * @param {?=} action\n     * @return {?}\n     */\n\n\n    _closeDialogByRef(action) {\n      this.dialogRef.close(action);\n    }\n    /**\n     * @private\n     * @return {?}\n     */\n\n\n    _loadListeners() {\n      this._layoutEventSubscription = this.layoutEvents.pipe().subscribe(\n      /**\n      * @return {?}\n      */\n      () => this.layout());\n\n      if (this._platform.isBrowser) {\n        this._ngZone.runOutsideAngular(\n        /**\n        * @return {?}\n        */\n        () => fromEvent(document, 'keydown').pipe(takeUntil(this._destroy)).subscribe(\n        /**\n        * @param {?} evt\n        * @return {?}\n        */\n        evt => this._ngZone.run(\n        /**\n        * @return {?}\n        */\n        () => this._foundation.handleDocumentKeydown(evt))));\n      }\n    }\n    /**\n     * Retrieves the DOM element of the component host.\n     * @private\n     * @return {?}\n     */\n\n\n    _getDialog() {\n      return this._elementRef.nativeElement;\n    }\n\n  }\n\n  MdcDialogComponent.ɵfac = function MdcDialogComponent_Factory(t) {\n    return new (t || MdcDialogComponent)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.NgZone), ɵngcc0.ɵɵdirectiveInject(ɵngcc1.Platform), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef), ɵngcc0.ɵɵdirectiveInject(MdcDialogRef));\n  };\n\n  MdcDialogComponent.ɵcmp = /*@__PURE__*/ɵngcc0.ɵɵdefineComponent({\n    type: MdcDialogComponent,\n    selectors: [[\"mdc-dialog\"]],\n    contentQueries: function MdcDialogComponent_ContentQueries(rf, ctx, dirIndex) {\n      if (rf & 1) {\n        ɵngcc0.ɵɵcontentQuery(dirIndex, MdcDialogSurface, 5);\n        ɵngcc0.ɵɵcontentQuery(dirIndex, MdcDialogContent, 5);\n        ɵngcc0.ɵɵcontentQuery(dirIndex, MdcDialogButton, 5);\n      }\n\n      if (rf & 2) {\n        let _t;\n\n        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx._surface = _t.first);\n        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx._content = _t.first);\n        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx._buttons = _t);\n      }\n    },\n    hostAttrs: [\"role\", \"alertdialog\", 1, \"mdc-dialog\"],\n    hostVars: 5,\n    hostBindings: function MdcDialogComponent_HostBindings(rf, ctx) {\n      if (rf & 1) {\n        ɵngcc0.ɵɵlistener(\"click\", function MdcDialogComponent_click_HostBindingHandler($event) {\n          return ctx._onClick($event);\n        })(\"keydown\", function MdcDialogComponent_keydown_HostBindingHandler($event) {\n          return ctx._onKeydown($event);\n        });\n      }\n\n      if (rf & 2) {\n        ɵngcc0.ɵɵattribute(\"id\", ctx.config == null ? null : ctx.config.id)(\"aria-modal\", true)(\"aria-labelledby\", ctx.config == null ? null : ctx.config.ariaLabel)(\"aria-label\", ctx.config == null ? null : ctx.config.ariaLabel)(\"aria-describedby\", (ctx.config == null ? null : ctx.config.ariaDescribedBy) || null);\n      }\n    },\n    exportAs: [\"mdc-dialog\"],\n    features: [ɵngcc0.ɵɵInheritDefinitionFeature],\n    ngContentSelectors: _c0,\n    decls: 2,\n    vars: 0,\n    template: function MdcDialogComponent_Template(rf, ctx) {\n      if (rf & 1) {\n        ɵngcc0.ɵɵprojectionDef();\n        ɵngcc0.ɵɵelement(0, \"mdc-dialog-scrim\");\n        ɵngcc0.ɵɵprojection(1);\n      }\n    },\n    directives: [MdcDialogScrim],\n    encapsulation: 2,\n    changeDetection: 0\n  });\n  /** @nocollapse */\n\n  return MdcDialogComponent;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n/**\n * @fileoverview added by tsickle\n * Generated from: dialog/dialog-config.ts\n * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n\n/**\n * @template D\n */\n\n\nclass MdcDialogConfig {\n  constructor() {\n    /**\n     * ID of the element that describes the dialog.\n     */\n    this.ariaDescribedBy = null;\n    /**\n     * Aria label to assign to the dialog element\n     */\n\n    this.ariaLabel = null;\n    /**\n     * Whether the user can use escape key to close the dialog\n     */\n\n    this.escapeToClose = true;\n    /**\n     * Whether the user can click outside to close the dialog\n     */\n\n    this.clickOutsideToClose = true;\n    /**\n     * Applied automatically when the dialog has overflowing content to warrant scrolling.\n     */\n\n    this.scrollable = true;\n    /**\n     * Applied automatically when the dialog's action buttons can't fit on a single line and must be stacked.\n     */\n\n    this.buttonsStacked = true;\n    /**\n     * Whether the dialog should focus the first focusable element on open.\n     */\n\n    this.autoFocus = true;\n    /**\n     * Whether the dialog should restore focus to the\n     * previously-focused element, after it's closed.\n     */\n\n    this.restoreFocus = true;\n    /**\n     * Data to be injected into the dialog content.\n     */\n\n    this.data = null;\n  }\n\n}\n/**\n * @fileoverview added by tsickle\n * Generated from: dialog/dialog-portal.ts\n * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n\n/**\n * Throws an exception for the case when a ComponentPortal is\n * attached to a DomPortalOutlet without an origin.\n * @return {?}\n */\n\n\nfunction throwMdcDialogContentAlreadyAttachedError() {\n  throw Error('Attempting to attach dialog content after content is already attached');\n}\n\nlet MdcDialogPortal = /*#__PURE__*/(() => {\n  class MdcDialogPortal extends BasePortalOutlet {\n    /**\n     * @param {?} _elementRef\n     * @param {?} _focusTrapFactory\n     * @param {?} _document\n     * @param {?} _config\n     */\n    constructor(_elementRef, _focusTrapFactory, _document, _config) {\n      super();\n      this._elementRef = _elementRef;\n      this._focusTrapFactory = _focusTrapFactory;\n      this._document = _document;\n      this._config = _config;\n      /**\n       * Element that was focused before the dialog was opened. Save this to restore upon close.\n       */\n\n      this._elementFocusedBeforeDialogWasOpened = null;\n      /**\n       * A subject emitting after the dialog exits the view.\n       */\n\n      this._afterExit = new Subject();\n    }\n    /**\n     * Attach a ComponentPortal as content to this dialog container.\n     * @template T\n     * @param {?} portal Portal to be attached as the dialog content.\n     * @return {?}\n     */\n\n\n    attachComponentPortal(portal) {\n      if (this._portalOutlet.hasAttached()) {\n        throwMdcDialogContentAlreadyAttachedError();\n      }\n\n      this._savePreviouslyFocusedElement();\n\n      return this._portalOutlet.attachComponentPortal(portal);\n    }\n    /**\n     * Attach a TemplatePortal as content to this dialog container.\n     * @template C\n     * @param {?} portal Portal to be attached as the dialog content.\n     * @return {?}\n     */\n\n\n    attachTemplatePortal(portal) {\n      if (this._portalOutlet.hasAttached()) {\n        throwMdcDialogContentAlreadyAttachedError();\n      }\n\n      this._savePreviouslyFocusedElement();\n\n      return this._portalOutlet.attachTemplatePortal(portal);\n    }\n    /**\n     * Moves the focus inside the focus trap.\n     * @return {?}\n     */\n\n\n    trapFocus() {\n      /** @type {?} */\n      const element = this._elementRef.nativeElement;\n\n      if (!this._focusTrap) {\n        this._focusTrap = this._focusTrapFactory.create(element);\n      } // If we were to attempt to focus immediately, then the content of the dialog would not yet be\n      // ready in instances where change detection has to run first. To deal with this, we simply\n      // wait for the microtask queue to be empty.\n\n\n      if (this._config.autoFocus) {\n        this._focusTrap.focusInitialElementWhenReady();\n      } else {\n        /** @type {?} */\n        const activeElement = this._document.activeElement; // Otherwise ensure that focus is on the dialog container. It's possible that a different\n        // component tried to move focus. Note that we only want to do this\n        // if the focus isn't inside the dialog already, because it's possible that the consumer\n        // turned off `autoFocus` in order to move focus themselves.\n\n        if (activeElement !== element && !element.contains(activeElement)) {\n          element.focus();\n        }\n      }\n    }\n    /**\n     * Restores focus to the element that was focused before the dialog opened.\n     * @return {?}\n     */\n\n\n    restoreFocus() {\n      /** @type {?} */\n      const toFocus = this._elementFocusedBeforeDialogWasOpened; // We need the extra check, because IE can set the `activeElement` to null in some cases.\n\n      if (this._config.restoreFocus && toFocus && typeof toFocus.focus === 'function') {\n        toFocus.focus();\n      }\n\n      if (this._focusTrap) {\n        this._focusTrap.destroy();\n      }\n    }\n    /**\n     * Saves a reference to the element that was focused before the dialog was opened.\n     * @private\n     * @return {?}\n     */\n\n\n    _savePreviouslyFocusedElement() {\n      if (this._document) {\n        this._elementFocusedBeforeDialogWasOpened =\n        /** @type {?} */\n        this._document.activeElement; // Note that there is no focus method when rendering on the server.\n\n        if (this._elementRef.nativeElement.focus) {\n          // Move focus onto the dialog immediately in order to prevent the user from accidentally\n          // opening multiple dialogs at the same time. Needs to be async, because the element\n          // may not be focusable immediately.\n          Promise.resolve().then(\n          /**\n          * @return {?}\n          */\n          () => this._elementRef.nativeElement.focus());\n        }\n      }\n    }\n\n  }\n\n  MdcDialogPortal.ɵfac = function MdcDialogPortal_Factory(t) {\n    return new (t || MdcDialogPortal)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef), ɵngcc0.ɵɵdirectiveInject(ɵngcc2.FocusTrapFactory), ɵngcc0.ɵɵdirectiveInject(DOCUMENT, 8), ɵngcc0.ɵɵdirectiveInject(MdcDialogConfig));\n  };\n\n  MdcDialogPortal.ɵcmp = /*@__PURE__*/ɵngcc0.ɵɵdefineComponent({\n    type: MdcDialogPortal,\n    selectors: [[\"mdc-dialog-portal\"]],\n    viewQuery: function MdcDialogPortal_Query(rf, ctx) {\n      if (rf & 1) {\n        ɵngcc0.ɵɵviewQuery(CdkPortalOutlet, 7);\n      }\n\n      if (rf & 2) {\n        let _t;\n\n        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx._portalOutlet = _t.first);\n      }\n    },\n    hostVars: 1,\n    hostBindings: function MdcDialogPortal_HostBindings(rf, ctx) {\n      if (rf & 2) {\n        ɵngcc0.ɵɵattribute(\"id\", ctx._id);\n      }\n    },\n    features: [ɵngcc0.ɵɵInheritDefinitionFeature],\n    decls: 1,\n    vars: 0,\n    consts: [[\"cdkPortalOutlet\", \"\"]],\n    template: function MdcDialogPortal_Template(rf, ctx) {\n      if (rf & 1) {\n        ɵngcc0.ɵɵtemplate(0, MdcDialogPortal_ng_template_0_Template, 0, 0, \"ng-template\", 0);\n      }\n    },\n    directives: [ɵngcc3.CdkPortalOutlet],\n    encapsulation: 2\n  });\n  /** @nocollapse */\n\n  return MdcDialogPortal;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n/**\n * @fileoverview added by tsickle\n * Generated from: dialog/dialog.ts\n * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n\n/**\n * Injection token that can be used to access the data that was passed in to a dialog.\n * @type {?}\n */\n\n\nconst MDC_DIALOG_DATA = new InjectionToken('MdcDialogData');\n/**\n * Injection token that can be used to specify default dialog options.\n * @type {?}\n */\n\nconst MDC_DIALOG_DEFAULT_OPTIONS = new InjectionToken('mdc-dialog-default-options');\nlet MdcDialog = /*#__PURE__*/(() => {\n  class MdcDialog {\n    /**\n     * @param {?} _overlay\n     * @param {?} _injector\n     * @param {?} _defaultOptions\n     * @param {?} _parentDialog\n     */\n    constructor(_overlay, _injector, _defaultOptions, _parentDialog) {\n      this._overlay = _overlay;\n      this._injector = _injector;\n      this._defaultOptions = _defaultOptions;\n      this._parentDialog = _parentDialog;\n      this._openDialogsAtThisLevel = [];\n      this._afterAllClosedAtThisLevel = new Subject();\n      this._afterOpenedAtThisLevel = new Subject();\n      this._ariaHiddenElements = new Map();\n      /**\n       * Stream that emits when all open dialog have finished closing.\n       * Will emit on subscribe if there are no open dialogs to begin with.\n       */\n\n      this.afterAllClosed =\n      /** @type {?} */\n      defer(\n      /**\n      * @return {?}\n      */\n      () => this.openDialogs.length ? this._afterAllClosed : this._afterAllClosed.pipe(startWith(undefined)));\n    }\n    /**\n     * Keeps track of the currently-open dialogs.\n     * @return {?}\n     */\n\n\n    get openDialogs() {\n      return this._parentDialog ? this._parentDialog.openDialogs : this._openDialogsAtThisLevel;\n    }\n    /**\n     * Stream that emits when a dialog has been opened.\n     * @return {?}\n     */\n\n\n    get afterOpened() {\n      return this._parentDialog ? this._parentDialog.afterOpened : this._afterOpenedAtThisLevel;\n    }\n    /**\n     * @return {?}\n     */\n\n\n    get _afterAllClosed() {\n      /** @type {?} */\n      const parent = this._parentDialog;\n      return parent ? parent._afterAllClosed : this._afterAllClosedAtThisLevel;\n    }\n    /**\n     * Opens a modal dialog containing the given template.\n     * @template T, D, R\n     * @param {?} componentOrTemplateRef Type of the component to load into the dialog,\n     *     or a TemplateRef to instantiate as the dialog content.\n     * @param {?=} config Extra configuration options.\n     * @return {?} Reference to the newly-opened dialog.\n     */\n\n\n    open(componentOrTemplateRef, config) {\n      config = _applyConfigDefaults(config, this._defaultOptions || new MdcDialogConfig());\n\n      if (config.id && this.getDialogById(config.id)) {\n        throw Error(`Dialog with id \"${config.id}\" exists already. The dialog id must be unique.`);\n      }\n      /** @type {?} */\n\n\n      const overlayRef = this._createOverlay();\n      /** @type {?} */\n\n\n      const dialogContainer = this._attachDialogContainer(overlayRef, config);\n      /** @type {?} */\n\n\n      const dialogRef = this._attachDialogContent(componentOrTemplateRef, dialogContainer, overlayRef, config);\n\n      this.openDialogs.push(dialogRef);\n      dialogRef.afterClosed().subscribe(\n      /**\n      * @return {?}\n      */\n      () => this._removeOpenDialog(dialogRef, dialogContainer));\n      this.afterOpened.next(dialogRef);\n      return dialogRef;\n    }\n    /**\n     * Closes all of the currently-open dialogs.\n     * @return {?}\n     */\n\n\n    closeAll() {\n      this._closeDialogs(this.openDialogs);\n    }\n    /**\n     * Finds an open dialog by its id.\n     * @param {?} id ID to use when looking up the dialog.\n     * @return {?}\n     */\n\n\n    getDialogById(id) {\n      return this.openDialogs.find(\n      /**\n      * @param {?} dialog\n      * @return {?}\n      */\n      dialog => dialog.id === id);\n    }\n    /**\n     * @return {?}\n     */\n\n\n    ngOnDestroy() {\n      // Only close the dialogs at this level on destroy\n      // since the parent service may still be active.\n      this._closeDialogs(this._openDialogsAtThisLevel);\n\n      this._afterAllClosedAtThisLevel.complete();\n\n      this._afterOpenedAtThisLevel.complete();\n    }\n    /**\n     * Creates the overlay into which the dialog will be loaded.\n     * @private\n     * @return {?} A promise resolving to the OverlayRef for the created overlay.\n     */\n\n\n    _createOverlay() {\n      return this._overlay.create();\n    }\n    /**\n     * Attaches an MdcDialogPortal to a dialog's already-created overlay.\n     * @private\n     * @param {?} overlay Reference to the dialog's underlying overlay.\n     * @param {?} config The dialog configuration.\n     * @return {?} A promise resolving to a ComponentRef for the attached container.\n     */\n\n\n    _attachDialogContainer(overlay, config) {\n      /** @type {?} */\n      const userInjector = config && config.viewContainerRef && config.viewContainerRef.injector;\n      /** @type {?} */\n\n      const injector = new PortalInjector(userInjector || this._injector, new WeakMap([[MdcDialogConfig, config]]));\n      /** @type {?} */\n\n      const containerPortal = new ComponentPortal(MdcDialogPortal, config.viewContainerRef, injector, config.componentFactoryResolver);\n      /** @type {?} */\n\n      const containerRef = overlay.attach(containerPortal);\n      return containerRef.instance;\n    }\n    /**\n     * Attaches the user-provided component to the already-created MdcDialogPortal.\n     * @private\n     * @template T, R\n     * @param {?} componentOrTemplateRef The type of component being loaded into the dialog,\n     *     or a TemplateRef to instantiate as the content.\n     * @param {?} dialogContainer Reference to the wrapping MdcDialogPortal.\n     * @param {?} overlayRef Reference to the overlay in which the dialog resides.\n     * @param {?} config The dialog configuration.\n     * @return {?} A promise resolving to the MdcDialogRef that should be returned to the user.\n     */\n\n\n    _attachDialogContent(componentOrTemplateRef, dialogContainer, overlayRef, config) {\n      // Create a reference to the dialog we're creating in order to give the user a handle\n      // to modify and close it.\n\n      /** @type {?} */\n      const dialogRef = new MdcDialogRef(overlayRef, dialogContainer, config.id);\n\n      if (componentOrTemplateRef instanceof TemplateRef) {\n        dialogContainer.attachTemplatePortal(new TemplatePortal(componentOrTemplateRef,\n        /** @type {?} */\n        null,\n        /** @type {?} */\n        {\n          $implicit: config.data,\n          dialogRef\n        }));\n      } else {\n        /** @type {?} */\n        const injector = this._createInjector(config, dialogRef, dialogContainer);\n        /** @type {?} */\n\n\n        const contentRef = dialogContainer.attachComponentPortal(new ComponentPortal(componentOrTemplateRef, config.viewContainerRef, injector));\n        dialogRef.componentInstance = contentRef.instance;\n      }\n\n      return dialogRef;\n    }\n    /**\n     * Creates a custom injector to be used inside the dialog. This allows a component loaded inside\n     * of a dialog to close itself and, optionally, to return a value.\n     * @private\n     * @template T\n     * @param {?} config Config object that is used to construct the dialog.\n     * @param {?} dialogRef Reference to the dialog.\n     * @param {?} portalContainer\n     * @return {?} The custom injector that can be used inside the dialog.\n     */\n\n\n    _createInjector(config, dialogRef, portalContainer) {\n      /** @type {?} */\n      const userInjector = config && config.viewContainerRef && config.viewContainerRef.injector;\n      portalContainer.trapFocus(); // The MdcDialogPortal is injected in the portal as the MdcDialogPortal and the dialog's\n      // content are created out of the same ViewContainerRef and as such, are siblings for injector\n      // purposes. To allow the hierarchy that is expected, the MdcDialogPortal is explicitly\n      // added to the injection tokens.\n\n      /** @type {?} */\n\n      const injectionTokens = new WeakMap([[MdcDialogPortal, portalContainer], [MDC_DIALOG_DATA, config.data], [MdcDialogRef, dialogRef]]);\n      return new PortalInjector(userInjector || this._injector, injectionTokens);\n    }\n    /**\n     * Removes a dialog from the array of open dialogs.\n     * @private\n     * @param {?} dialogRef Dialog to be removed.\n     * @param {?} dialogContainer\n     * @return {?}\n     */\n\n\n    _removeOpenDialog(dialogRef, dialogContainer) {\n      /** @type {?} */\n      const index = this.openDialogs.indexOf(dialogRef);\n\n      if (index > -1) {\n        dialogContainer.restoreFocus();\n        this.openDialogs.splice(index, 1); // If all the dialogs were closed, remove/restore the `aria-hidden`\n        // to a the siblings and emit to the `afterAllClosed` stream.\n\n        if (!this.openDialogs.length) {\n          this._ariaHiddenElements.forEach(\n          /**\n          * @param {?} previousValue\n          * @param {?} element\n          * @return {?}\n          */\n          (previousValue, element) => {\n            if (previousValue) {\n              element.setAttribute('aria-hidden', previousValue);\n            } else {\n              element.removeAttribute('aria-hidden');\n            }\n          });\n\n          this._ariaHiddenElements.clear();\n\n          this._afterAllClosed.next();\n        }\n      }\n    }\n    /**\n     * Closes all of the dialogs in an array.\n     * @private\n     * @param {?} dialogs\n     * @return {?}\n     */\n\n\n    _closeDialogs(dialogs) {\n      /** @type {?} */\n      let i = dialogs.length;\n\n      while (i--) {\n        // The `_openDialogs` property isn't updated after close until the rxjs subscription\n        // runs on the next microtask, in addition to modifying the array as we're going\n        // through it. We loop through all of them and call close without assuming that\n        // they'll be removed from the list instantaneously.\n        dialogs[i].close();\n      }\n    }\n\n  }\n\n  MdcDialog.ɵfac = function MdcDialog_Factory(t) {\n    return new (t || MdcDialog)(ɵngcc0.ɵɵinject(ɵngcc4.Overlay), ɵngcc0.ɵɵinject(ɵngcc0.Injector), ɵngcc0.ɵɵinject(MDC_DIALOG_DEFAULT_OPTIONS, 8), ɵngcc0.ɵɵinject(MdcDialog, 12));\n  };\n\n  MdcDialog.ɵprov = /*@__PURE__*/ɵngcc0.ɵɵdefineInjectable({\n    token: MdcDialog,\n    factory: MdcDialog.ɵfac\n  });\n  /** @nocollapse */\n\n  return MdcDialog;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n/**\n * Applies default options to the dialog config.\n * @param {?=} config Config to be modified.\n * @param {?=} defaultOptions Default options provided.\n * @return {?} The new configuration object.\n */\n\n\nfunction _applyConfigDefaults(config, defaultOptions) {\n  return Object.assign(Object.assign({}, defaultOptions), config);\n}\n/**\n * @fileoverview added by tsickle\n * Generated from: dialog/module.ts\n * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n\n/** @type {?} */\n\n\nconst DIALOG_DECLARATIONS = [MdcDialogAction, MdcDialogActions, MdcDialogButton, MdcDialogComponent, MdcDialogContainer, MdcDialogPortal, MdcDialogContent, MdcDialogScrim, MdcDialogSurface, MdcDialogSurface, MdcDialogTitle];\nlet MdcDialogModule = /*#__PURE__*/(() => {\n  class MdcDialogModule {}\n\n  MdcDialogModule.ɵfac = function MdcDialogModule_Factory(t) {\n    return new (t || MdcDialogModule)();\n  };\n\n  MdcDialogModule.ɵmod = /*@__PURE__*/ɵngcc0.ɵɵdefineNgModule({\n    type: MdcDialogModule\n  });\n  MdcDialogModule.ɵinj = /*@__PURE__*/ɵngcc0.ɵɵdefineInjector({\n    providers: [MdcDialog],\n    imports: [[OverlayModule, PortalModule]]\n  });\n  return MdcDialogModule;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\n(function () {\n  (typeof ngJitMode === \"undefined\" || ngJitMode) && ɵngcc0.ɵɵsetNgModuleScope(MdcDialogModule, {\n    declarations: function () {\n      return [MdcDialogAction, MdcDialogActions, MdcDialogButton, MdcDialogComponent, MdcDialogContainer, MdcDialogPortal, MdcDialogContent, MdcDialogScrim, MdcDialogSurface, MdcDialogSurface, MdcDialogTitle];\n    },\n    imports: function () {\n      return [OverlayModule, PortalModule];\n    },\n    exports: function () {\n      return [MdcDialogAction, MdcDialogActions, MdcDialogButton, MdcDialogComponent, MdcDialogContainer, MdcDialogPortal, MdcDialogContent, MdcDialogScrim, MdcDialogSurface, MdcDialogSurface, MdcDialogTitle];\n    }\n  });\n})();\n\nexport { MDC_DIALOG_DATA, MDC_DIALOG_DEFAULT_OPTIONS, MdcDialog, MdcDialogAction, MdcDialogActions, MdcDialogButton, MdcDialogComponent, MdcDialogConfig, MdcDialogContainer, MdcDialogContent, MdcDialogModule, MdcDialogPortal, MdcDialogRef, MdcDialogScrim, MdcDialogSurface, MdcDialogTitle, throwMdcDialogContentAlreadyAttachedError }; //# sourceMappingURL=dialog.js.map","map":null,"metadata":{},"sourceType":"module"}