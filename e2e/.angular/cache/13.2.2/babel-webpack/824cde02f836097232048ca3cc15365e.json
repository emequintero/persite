{"ast":null,"code":"/**\n * @license\n * Copyright (c) Dominic Carretto\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://github.com/trimox/angular-mdc-web/blob/master/LICENSE\n */\nimport { Component, ChangeDetectionStrategy, ViewEncapsulation, ElementRef, Input, EventEmitter, NgZone, ChangeDetectorRef, Optional, Inject, Output, ContentChild, Directive, NgModule } from '@angular/core';\nimport { DOCUMENT, CommonModule } from '@angular/common';\nimport { FocusTrapFactory, FocusMonitor } from '@angular/cdk/a11y';\nimport { coerceBooleanProperty } from '@angular/cdk/coercion';\nimport { Platform } from '@angular/cdk/platform';\nimport { Subject, fromEvent } from 'rxjs';\nimport { takeUntil } from 'rxjs/operators';\nimport { MDCComponent } from '@angular-mdc/web/base';\nimport { MdcList } from '@angular-mdc/web/list';\nimport { MDCModalDrawerFoundation, MDCDismissibleDrawerFoundation, cssClasses } from '@material/drawer';\n/**\n * @fileoverview added by tsickle\n * Generated from: drawer/drawer.ts\n * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n\nimport * as ɵngcc0 from '@angular/core';\nimport * as ɵngcc1 from '@angular/common';\nimport * as ɵngcc2 from '@angular/cdk/platform';\nimport * as ɵngcc3 from '@angular/cdk/a11y';\n\nfunction MdcDrawerHeader_h3_1_Template(rf, ctx) {\n  if (rf & 1) {\n    ɵngcc0.ɵɵelementStart(0, \"h3\", 2);\n    ɵngcc0.ɵɵtext(1);\n    ɵngcc0.ɵɵelementEnd();\n  }\n\n  if (rf & 2) {\n    const ctx_r0 = ɵngcc0.ɵɵnextContext();\n    ɵngcc0.ɵɵadvance(1);\n    ɵngcc0.ɵɵtextInterpolate(ctx_r0.title);\n  }\n}\n\nfunction MdcDrawerHeader_h6_2_Template(rf, ctx) {\n  if (rf & 1) {\n    ɵngcc0.ɵɵelementStart(0, \"h6\", 3);\n    ɵngcc0.ɵɵtext(1);\n    ɵngcc0.ɵɵelementEnd();\n  }\n\n  if (rf & 2) {\n    const ctx_r1 = ɵngcc0.ɵɵnextContext();\n    ɵngcc0.ɵɵadvance(1);\n    ɵngcc0.ɵɵtextInterpolate(ctx_r1.subtitle);\n  }\n}\n\nconst _c0 = [\"*\"];\nlet MdcDrawerHeader = /*#__PURE__*/(() => {\n  class MdcDrawerHeader {\n    /**\n     * @param {?} elementRef\n     */\n    constructor(elementRef) {\n      this.elementRef = elementRef;\n    }\n\n  }\n\n  MdcDrawerHeader.ɵfac = function MdcDrawerHeader_Factory(t) {\n    return new (t || MdcDrawerHeader)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef));\n  };\n\n  MdcDrawerHeader.ɵcmp = /*@__PURE__*/ɵngcc0.ɵɵdefineComponent({\n    type: MdcDrawerHeader,\n    selectors: [[\"mdc-drawer-header\"]],\n    hostAttrs: [1, \"mdc-drawer__header\"],\n    inputs: {\n      title: \"title\",\n      subtitle: \"subtitle\"\n    },\n    ngContentSelectors: _c0,\n    decls: 3,\n    vars: 2,\n    consts: [[\"class\", \"mdc-drawer__title\", 4, \"ngIf\"], [\"class\", \"mdc-drawer__subtitle\", 4, \"ngIf\"], [1, \"mdc-drawer__title\"], [1, \"mdc-drawer__subtitle\"]],\n    template: function MdcDrawerHeader_Template(rf, ctx) {\n      if (rf & 1) {\n        ɵngcc0.ɵɵprojectionDef();\n        ɵngcc0.ɵɵprojection(0);\n        ɵngcc0.ɵɵtemplate(1, MdcDrawerHeader_h3_1_Template, 2, 1, \"h3\", 0);\n        ɵngcc0.ɵɵtemplate(2, MdcDrawerHeader_h6_2_Template, 2, 1, \"h6\", 1);\n      }\n\n      if (rf & 2) {\n        ɵngcc0.ɵɵadvance(1);\n        ɵngcc0.ɵɵproperty(\"ngIf\", ctx.title);\n        ɵngcc0.ɵɵadvance(1);\n        ɵngcc0.ɵɵproperty(\"ngIf\", ctx.subtitle);\n      }\n    },\n    directives: [ɵngcc1.NgIf],\n    encapsulation: 2,\n    changeDetection: 0\n  });\n  /** @nocollapse */\n\n  return MdcDrawerHeader;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\nlet MdcDrawer = /*#__PURE__*/(() => {\n  class MdcDrawer extends MDCComponent {\n    /**\n     * @param {?} _platform\n     * @param {?} _ngZone\n     * @param {?} _changeDetectorRef\n     * @param {?} _focusTrapFactory\n     * @param {?} _focusMonitor\n     * @param {?} _document\n     * @param {?} elementRef\n     */\n    constructor(_platform, _ngZone, _changeDetectorRef, _focusTrapFactory, _focusMonitor, _document, elementRef) {\n      super(elementRef);\n      this._platform = _platform;\n      this._ngZone = _ngZone;\n      this._changeDetectorRef = _changeDetectorRef;\n      this._focusTrapFactory = _focusTrapFactory;\n      this._focusMonitor = _focusMonitor;\n      this._document = _document;\n      this.elementRef = elementRef;\n      /**\n       * Emits when the component is destroyed.\n       */\n\n      this._destroyed = new Subject();\n      this._scrimElement = null;\n      /**\n       * Element that was focused before the drawer was opened. Save this to restore upon close.\n       */\n\n      this._elementFocusedBeforeDrawerWasOpened = null;\n      this._open = false;\n      this._drawer = '';\n      this._autoFocus = true;\n      this._restoreFocus = true;\n      this.opened = new EventEmitter();\n      this.closed = new EventEmitter();\n      /**\n       * Event emitted when the drawer open state is changed.\n       */\n\n      this.openedChange = new EventEmitter(\n      /* isAsync */\n      true);\n      /**\n       * Event emitted when the drawer variant is changed.\n       */\n\n      this.drawerChange = new EventEmitter(\n      /* isAsync */\n      true);\n      this._scrimSubscription = null;\n      this.openedChange.subscribe(\n      /**\n      * @param {?} opened\n      * @return {?}\n      */\n      opened => {\n        if (opened) {\n          if (this._document) {\n            this._elementFocusedBeforeDrawerWasOpened =\n            /** @type {?} */\n            this._document.activeElement;\n          }\n\n          if (this._isFocusTrapEnabled && this._focusTrap) {\n            this._trapFocus();\n          }\n        } else {\n          this._releaseFocus();\n        }\n      });\n      this.drawerChange.subscribe(\n      /**\n      * @return {?}\n      */\n      () => this._initFoundation());\n      /**\n       * Listen to `keydown` events outside the zone so that change detection is not run every\n       * time a key is pressed. Instead we re-enter the zone only if the `ESC` key is pressed\n       * and we don't have close disabled.\n       */\n\n      this._ngZone.runOutsideAngular(\n      /**\n      * @return {?}\n      */\n      () => {\n        /** @type {?} */\n        fromEvent(this._elementRef.nativeElement, 'keydown').pipe(takeUntil(this._destroyed)).subscribe(\n        /**\n        * @param {?} event\n        * @return {?}\n        */\n        event => this._ngZone.run(\n        /**\n        * @return {?}\n        */\n        () => {\n          this._foundation.handleKeydown(event);\n\n          if (this.modal) {\n            event.stopPropagation();\n            event.preventDefault();\n          }\n        }));\n      });\n    }\n    /**\n     * @return {?}\n     */\n\n\n    get open() {\n      return this._open;\n    }\n    /**\n     * @param {?} value\n     * @return {?}\n     */\n\n\n    set open(value) {\n      if (this._platform.isBrowser && this._open !== value) {\n        this._open = coerceBooleanProperty(value);\n        this._open ? this._foundation.open() : this._foundation.close();\n        this.openedChange.emit(this._open);\n\n        this._updateFocusTrapState();\n\n        this._changeDetectorRef.markForCheck();\n      }\n    }\n    /**\n     * @return {?}\n     */\n\n\n    get drawer() {\n      return this._drawer;\n    }\n    /**\n     * @param {?} drawer\n     * @return {?}\n     */\n\n\n    set drawer(drawer) {\n      if (this._drawer !== drawer) {\n        this._drawer = drawer;\n        this.drawerChange.emit();\n\n        this._updateFocusTrapState();\n      }\n    }\n    /**\n     * @return {?}\n     */\n\n\n    get autoFocus() {\n      return this._autoFocus;\n    }\n    /**\n     * @param {?} value\n     * @return {?}\n     */\n\n\n    set autoFocus(value) {\n      this._autoFocus = coerceBooleanProperty(value);\n    }\n    /**\n     * @return {?}\n     */\n\n\n    get restoreFocus() {\n      return this._restoreFocus;\n    }\n    /**\n     * @param {?} value\n     * @return {?}\n     */\n\n\n    set restoreFocus(value) {\n      this._restoreFocus = coerceBooleanProperty(value);\n    }\n    /**\n     * @return {?}\n     */\n\n\n    get fixedAdjustElement() {\n      return this._fixedAdjustElement;\n    }\n    /**\n     * @param {?} element\n     * @return {?}\n     */\n\n\n    set fixedAdjustElement(element) {\n      this._fixedAdjustElement = element;\n      element ? this._getHostElement().style.setProperty('position', 'absolute') : this._getHostElement().style.removeProperty('position');\n\n      this._changeDetectorRef.markForCheck();\n    }\n    /**\n     * @return {?}\n     */\n\n\n    get modal() {\n      return this.drawer === 'modal';\n    }\n    /**\n     * @return {?}\n     */\n\n\n    get dismissible() {\n      return this.drawer === 'dismissible';\n    }\n    /**\n     * @return {?}\n     */\n\n\n    get _isFocusTrapEnabled() {\n      // The focus trap is only enabled when the drawer is open and modal.\n      return this.open && this.modal;\n    }\n    /**\n     * @return {?}\n     */\n\n\n    getDefaultFoundation() {\n      /** @type {?} */\n      const adapter = {\n        addClass:\n        /**\n        * @param {?} className\n        * @return {?}\n        */\n        className => this._getHostElement().classList.add(className),\n        removeClass:\n        /**\n        * @param {?} className\n        * @return {?}\n        */\n        className => this._getHostElement().classList.remove(className),\n        hasClass:\n        /**\n        * @param {?} className\n        * @return {?}\n        */\n        className => this._getHostElement().classList.contains(className),\n        elementHasClass:\n        /**\n        * @param {?} element\n        * @param {?} className\n        * @return {?}\n        */\n        (element, className) => element.classList.contains(className),\n        saveFocus:\n        /**\n        * @return {?}\n        */\n        () => this._savePreviouslyFocusedElement(),\n        restoreFocus:\n        /**\n        * @return {?}\n        */\n        () => this._releaseFocus(),\n        focusActiveNavigationItem:\n        /**\n        * @return {?}\n        */\n        () => {\n          var _a;\n\n          if (!this._platform.isBrowser || !this._list || !this._autoFocus) {\n            return;\n          }\n          /** @type {?} */\n\n\n          const selectedItem = this._list.getSelectedItem();\n\n          if (selectedItem) {\n            selectedItem.focus();\n          } else {\n            /** @type {?} */\n            const cdkInitialItem = this._platform.isBrowser ?\n            /** @type {?} */\n            document.querySelector(`[cdkFocusInitial]`) : null;\n            (_a = cdkInitialItem) === null || _a === void 0 ? void 0 : _a.focus();\n          }\n        },\n        notifyClose:\n        /**\n        * @return {?}\n        */\n        () => this.closed.emit(),\n        notifyOpen:\n        /**\n        * @return {?}\n        */\n        () => this.opened.emit(),\n        trapFocus:\n        /**\n        * @return {?}\n        */\n        () => {},\n        releaseFocus:\n        /**\n        * @return {?}\n        */\n        () => this._releaseFocus()\n      };\n      return this.modal ? new MDCModalDrawerFoundation(adapter) : new MDCDismissibleDrawerFoundation(adapter);\n    }\n    /**\n     * @return {?}\n     */\n\n\n    ngAfterContentInit() {\n      this._initListType();\n    }\n    /**\n     * @return {?}\n     */\n\n\n    ngOnDestroy() {\n      var _a, _b, _c;\n\n      this.open = false;\n      (_a = this._focusTrap) === null || _a === void 0 ? void 0 : _a.destroy();\n      (_b = this._scrimElement) === null || _b === void 0 ? void 0 : _b.remove();\n      (_c = this._scrimSubscription) === null || _c === void 0 ? void 0 : _c.unsubscribe();\n\n      this._destroyed.next();\n\n      this._destroyed.complete();\n\n      if (this._foundation && this._platform.isBrowser) {\n        this._foundation.destroy();\n      }\n    }\n    /**\n     * @param {?} event\n     * @return {?}\n     */\n\n\n    _handleTransitionEnd(event) {\n      this._foundation.handleTransitionEnd(event);\n    }\n    /**\n     * @private\n     * @return {?}\n     */\n\n\n    _createScrim() {\n      if (this._platform.isBrowser) {\n        this._scrimElement = document.createElement('div');\n\n        this._scrimElement.classList.add('mdc-drawer-scrim');\n\n        this._getHostElement().insertAdjacentElement('afterend', this._scrimElement);\n\n        this._scrimSubscription = this._ngZone.runOutsideAngular(\n        /**\n        * @return {?}\n        */\n        () => fromEvent(\n        /** @type {?} */\n        this._scrimElement, 'click').subscribe(\n        /**\n        * @return {?}\n        */\n        () => this._ngZone.run(\n        /**\n        * @return {?}\n        */\n        () => this.open = false)));\n      }\n    }\n    /**\n     * @private\n     * @return {?}\n     */\n\n\n    _initFoundation() {\n      this._getHostElement().classList.remove(cssClasses.MODAL);\n\n      this._getHostElement().classList.remove(cssClasses.DISMISSIBLE);\n\n      this._foundation = this.getDefaultFoundation();\n\n      this._foundation.init();\n\n      if (this.modal || this.dismissible) {\n        this._getHostElement().classList.add(`${cssClasses.ROOT}--${this.drawer}`);\n      }\n\n      if (this._scrimElement) {\n        if (this._scrimSubscription) {\n          this._scrimSubscription.unsubscribe();\n        }\n\n        this._scrimElement.remove();\n\n        this._scrimElement = null;\n      }\n\n      if (this.modal) {\n        this._focusTrap = this._focusTrapFactory.create(this._elementRef.nativeElement);\n\n        this._updateFocusTrapState();\n\n        this._createScrim();\n      } else if (this._focusTrap) {\n        this._focusTrap.destroy();\n      }\n\n      this._changeDetectorRef.markForCheck();\n    }\n    /**\n     * @private\n     * @return {?}\n     */\n\n\n    _initListType() {\n      if (this._list && (this._list.singleSelection || this._list.singleSelection === undefined)) {\n        this._list.wrapFocus = true;\n        this._list.singleSelection = true;\n        this._list.useActivatedClass = true;\n      }\n    }\n    /**\n     * Updates the enabled state of the focus trap.\n     * @private\n     * @return {?}\n     */\n\n\n    _updateFocusTrapState() {\n      if (this._focusTrap) {\n        this._focusTrap.enabled = this._isFocusTrapEnabled;\n      }\n    }\n    /**\n     * @private\n     * @return {?}\n     */\n\n\n    _trapFocus() {\n      if (!this.autoFocus) {\n        return;\n      }\n\n      this._focusTrap.focusInitialElementWhenReady().then(\n      /**\n      * @param {?} hasMovedFocus\n      * @return {?}\n      */\n      hasMovedFocus => {\n        // If there were no focusable elements, focus the drawer itself so the keyboard navigation\n        // still works. We need to check that `focus` is a function due to Universal.\n        if (!hasMovedFocus && typeof this._elementRef.nativeElement.focus === 'function') {\n          this._elementRef.nativeElement.focus();\n        }\n      });\n    }\n    /**\n     * Restores focus to the element that was focused before the drawer opened.\n     * @private\n     * @return {?}\n     */\n\n\n    _releaseFocus() {\n      if (!this.autoFocus) {\n        return;\n      }\n      /** @type {?} */\n\n\n      const activeEl = this._document && this._document.activeElement;\n\n      if (activeEl && this._elementRef.nativeElement.contains(activeEl)) {\n        if (this._elementFocusedBeforeDrawerWasOpened instanceof HTMLElement) {\n          this._focusMonitor.focusVia(this._elementFocusedBeforeDrawerWasOpened, this._openedVia);\n        } else {\n          this._elementRef.nativeElement.blur();\n        }\n      }\n\n      this._elementFocusedBeforeDrawerWasOpened = null;\n      this._openedVia = null;\n    }\n    /**\n     * Saves a reference to the element that was focused before the drawer was opened.\n     * @private\n     * @return {?}\n     */\n\n\n    _savePreviouslyFocusedElement() {\n      if (this._document) {\n        this._elementFocusedBeforeDrawerWasOpened =\n        /** @type {?} */\n        this._document.activeElement; // Note that there is no focus method when rendering on the server.\n\n        if (this._elementRef.nativeElement.focus) {\n          // Move focus onto the drawer immediately. Needs to be async, because the element\n          // may not be focusable immediately.\n          Promise.resolve().then(\n          /**\n          * @return {?}\n          */\n          () => this._elementRef.nativeElement.focus());\n        }\n      }\n    }\n    /**\n     * @private\n     * @return {?}\n     */\n\n\n    _getHostElement() {\n      return this.elementRef.nativeElement;\n    }\n\n  }\n\n  MdcDrawer.ɵfac = function MdcDrawer_Factory(t) {\n    return new (t || MdcDrawer)(ɵngcc0.ɵɵdirectiveInject(ɵngcc2.Platform), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.NgZone), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ChangeDetectorRef), ɵngcc0.ɵɵdirectiveInject(ɵngcc3.FocusTrapFactory), ɵngcc0.ɵɵdirectiveInject(ɵngcc3.FocusMonitor), ɵngcc0.ɵɵdirectiveInject(DOCUMENT, 8), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef));\n  };\n\n  MdcDrawer.ɵcmp = /*@__PURE__*/ɵngcc0.ɵɵdefineComponent({\n    type: MdcDrawer,\n    selectors: [[\"mdc-drawer\"]],\n    contentQueries: function MdcDrawer_ContentQueries(rf, ctx, dirIndex) {\n      if (rf & 1) {\n        ɵngcc0.ɵɵcontentQuery(dirIndex, MdcList, 5);\n      }\n\n      if (rf & 2) {\n        let _t;\n\n        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx._list = _t.first);\n      }\n    },\n    hostAttrs: [\"role\", \"navigation\", 1, \"mdc-drawer\"],\n    hostBindings: function MdcDrawer_HostBindings(rf, ctx) {\n      if (rf & 1) {\n        ɵngcc0.ɵɵlistener(\"transitionend\", function MdcDrawer_transitionend_HostBindingHandler($event) {\n          return ctx._handleTransitionEnd($event);\n        });\n      }\n    },\n    inputs: {\n      open: \"open\",\n      drawer: \"drawer\",\n      autoFocus: \"autoFocus\",\n      restoreFocus: \"restoreFocus\",\n      fixedAdjustElement: \"fixedAdjustElement\"\n    },\n    outputs: {\n      opened: \"opened\",\n      closed: \"closed\",\n      openedChange: \"openedChange\",\n      drawerChange: \"drawerChange\"\n    },\n    exportAs: [\"mdcDrawer\"],\n    features: [ɵngcc0.ɵɵInheritDefinitionFeature],\n    ngContentSelectors: _c0,\n    decls: 1,\n    vars: 0,\n    template: function MdcDrawer_Template(rf, ctx) {\n      if (rf & 1) {\n        ɵngcc0.ɵɵprojectionDef();\n        ɵngcc0.ɵɵprojection(0);\n      }\n    },\n    encapsulation: 2,\n    changeDetection: 0\n  });\n  /** @nocollapse */\n\n  return MdcDrawer;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n/**\n * @fileoverview added by tsickle\n * Generated from: drawer/drawer-directives.ts\n * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n\n\nlet MdcDrawerTitle = /*#__PURE__*/(() => {\n  class MdcDrawerTitle {}\n\n  MdcDrawerTitle.ɵfac = function MdcDrawerTitle_Factory(t) {\n    return new (t || MdcDrawerTitle)();\n  };\n\n  MdcDrawerTitle.ɵdir = /*@__PURE__*/ɵngcc0.ɵɵdefineDirective({\n    type: MdcDrawerTitle,\n    selectors: [[\"\", \"mdcDrawerTitle\", \"\"]],\n    hostAttrs: [1, \"mdc-drawer__title\"]\n  });\n  return MdcDrawerTitle;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\nlet MdcDrawerSubtitle = /*#__PURE__*/(() => {\n  class MdcDrawerSubtitle {}\n\n  MdcDrawerSubtitle.ɵfac = function MdcDrawerSubtitle_Factory(t) {\n    return new (t || MdcDrawerSubtitle)();\n  };\n\n  MdcDrawerSubtitle.ɵdir = /*@__PURE__*/ɵngcc0.ɵɵdefineDirective({\n    type: MdcDrawerSubtitle,\n    selectors: [[\"\", \"mdcDrawerSubtitle\", \"\"]],\n    hostAttrs: [1, \"mdc-drawer__subtitle\"]\n  });\n  return MdcDrawerSubtitle;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\nlet MdcDrawerContent = /*#__PURE__*/(() => {\n  class MdcDrawerContent {}\n\n  MdcDrawerContent.ɵfac = function MdcDrawerContent_Factory(t) {\n    return new (t || MdcDrawerContent)();\n  };\n\n  MdcDrawerContent.ɵdir = /*@__PURE__*/ɵngcc0.ɵɵdefineDirective({\n    type: MdcDrawerContent,\n    selectors: [[\"mdc-drawer-content\"], [\"\", \"mdcDrawerContent\", \"\"]],\n    hostAttrs: [1, \"mdc-drawer__content\"]\n  });\n  return MdcDrawerContent;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\nlet MdcDrawerAppContent = /*#__PURE__*/(() => {\n  class MdcDrawerAppContent {}\n\n  MdcDrawerAppContent.ɵfac = function MdcDrawerAppContent_Factory(t) {\n    return new (t || MdcDrawerAppContent)();\n  };\n\n  MdcDrawerAppContent.ɵdir = /*@__PURE__*/ɵngcc0.ɵɵdefineDirective({\n    type: MdcDrawerAppContent,\n    selectors: [[\"mdc-drawer-app-content\"], [\"\", \"mdcDrawerAppContent\", \"\"]],\n    hostAttrs: [1, \"mdc-drawer-app-content\"]\n  });\n  return MdcDrawerAppContent;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n/**\n * @fileoverview added by tsickle\n * Generated from: drawer/module.ts\n * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n\n/** @type {?} */\n\n\nconst DRAWER_DECLARATIONS = [MdcDrawer, MdcDrawerAppContent, MdcDrawerContent, MdcDrawerHeader, MdcDrawerSubtitle, MdcDrawerTitle];\nlet MdcDrawerModule = /*#__PURE__*/(() => {\n  class MdcDrawerModule {}\n\n  MdcDrawerModule.ɵfac = function MdcDrawerModule_Factory(t) {\n    return new (t || MdcDrawerModule)();\n  };\n\n  MdcDrawerModule.ɵmod = /*@__PURE__*/ɵngcc0.ɵɵdefineNgModule({\n    type: MdcDrawerModule\n  });\n  MdcDrawerModule.ɵinj = /*@__PURE__*/ɵngcc0.ɵɵdefineInjector({\n    imports: [[CommonModule]]\n  });\n  return MdcDrawerModule;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\n(function () {\n  (typeof ngJitMode === \"undefined\" || ngJitMode) && ɵngcc0.ɵɵsetNgModuleScope(MdcDrawerModule, {\n    declarations: function () {\n      return [MdcDrawer, MdcDrawerAppContent, MdcDrawerContent, MdcDrawerHeader, MdcDrawerSubtitle, MdcDrawerTitle];\n    },\n    imports: function () {\n      return [CommonModule];\n    },\n    exports: function () {\n      return [MdcDrawer, MdcDrawerAppContent, MdcDrawerContent, MdcDrawerHeader, MdcDrawerSubtitle, MdcDrawerTitle];\n    }\n  });\n})();\n\nexport { MdcDrawer, MdcDrawerAppContent, MdcDrawerContent, MdcDrawerHeader, MdcDrawerModule, MdcDrawerSubtitle, MdcDrawerTitle }; //# sourceMappingURL=drawer.js.map","map":null,"metadata":{},"sourceType":"module"}