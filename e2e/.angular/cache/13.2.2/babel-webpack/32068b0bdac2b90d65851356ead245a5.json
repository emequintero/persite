{"ast":null,"code":"/**\n * @license\n * Copyright (c) Dominic Carretto\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://github.com/trimox/angular-mdc-web/blob/master/LICENSE\n */\nimport { Component, ViewEncapsulation, ChangeDetectionStrategy, ElementRef, Input, InjectionToken, Directive, EventEmitter, ChangeDetectorRef, Optional, Inject, Output, ContentChildren, NgModule } from '@angular/core';\nimport { CommonModule } from '@angular/common';\nimport { coerceBooleanProperty } from '@angular/cdk/coercion';\nimport { Platform } from '@angular/cdk/platform';\nimport { merge } from 'rxjs';\nimport { startWith } from 'rxjs/operators';\nimport { MDCComponent } from '@angular-mdc/web/base';\nimport { ENTER, SPACE } from '@angular/cdk/keycodes';\nimport { MDCRippleFoundation } from '@material/ripple';\nimport { MdcRipple } from '@angular-mdc/web/ripple';\nimport { matches } from '@angular-mdc/web/dom';\nimport { MDCListFoundation, cssClasses, strings } from '@material/list';\n/**\n * @fileoverview added by tsickle\n * Generated from: list/list-divider.ts\n * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n\nimport * as ɵngcc0 from '@angular/core';\nimport * as ɵngcc1 from '@angular/common';\nimport * as ɵngcc2 from '@angular-mdc/web/ripple';\nimport * as ɵngcc3 from '@angular/cdk/platform';\nconst _c0 = [\"mdcListDivider\", \"\"];\nconst _c1 = [\"mdcListItemText\", \"\"];\n\nfunction MdcListItemText_span_3_Template(rf, ctx) {\n  if (rf & 1) {\n    ɵngcc0.ɵɵelementStart(0, \"span\", 2);\n    ɵngcc0.ɵɵtext(1);\n    ɵngcc0.ɵɵelementEnd();\n  }\n\n  if (rf & 2) {\n    const ctx_r0 = ɵngcc0.ɵɵnextContext();\n    ɵngcc0.ɵɵadvance(1);\n    ɵngcc0.ɵɵtextInterpolate(ctx_r0.secondaryText);\n  }\n}\n\nconst _c2 = [\"*\"];\nconst _c3 = [\"mdcListGroup\", \"\"];\n\nfunction MdcListGroup_h3_0_Template(rf, ctx) {\n  if (rf & 1) {\n    ɵngcc0.ɵɵelementStart(0, \"h3\", 1);\n    ɵngcc0.ɵɵtext(1);\n    ɵngcc0.ɵɵelementEnd();\n  }\n\n  if (rf & 2) {\n    const ctx_r0 = ɵngcc0.ɵɵnextContext();\n    ɵngcc0.ɵɵadvance(1);\n    ɵngcc0.ɵɵtextInterpolate(ctx_r0.subheader);\n  }\n}\n\nlet MdcListDivider = /*#__PURE__*/(() => {\n  class MdcListDivider {\n    /**\n     * @param {?} elementRef\n     */\n    constructor(elementRef) {\n      this.elementRef = elementRef;\n      this._inset = false;\n      this._padded = false;\n    }\n    /**\n     * @return {?}\n     */\n\n\n    get inset() {\n      return this._inset;\n    }\n    /**\n     * @param {?} value\n     * @return {?}\n     */\n\n\n    set inset(value) {\n      this._inset = coerceBooleanProperty(value);\n    }\n    /**\n     * @return {?}\n     */\n\n\n    get padded() {\n      return this._padded;\n    }\n    /**\n     * @param {?} value\n     * @return {?}\n     */\n\n\n    set padded(value) {\n      this._padded = coerceBooleanProperty(value);\n    }\n\n  }\n\n  MdcListDivider.ɵfac = function MdcListDivider_Factory(t) {\n    return new (t || MdcListDivider)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef));\n  };\n\n  MdcListDivider.ɵcmp = /*@__PURE__*/ɵngcc0.ɵɵdefineComponent({\n    type: MdcListDivider,\n    selectors: [[\"\", \"mdcListDivider\", \"\"], [\"mdc-list-divider\"]],\n    hostAttrs: [\"role\", \"separator\", 1, \"mdc-list-divider\"],\n    hostVars: 4,\n    hostBindings: function MdcListDivider_HostBindings(rf, ctx) {\n      if (rf & 2) {\n        ɵngcc0.ɵɵclassProp(\"mdc-list-divider--inset\", ctx.inset)(\"mdc-list-divider--padded\", ctx.padded);\n      }\n    },\n    inputs: {\n      inset: \"inset\",\n      padded: \"padded\"\n    },\n    exportAs: [\"mdcListDivider\"],\n    attrs: _c0,\n    decls: 0,\n    vars: 0,\n    template: function MdcListDivider_Template(rf, ctx) {},\n    encapsulation: 2,\n    changeDetection: 0\n  });\n  /** @nocollapse */\n\n  return MdcListDivider;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n/**\n * @fileoverview added by tsickle\n * Generated from: list/list-item.ts\n * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n\n/**\n * Change event that is fired whenever the selected state of an option changes.\n */\n\n\nclass MdcListSelectionChange {\n  /**\n   * @param {?} source\n   */\n  constructor(source) {\n    this.source = source;\n  }\n\n}\n/**\n * Injection token used to provide the parent MdcList component to MdcListItem.\n * @type {?}\n */\n\n\nconst MDC_LIST_PARENT_COMPONENT = new InjectionToken('MDC_LIST_PARENT_COMPONENT');\n/** @type {?} */\n\nlet uniqueIdCounter = 0;\nlet MdcListItemGraphic = /*#__PURE__*/(() => {\n  class MdcListItemGraphic {\n    /**\n     * @param {?} elementRef\n     */\n    constructor(elementRef) {\n      this.elementRef = elementRef;\n    }\n\n  }\n\n  MdcListItemGraphic.ɵfac = function MdcListItemGraphic_Factory(t) {\n    return new (t || MdcListItemGraphic)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef));\n  };\n\n  MdcListItemGraphic.ɵdir = /*@__PURE__*/ɵngcc0.ɵɵdefineDirective({\n    type: MdcListItemGraphic,\n    selectors: [[\"\", \"mdcListItemGraphic\", \"\"], [\"mdc-list-item-graphic\"]],\n    hostAttrs: [\"role\", \"presentation\", 1, \"mdc-list-item__graphic\"],\n    hostVars: 1,\n    hostBindings: function MdcListItemGraphic_HostBindings(rf, ctx) {\n      if (rf & 2) {\n        ɵngcc0.ɵɵattribute(\"aria-hidden\", true);\n      }\n    },\n    exportAs: [\"mdcListItemGraphic\"]\n  });\n  /** @nocollapse */\n\n  return MdcListItemGraphic;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\nlet MdcListItemMeta = /*#__PURE__*/(() => {\n  class MdcListItemMeta {\n    /**\n     * @param {?} elementRef\n     */\n    constructor(elementRef) {\n      this.elementRef = elementRef;\n    }\n\n  }\n\n  MdcListItemMeta.ɵfac = function MdcListItemMeta_Factory(t) {\n    return new (t || MdcListItemMeta)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef));\n  };\n\n  MdcListItemMeta.ɵdir = /*@__PURE__*/ɵngcc0.ɵɵdefineDirective({\n    type: MdcListItemMeta,\n    selectors: [[\"\", \"mdcListItemMeta\", \"\"], [\"mdc-list-item-meta\"]],\n    hostAttrs: [1, \"mdc-list-item__meta\"],\n    exportAs: [\"mdcListItemMeta\"]\n  });\n  /** @nocollapse */\n\n  return MdcListItemMeta;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\nlet MdcListItemText = /*#__PURE__*/(() => {\n  class MdcListItemText {\n    /**\n     * @param {?} elementRef\n     */\n    constructor(elementRef) {\n      this.elementRef = elementRef;\n    }\n\n  }\n\n  MdcListItemText.ɵfac = function MdcListItemText_Factory(t) {\n    return new (t || MdcListItemText)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef));\n  };\n\n  MdcListItemText.ɵcmp = /*@__PURE__*/ɵngcc0.ɵɵdefineComponent({\n    type: MdcListItemText,\n    selectors: [[\"\", \"mdcListItemText\", \"\"], [\"mdc-list-item-text\"]],\n    hostAttrs: [1, \"mdc-list-item__text\"],\n    inputs: {\n      secondaryText: \"secondaryText\"\n    },\n    exportAs: [\"mdcListItemText\"],\n    attrs: _c1,\n    ngContentSelectors: _c2,\n    decls: 4,\n    vars: 1,\n    consts: [[1, \"mdc-list-item__primary-text\"], [\"class\", \"mdc-list-item__secondary-text\", 4, \"ngIf\"], [1, \"mdc-list-item__secondary-text\"]],\n    template: function MdcListItemText_Template(rf, ctx) {\n      if (rf & 1) {\n        ɵngcc0.ɵɵprojectionDef();\n        ɵngcc0.ɵɵelementContainerStart(0);\n        ɵngcc0.ɵɵelementStart(1, \"span\", 0);\n        ɵngcc0.ɵɵprojection(2);\n        ɵngcc0.ɵɵelementEnd();\n        ɵngcc0.ɵɵtemplate(3, MdcListItemText_span_3_Template, 2, 1, \"span\", 1);\n        ɵngcc0.ɵɵelementContainerEnd();\n      }\n\n      if (rf & 2) {\n        ɵngcc0.ɵɵadvance(3);\n        ɵngcc0.ɵɵproperty(\"ngIf\", ctx.secondaryText);\n      }\n    },\n    directives: [ɵngcc1.NgIf],\n    encapsulation: 2,\n    changeDetection: 0\n  });\n  /** @nocollapse */\n\n  return MdcListItemText;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\nlet MdcListItemSecondary = /*#__PURE__*/(() => {\n  class MdcListItemSecondary {\n    /**\n     * @param {?} elementRef\n     */\n    constructor(elementRef) {\n      this.elementRef = elementRef;\n    }\n\n  }\n\n  MdcListItemSecondary.ɵfac = function MdcListItemSecondary_Factory(t) {\n    return new (t || MdcListItemSecondary)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef));\n  };\n\n  MdcListItemSecondary.ɵdir = /*@__PURE__*/ɵngcc0.ɵɵdefineDirective({\n    type: MdcListItemSecondary,\n    selectors: [[\"\", \"mdcListItemSecondary\", \"\"], [\"mdc-list-item-secondary\"]],\n    hostAttrs: [1, \"mdc-list-item__secondary-text\"],\n    exportAs: [\"mdcListItemSecondary\"]\n  });\n  /** @nocollapse */\n\n  return MdcListItemSecondary;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\nlet MdcListItem = /*#__PURE__*/(() => {\n  class MdcListItem {\n    /**\n     * @param {?} ripple\n     * @param {?} _changeDetectorRef\n     * @param {?} elementRef\n     * @param {?} _parent\n     */\n    constructor(ripple, _changeDetectorRef, elementRef, _parent) {\n      this.ripple = ripple;\n      this._changeDetectorRef = _changeDetectorRef;\n      this.elementRef = elementRef;\n      this._parent = _parent;\n      this._id = `mdc-list-item-${uniqueIdCounter++}`;\n      this.tabIndex = -1;\n      this._selected = false;\n      this._activated = false;\n      this._disabled = false;\n      this.selectionChange = new EventEmitter();\n      this._root = this.elementRef.nativeElement;\n      this.ripple = this._createRipple();\n      this.ripple.init();\n    }\n    /**\n     * The unique ID of the list item.\n     * @return {?}\n     */\n\n\n    get id() {\n      return this._id;\n    }\n    /**\n     * Whether the list item is selected.\n     * @return {?}\n     */\n\n\n    get selected() {\n      return this._selected;\n    }\n    /**\n     * @param {?} value\n     * @return {?}\n     */\n\n\n    set selected(value) {\n      /** @type {?} */\n      const newValue = coerceBooleanProperty(value);\n\n      if (newValue !== this._selected) {\n        this._selected = newValue;\n\n        this._changeDetectorRef.markForCheck();\n      }\n    }\n    /**\n     * Whether the list item is activated.\n     * @return {?}\n     */\n\n\n    get activated() {\n      return this._activated;\n    }\n    /**\n     * @param {?} value\n     * @return {?}\n     */\n\n\n    set activated(value) {\n      /** @type {?} */\n      const newValue = coerceBooleanProperty(value);\n\n      if (newValue !== this._activated) {\n        this._activated = newValue;\n\n        this._changeDetectorRef.markForCheck();\n      }\n    }\n    /**\n     * Whether the list item is disabled.\n     * @return {?}\n     */\n\n\n    get disabled() {\n      return this._disabled;\n    }\n    /**\n     * @param {?} value\n     * @return {?}\n     */\n\n\n    set disabled(value) {\n      /** @type {?} */\n      const newValue = coerceBooleanProperty(value);\n\n      if (newValue !== this._disabled) {\n        this._disabled = newValue;\n\n        this._changeDetectorRef.markForCheck();\n      }\n    }\n    /**\n     * @return {?}\n     */\n\n\n    ngOnDestroy() {\n      this.ripple.destroy();\n    }\n    /**\n     * @private\n     * @return {?}\n     */\n\n\n    _createRipple() {\n      /** @type {?} */\n      const adapter = Object.assign(Object.assign({}, MdcRipple.createAdapter(this)), {\n        isSurfaceDisabled:\n        /**\n        * @return {?}\n        */\n        () => this._disabled || this._parent.disableRipple\n      });\n      return new MdcRipple(this.elementRef, new MDCRippleFoundation(adapter));\n    }\n    /**\n     * @return {?}\n     */\n\n\n    focus() {\n      this.getListItemElement().focus();\n    }\n    /**\n     * @param {?} role\n     * @return {?}\n     */\n\n\n    setRole(role) {\n      this.getListItemElement().setAttribute('role', role);\n    }\n    /**\n     * @return {?}\n     */\n\n\n    getListItemElement() {\n      return this.elementRef.nativeElement;\n    }\n    /**\n     * @param {?} evt\n     * @return {?}\n     */\n\n\n    _onKeydown(evt) {\n      if (evt.keyCode === ENTER || evt.keyCode === SPACE) {\n        this._emitChangeEvent();\n      }\n    }\n    /**\n     * Emits a change event if the selected state of an option changed.\n     * @return {?}\n     */\n\n\n    _emitChangeEvent() {\n      if (this._disabled) {\n        return;\n      }\n\n      this.selectionChange.emit(new MdcListSelectionChange(this));\n    }\n\n  }\n\n  MdcListItem.ɵfac = function MdcListItem_Factory(t) {\n    return new (t || MdcListItem)(ɵngcc0.ɵɵdirectiveInject(ɵngcc2.MdcRipple), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ChangeDetectorRef), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef), ɵngcc0.ɵɵdirectiveInject(MDC_LIST_PARENT_COMPONENT, 8));\n  };\n\n  MdcListItem.ɵcmp = /*@__PURE__*/ɵngcc0.ɵɵdefineComponent({\n    type: MdcListItem,\n    selectors: [[\"mdc-list-item\"], [\"a\", \"mdc-list-item\", \"\"]],\n    hostAttrs: [\"role\", \"listitem\", 1, \"mdc-list-item\"],\n    hostVars: 9,\n    hostBindings: function MdcListItem_HostBindings(rf, ctx) {\n      if (rf & 1) {\n        ɵngcc0.ɵɵlistener(\"click\", function MdcListItem_click_HostBindingHandler() {\n          return ctx._emitChangeEvent();\n        })(\"keydown\", function MdcListItem_keydown_HostBindingHandler($event) {\n          return ctx._onKeydown($event);\n        });\n      }\n\n      if (rf & 2) {\n        ɵngcc0.ɵɵhostProperty(\"id\", ctx.id)(\"tabIndex\", ctx.tabIndex);\n        ɵngcc0.ɵɵattribute(\"data-value\", ctx.value);\n        ɵngcc0.ɵɵclassProp(\"mdc-list-item--selected\", ctx.selected)(\"mdc-list-item--activated\", ctx.activated)(\"mdc-list-item--disabled\", ctx.disabled);\n      }\n    },\n    inputs: {\n      tabIndex: \"tabIndex\",\n      selected: \"selected\",\n      activated: \"activated\",\n      disabled: \"disabled\",\n      value: \"value\"\n    },\n    outputs: {\n      selectionChange: \"selectionChange\"\n    },\n    exportAs: [\"mdcListItem\"],\n    features: [ɵngcc0.ɵɵProvidersFeature([MdcRipple])],\n    ngContentSelectors: _c2,\n    decls: 1,\n    vars: 0,\n    template: function MdcListItem_Template(rf, ctx) {\n      if (rf & 1) {\n        ɵngcc0.ɵɵprojectionDef();\n        ɵngcc0.ɵɵprojection(0);\n      }\n    },\n    encapsulation: 2,\n    changeDetection: 0\n  });\n  /** @nocollapse */\n\n  return MdcListItem;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n/**\n * @fileoverview added by tsickle\n * Generated from: list/list.ts\n * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n\n/**\n * Change event that is being fired whenever the selected state of an option changes.\n */\n\n\nclass MdcListItemChange {\n  /**\n   * @param {?} source\n   * @param {?} option\n   */\n  constructor(source, option) {\n    this.source = source;\n    this.option = option;\n  }\n\n}\n\nlet MdcListGroup = /*#__PURE__*/(() => {\n  class MdcListGroup {\n    /**\n     * @param {?} elementRef\n     */\n    constructor(elementRef) {\n      this.elementRef = elementRef;\n    }\n\n  }\n\n  MdcListGroup.ɵfac = function MdcListGroup_Factory(t) {\n    return new (t || MdcListGroup)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef));\n  };\n\n  MdcListGroup.ɵcmp = /*@__PURE__*/ɵngcc0.ɵɵdefineComponent({\n    type: MdcListGroup,\n    selectors: [[\"\", \"mdcListGroup\", \"\"], [\"mdc-list-group\"]],\n    hostAttrs: [1, \"mdc-list-group\"],\n    inputs: {\n      subheader: \"subheader\"\n    },\n    exportAs: [\"mdcListGroup\"],\n    attrs: _c3,\n    ngContentSelectors: _c2,\n    decls: 2,\n    vars: 1,\n    consts: [[\"class\", \"mdc-list-group__subheader\", 4, \"ngIf\"], [1, \"mdc-list-group__subheader\"]],\n    template: function MdcListGroup_Template(rf, ctx) {\n      if (rf & 1) {\n        ɵngcc0.ɵɵprojectionDef();\n        ɵngcc0.ɵɵtemplate(0, MdcListGroup_h3_0_Template, 2, 1, \"h3\", 0);\n        ɵngcc0.ɵɵprojection(1);\n      }\n\n      if (rf & 2) {\n        ɵngcc0.ɵɵproperty(\"ngIf\", ctx.subheader);\n      }\n    },\n    directives: [ɵngcc1.NgIf],\n    encapsulation: 2,\n    changeDetection: 0\n  });\n  /** @nocollapse */\n\n  return MdcListGroup;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\nlet MdcListGroupSubheader = /*#__PURE__*/(() => {\n  class MdcListGroupSubheader {\n    /**\n     * @param {?} elementRef\n     */\n    constructor(elementRef) {\n      this.elementRef = elementRef;\n    }\n\n  }\n\n  MdcListGroupSubheader.ɵfac = function MdcListGroupSubheader_Factory(t) {\n    return new (t || MdcListGroupSubheader)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef));\n  };\n\n  MdcListGroupSubheader.ɵdir = /*@__PURE__*/ɵngcc0.ɵɵdefineDirective({\n    type: MdcListGroupSubheader,\n    selectors: [[\"\", \"mdcListGroupSubheader\", \"\"], [\"mdc-list-group-subheader\"]],\n    hostAttrs: [1, \"mdc-list-group__subheader\"],\n    exportAs: [\"mdcListGroupSubheader\"]\n  });\n  /** @nocollapse */\n\n  return MdcListGroupSubheader;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\nlet MdcList = /*#__PURE__*/(() => {\n  class MdcList extends MDCComponent {\n    /**\n     * @param {?} _platform\n     * @param {?} _changeDetectorRef\n     * @param {?} elementRef\n     */\n    constructor(_platform, _changeDetectorRef, elementRef) {\n      super(elementRef);\n      this._platform = _platform;\n      this._changeDetectorRef = _changeDetectorRef;\n      this.elementRef = elementRef;\n      this._twoLine = false;\n      this._dense = false;\n      this._border = false;\n      this._avatar = false;\n      this._interactive = true;\n      this._disableRipple = false;\n      this._useActivatedClass = false;\n      this._useSelectedClass = false;\n      this._verticalOrientation = true;\n      this._wrapFocus = false;\n      /**\n       * Emits a change event whenever the selected state of an option changes.\n       */\n\n      this.selectionChange = new EventEmitter();\n      /**\n       * Emits an event for keyboard and mouse actions.\n       */\n\n      this.actionEvent = new EventEmitter();\n      /**\n       * Subscription to changes in list items.\n       */\n\n      this._changeSubscription = null;\n      /**\n       * Subscription to selection events in list items.\n       */\n\n      this.itemSelectionSubscription = null;\n    }\n    /**\n     * @return {?}\n     */\n\n\n    get twoLine() {\n      return this._twoLine;\n    }\n    /**\n     * @param {?} value\n     * @return {?}\n     */\n\n\n    set twoLine(value) {\n      this._twoLine = coerceBooleanProperty(value);\n    }\n    /**\n     * @return {?}\n     */\n\n\n    get dense() {\n      return this._dense;\n    }\n    /**\n     * @param {?} value\n     * @return {?}\n     */\n\n\n    set dense(value) {\n      this._dense = coerceBooleanProperty(value);\n    }\n    /**\n     * @return {?}\n     */\n\n\n    get border() {\n      return this._border;\n    }\n    /**\n     * @param {?} value\n     * @return {?}\n     */\n\n\n    set border(value) {\n      this._border = coerceBooleanProperty(value);\n    }\n    /**\n     * @return {?}\n     */\n\n\n    get avatar() {\n      return this._avatar;\n    }\n    /**\n     * @param {?} value\n     * @return {?}\n     */\n\n\n    set avatar(value) {\n      this._avatar = coerceBooleanProperty(value);\n    }\n    /**\n     * @return {?}\n     */\n\n\n    get interactive() {\n      return this._interactive;\n    }\n    /**\n     * @param {?} value\n     * @return {?}\n     */\n\n\n    set interactive(value) {\n      /** @type {?} */\n      const newValue = coerceBooleanProperty(value);\n\n      if (newValue !== this._interactive) {\n        this._interactive = newValue;\n      }\n    }\n    /**\n     * @return {?}\n     */\n\n\n    get disableRipple() {\n      return this._disableRipple;\n    }\n    /**\n     * @param {?} value\n     * @return {?}\n     */\n\n\n    set disableRipple(value) {\n      /** @type {?} */\n      const newValue = coerceBooleanProperty(value);\n\n      if (newValue !== this._disableRipple) {\n        this._disableRipple = newValue;\n      }\n    }\n    /**\n     * @return {?}\n     */\n\n\n    get singleSelection() {\n      return this._singleSelection;\n    }\n    /**\n     * @param {?} value\n     * @return {?}\n     */\n\n\n    set singleSelection(value) {\n      if (value !== undefined) {\n        /** @type {?} */\n        const newValue = coerceBooleanProperty(value);\n\n        if (newValue !== this._singleSelection) {\n          this._singleSelection = newValue;\n\n          this._foundation.setSingleSelection(this._singleSelection);\n\n          this._changeDetectorRef.markForCheck();\n        }\n      }\n    }\n    /**\n     * @return {?}\n     */\n\n\n    get useActivatedClass() {\n      return this._useActivatedClass;\n    }\n    /**\n     * @param {?} value\n     * @return {?}\n     */\n\n\n    set useActivatedClass(value) {\n      this._useActivatedClass = coerceBooleanProperty(value);\n\n      this._foundation.setUseActivatedClass(this._useActivatedClass);\n\n      this._changeDetectorRef.markForCheck();\n    }\n    /**\n     * @return {?}\n     */\n\n\n    get useSelectedClass() {\n      return this._useSelectedClass;\n    }\n    /**\n     * @param {?} value\n     * @return {?}\n     */\n\n\n    set useSelectedClass(value) {\n      this._useSelectedClass = coerceBooleanProperty(value);\n\n      this._changeDetectorRef.markForCheck();\n    }\n    /**\n     * @return {?}\n     */\n\n\n    get verticalOrientation() {\n      return this._verticalOrientation;\n    }\n    /**\n     * @param {?} value\n     * @return {?}\n     */\n\n\n    set verticalOrientation(value) {\n      this._verticalOrientation = coerceBooleanProperty(value);\n\n      this._foundation.setVerticalOrientation(this._verticalOrientation);\n\n      this._changeDetectorRef.markForCheck();\n    }\n    /**\n     * @return {?}\n     */\n\n\n    get wrapFocus() {\n      return this._wrapFocus;\n    }\n    /**\n     * @param {?} value\n     * @return {?}\n     */\n\n\n    set wrapFocus(value) {\n      this._wrapFocus = coerceBooleanProperty(value);\n\n      this._foundation.setWrapFocus(this._wrapFocus);\n\n      this._changeDetectorRef.markForCheck();\n    }\n    /**\n     * Combined stream of all of the list item selection events.\n     * @return {?}\n     */\n\n\n    get listItemSelections() {\n      return merge(...this.items.map(\n      /**\n      * @param {?} item\n      * @return {?}\n      */\n      item => item.selectionChange));\n    }\n    /**\n     * @return {?}\n     */\n\n\n    getDefaultFoundation() {\n      /** @type {?} */\n      const adapter = {\n        getListItemCount:\n        /**\n        * @return {?}\n        */\n        () => this.items.length,\n        getFocusedElementIndex:\n        /**\n        * @return {?}\n        */\n        () => {\n          if (!this._platform.isBrowser &&\n          /** @type {?} */\n          document.activeElement) {\n            return -1;\n          }\n\n          return this.items.toArray().findIndex(\n          /**\n          * @param {?} _\n          * @return {?}\n          */\n          _ => _.getListItemElement() ===\n          /** @type {?} */\n          document.activeElement) || -1;\n        },\n        setAttributeForElementIndex:\n        /**\n        * @param {?} index\n        * @param {?} attr\n        * @param {?} value\n        * @return {?}\n        */\n        (index, attr, value) => {\n          var _a, _b;\n          /** @type {?} */\n\n\n          const item = this.getListItemByIndex(index);\n          (_b = (_a = item) === null || _a === void 0 ? void 0 : _a.getListItemElement()) === null || _b === void 0 ? void 0 : _b.setAttribute(attr, value);\n        },\n        addClassForElementIndex:\n        /**\n        * @param {?} index\n        * @param {?} className\n        * @return {?}\n        */\n        (index, className) => this.items.toArray()[index].getListItemElement().classList.add(className),\n        removeClassForElementIndex:\n        /**\n        * @param {?} index\n        * @param {?} className\n        * @return {?}\n        */\n        (index, className) => {\n          var _a, _b, _c;\n          /** @type {?} */\n\n\n          const item = this.getListItemByIndex(index);\n          (_c = (_b = (_a = item) === null || _a === void 0 ? void 0 : _a.getListItemElement()) === null || _b === void 0 ? void 0 : _b.classList) === null || _c === void 0 ? void 0 : _c.remove(className);\n        },\n        getAttributeForElementIndex:\n        /**\n        * @param {?} index\n        * @param {?} attr\n        * @return {?}\n        */\n        (index, attr) => this.items.toArray()[index].getListItemElement().getAttribute(attr),\n        focusItemAtIndex:\n        /**\n        * @param {?} index\n        * @return {?}\n        */\n        index => this.focusItemAtIndex(index),\n        setTabIndexForListItemChildren:\n        /**\n        * @param {?} listItemIndex\n        * @param {?} tabIndexValue\n        * @return {?}\n        */\n        (listItemIndex, tabIndexValue) => {\n          /** @type {?} */\n          const listItemChildren = [].slice.call(this.items.toArray()[listItemIndex].getListItemElement().querySelectorAll(strings.CHILD_ELEMENTS_TO_TOGGLE_TABINDEX));\n          listItemChildren.forEach(\n          /**\n          * @param {?} ele\n          * @return {?}\n          */\n          ele => ele.setAttribute('tabindex', `${tabIndexValue}`));\n        },\n        hasCheckboxAtIndex:\n        /**\n        * @param {?} index\n        * @return {?}\n        */\n        index => {\n          /** @type {?} */\n          const listItem = this.items.toArray()[index].getListItemElement();\n          return !!listItem.querySelector(strings.CHECKBOX_SELECTOR);\n        },\n        hasRadioAtIndex:\n        /**\n        * @param {?} index\n        * @return {?}\n        */\n        index => {\n          /** @type {?} */\n          const listItem = this.items.toArray()[index].getListItemElement();\n          return !!listItem.querySelector(strings.RADIO_SELECTOR);\n        },\n        isCheckboxCheckedAtIndex:\n        /**\n        * @param {?} index\n        * @return {?}\n        */\n        index => {\n          /** @type {?} */\n          const listItem = this.items.toArray()[index].getListItemElement();\n          /** @type {?} */\n\n          const toggleEl = listItem.querySelector(strings.CHECKBOX_SELECTOR);\n          return (\n            /** @type {?} */\n            toggleEl.checked\n          );\n        },\n        setCheckedCheckboxOrRadioAtIndex:\n        /**\n        * @param {?} index\n        * @param {?} isChecked\n        * @return {?}\n        */\n        (index, isChecked) => {\n          /** @type {?} */\n          const listItem = this.items.toArray()[index].getListItemElement();\n          /** @type {?} */\n\n          const toggleEl = listItem.querySelector(strings.CHECKBOX_RADIO_SELECTOR);\n\n          /** @type {?} */\n          toggleEl.checked = isChecked;\n\n          if (this._platform.isBrowser) {\n            /** @type {?} */\n            const event = document.createEvent('Event');\n            event.initEvent('change', true, true);\n\n            /** @type {?} */\n            toggleEl.dispatchEvent(event);\n          }\n        },\n        isFocusInsideList:\n        /**\n        * @return {?}\n        */\n        () => this._platform.isBrowser ? this.elementRef.nativeElement.contains(document.activeElement) : false,\n        isRootFocused:\n        /**\n        * @return {?}\n        */\n        () => this._platform.isBrowser ? document.activeElement === this._getHostElement() : false,\n        listItemAtIndexHasClass:\n        /**\n        * @param {?} index\n        * @param {?} className\n        * @return {?}\n        */\n        (index, className) => this.items.toArray()[index].getListItemElement().classList.contains(className),\n        notifyAction:\n        /**\n        * @param {?} index\n        * @return {?}\n        */\n        index => this.actionEvent.emit({\n          index: index\n        })\n      };\n      return new MDCListFoundation(adapter);\n    }\n    /**\n     * @return {?}\n     */\n\n\n    ngAfterViewInit() {\n      this._foundation.init();\n\n      this._foundation.layout(); // When list items change, re-subscribe\n\n\n      this._changeSubscription = this.items.changes.pipe(startWith(null)).subscribe(\n      /**\n      * @return {?}\n      */\n      () => {\n        if (this.items.length) {\n          this._resetListItems();\n        }\n      });\n    }\n    /**\n     * @return {?}\n     */\n\n\n    ngOnDestroy() {\n      var _a;\n\n      this._dropSubscriptions();\n\n      (_a = this._changeSubscription) === null || _a === void 0 ? void 0 : _a.unsubscribe();\n\n      this._foundation.destroy();\n    }\n    /**\n     * @param {?} index\n     * @return {?}\n     */\n\n\n    setSelectedIndex(index) {\n      this.reset();\n\n      this._foundation.setSelectedIndex(index);\n\n      if (index === -1) {\n        return;\n      }\n      /** @type {?} */\n\n\n      const selectedItem = this.items.toArray()[index];\n\n      if (selectedItem) {\n        this._applySelectionState(selectedItem);\n      }\n    }\n    /**\n     * @param {?} value\n     * @return {?}\n     */\n\n\n    setSelectedValue(value) {\n      this.reset();\n\n      if (value === null) {\n        return;\n      }\n      /** @type {?} */\n\n\n      const selectedItem = this.getListItemByValue(value);\n\n      this._foundation.setSelectedIndex(this.getListItemIndexByValue(value));\n\n      if (selectedItem) {\n        this._applySelectionState(selectedItem);\n      }\n    }\n    /**\n     * @return {?}\n     */\n\n\n    getSelectedItem() {\n      return this.items.toArray().find(\n      /**\n      * @param {?} _\n      * @return {?}\n      */\n      _ => _.selected || _.activated);\n    }\n    /**\n     * @return {?}\n     */\n\n\n    getSelectedIndex() {\n      return this.items.toArray().findIndex(\n      /**\n      * @param {?} _\n      * @return {?}\n      */\n      _ => _.selected || _.activated);\n    }\n    /**\n     * @return {?}\n     */\n\n\n    getSelectedValue() {\n      /** @type {?} */\n      const item = this.items ? this.items.find(\n      /**\n      * @param {?} _\n      * @return {?}\n      */\n      _ => _.selected) : null;\n      return item && item.value ? item.value : null;\n    }\n    /**\n     * @return {?}\n     */\n\n\n    getSelectedText() {\n      /** @type {?} */\n      const selectedItem = this.getSelectedItem();\n      return selectedItem && selectedItem.getListItemElement().textContent || '';\n    }\n    /**\n     * @param {?} value\n     * @return {?}\n     */\n\n\n    getListItemByValue(value) {\n      return this.items.toArray().find(\n      /**\n      * @param {?} _\n      * @return {?}\n      */\n      _ => _.value === value);\n    }\n    /**\n     * @param {?} index\n     * @return {?}\n     */\n\n\n    getListItemByIndex(index) {\n      return this.items.toArray()[index];\n    }\n    /**\n     * @param {?} value\n     * @return {?}\n     */\n\n\n    getListItemIndexByValue(value) {\n      return this.items.toArray().findIndex(\n      /**\n      * @param {?} _\n      * @return {?}\n      */\n      _ => _.value === value);\n    }\n    /**\n     * @param {?} index\n     * @return {?}\n     */\n\n\n    focusItemAtIndex(index) {\n      this.items.toArray()[index].getListItemElement().focus();\n    }\n    /**\n     * @return {?}\n     */\n\n\n    focusFirstElement() {\n      return this._foundation.focusFirstElement();\n    }\n    /**\n     * @return {?}\n     */\n\n\n    focusLastElement() {\n      return this._foundation.focusLastElement();\n    }\n    /**\n     * @param {?} index\n     * @return {?}\n     */\n\n\n    focusNextElement(index) {\n      return this._foundation.focusNextElement(index);\n    }\n    /**\n     * @param {?} index\n     * @return {?}\n     */\n\n\n    focusPrevElement(index) {\n      return this._foundation.focusPrevElement(index);\n    }\n    /**\n     * @param {?} role\n     * @return {?}\n     */\n\n\n    setRole(role) {\n      this._getHostElement().setAttribute('role', role);\n    }\n    /**\n     * @param {?} index\n     * @return {?}\n     */\n\n\n    setTabIndex(index) {\n      this._getHostElement().tabIndex = index;\n    }\n    /**\n     * @return {?}\n     */\n\n\n    focus() {\n      this._getHostElement().focus();\n    }\n    /**\n     * @return {?}\n     */\n\n\n    reset() {\n      this.items.forEach(\n      /**\n      * @param {?} _\n      * @return {?}\n      */\n      _ => {\n        _.selected = false;\n        _.activated = false;\n      });\n    }\n    /**\n     * @private\n     * @param {?} item\n     * @return {?}\n     */\n\n\n    _applySelectionState(item) {\n      if (this.useActivatedClass) {\n        item.activated = true;\n      } else if (this.useSelectedClass) {\n        item.selected = true;\n      }\n    }\n    /**\n     * @private\n     * @return {?}\n     */\n\n\n    _resetListItems() {\n      this._dropSubscriptions();\n\n      this._listenForListItemSelection();\n    }\n    /**\n     * @private\n     * @return {?}\n     */\n\n\n    _dropSubscriptions() {\n      if (this.itemSelectionSubscription) {\n        this.itemSelectionSubscription.unsubscribe();\n        this.itemSelectionSubscription = null;\n      }\n    }\n    /**\n     * Listens to selected events on each list item.\n     * @private\n     * @return {?}\n     */\n\n\n    _listenForListItemSelection() {\n      this.itemSelectionSubscription = this.listItemSelections.subscribe(\n      /**\n      * @param {?} event\n      * @return {?}\n      */\n      event => {\n        if (this.singleSelection) {\n          this.items.filter(\n          /**\n          * @param {?} _\n          * @return {?}\n          */\n          _ => _.id !== event.source.id && (_.activated || _.selected)).forEach(\n          /**\n          * @param {?} _\n          * @return {?}\n          */\n          _ => {\n            _.selected = false;\n            _.activated = false;\n          });\n        }\n\n        this._applySelectionState(event.source);\n\n        if (!this.singleSelection) {\n          event.source.ripple.handleBlur();\n        }\n\n        this.selectionChange.emit(new MdcListItemChange(this, event.source));\n      });\n    }\n    /**\n     * @param {?} evt\n     * @return {?}\n     */\n\n\n    _onFocusIn(evt) {\n      /** @type {?} */\n      const index = this._getListItemIndexByEvent(evt);\n\n      this._foundation.handleFocusIn(evt, index);\n    }\n    /**\n     * @param {?} evt\n     * @return {?}\n     */\n\n\n    _onFocusOut(evt) {\n      /** @type {?} */\n      const index = this._getListItemIndexByEvent(evt);\n\n      if (index >= 0) {\n        this._foundation.handleFocusOut(evt, index);\n      }\n    }\n    /**\n     * @param {?} evt\n     * @return {?}\n     */\n\n\n    _onKeydown(evt) {\n      /** @type {?} */\n      const index = this._getListItemIndexByEvent(evt);\n      /** @type {?} */\n\n\n      const target =\n      /** @type {?} */\n      evt.target;\n\n      if (index >= 0) {\n        this._foundation.handleKeydown(evt, target.classList.contains(cssClasses.LIST_ITEM_CLASS), index);\n      }\n    }\n    /**\n     * @param {?} evt\n     * @return {?}\n     */\n\n\n    _handleClickEvent(evt) {\n      /** @type {?} */\n      const index = this._getListItemIndexByEvent(evt);\n      /** @type {?} */\n\n\n      const target =\n      /** @type {?} */\n      evt.target;\n      /** @type {?} */\n\n      const listItem = this._getListItemByEventTarget(\n      /** @type {?} */\n      evt.target);\n\n      if (listItem && listItem.disabled) {\n        return;\n      } // Toggle the checkbox only if it's not the target of the event, or the checkbox will have 2 change events.\n\n      /** @type {?} */\n\n\n      const toggleCheckbox = !matches(target, strings.CHECKBOX_RADIO_SELECTOR);\n\n      this._foundation.handleClick(index, toggleCheckbox);\n    }\n    /**\n     * @private\n     * @param {?} target\n     * @return {?}\n     */\n\n\n    _getListItemByEventTarget(target) {\n      return this.items.toArray().find(\n      /**\n      * @param {?} _\n      * @return {?}\n      */\n      _ => _.getListItemElement() === target);\n    }\n    /**\n     * @private\n     * @param {?} evt\n     * @return {?}\n     */\n\n\n    _getListItemIndexByEvent(evt) {\n      return this.items.toArray().findIndex(\n      /**\n      * @param {?} _\n      * @return {?}\n      */\n      _ => _.getListItemElement() === evt.target);\n    }\n    /**\n     * Retrieves the DOM element of the component host.\n     * @private\n     * @return {?}\n     */\n\n\n    _getHostElement() {\n      return this.elementRef.nativeElement;\n    }\n\n  }\n\n  MdcList.ɵfac = function MdcList_Factory(t) {\n    return new (t || MdcList)(ɵngcc0.ɵɵdirectiveInject(ɵngcc3.Platform), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ChangeDetectorRef), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef));\n  };\n\n  MdcList.ɵcmp = /*@__PURE__*/ɵngcc0.ɵɵdefineComponent({\n    type: MdcList,\n    selectors: [[\"mdc-list\"]],\n    contentQueries: function MdcList_ContentQueries(rf, ctx, dirIndex) {\n      if (rf & 1) {\n        ɵngcc0.ɵɵcontentQuery(dirIndex, MdcListItem, 5);\n      }\n\n      if (rf & 2) {\n        let _t;\n\n        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.items = _t);\n      }\n    },\n    hostAttrs: [\"role\", \"list\", 1, \"mdc-list\"],\n    hostVars: 11,\n    hostBindings: function MdcList_HostBindings(rf, ctx) {\n      if (rf & 1) {\n        ɵngcc0.ɵɵlistener(\"click\", function MdcList_click_HostBindingHandler($event) {\n          return ctx._handleClickEvent($event);\n        })(\"keydown\", function MdcList_keydown_HostBindingHandler($event) {\n          return ctx._onKeydown($event);\n        })(\"focusin\", function MdcList_focusin_HostBindingHandler($event) {\n          return ctx._onFocusIn($event);\n        })(\"focusout\", function MdcList_focusout_HostBindingHandler($event) {\n          return ctx._onFocusOut($event);\n        });\n      }\n\n      if (rf & 2) {\n        ɵngcc0.ɵɵattribute(\"aria-orientation\", ctx.verticalOrientation ? \"vertical\" : \"horizontal\");\n        ɵngcc0.ɵɵclassProp(\"mdc-list--dense\", ctx.dense)(\"mdc-list--avatar-list\", ctx.avatar)(\"ngx-mdc-list--border\", ctx.border)(\"mdc-list--non-interactive\", !ctx.interactive)(\"mdc-list--two-line\", ctx.twoLine);\n      }\n    },\n    inputs: {\n      twoLine: \"twoLine\",\n      dense: \"dense\",\n      border: \"border\",\n      avatar: \"avatar\",\n      interactive: \"interactive\",\n      disableRipple: \"disableRipple\",\n      singleSelection: \"singleSelection\",\n      useActivatedClass: \"useActivatedClass\",\n      useSelectedClass: \"useSelectedClass\",\n      verticalOrientation: \"verticalOrientation\",\n      wrapFocus: \"wrapFocus\"\n    },\n    outputs: {\n      selectionChange: \"selectionChange\",\n      actionEvent: \"actionEvent\"\n    },\n    exportAs: [\"mdcList\"],\n    features: [ɵngcc0.ɵɵProvidersFeature([{\n      provide: MDC_LIST_PARENT_COMPONENT,\n      useExisting: MdcList\n    }]), ɵngcc0.ɵɵInheritDefinitionFeature],\n    ngContentSelectors: _c2,\n    decls: 1,\n    vars: 0,\n    template: function MdcList_Template(rf, ctx) {\n      if (rf & 1) {\n        ɵngcc0.ɵɵprojectionDef();\n        ɵngcc0.ɵɵprojection(0);\n      }\n    },\n    encapsulation: 2,\n    changeDetection: 0\n  });\n  /** @nocollapse */\n\n  return MdcList;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n/**\n * @fileoverview added by tsickle\n * Generated from: list/module.ts\n * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n\n/** @type {?} */\n\n\nconst LIST_DECLARATIONS = [MdcList, MdcListDivider, MdcListGroup, MdcListGroupSubheader, MdcListItem, MdcListItemGraphic, MdcListItemMeta, MdcListItemSecondary, MdcListItemText];\nlet MdcListModule = /*#__PURE__*/(() => {\n  class MdcListModule {}\n\n  MdcListModule.ɵfac = function MdcListModule_Factory(t) {\n    return new (t || MdcListModule)();\n  };\n\n  MdcListModule.ɵmod = /*@__PURE__*/ɵngcc0.ɵɵdefineNgModule({\n    type: MdcListModule\n  });\n  MdcListModule.ɵinj = /*@__PURE__*/ɵngcc0.ɵɵdefineInjector({\n    imports: [[CommonModule]]\n  });\n  return MdcListModule;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\n(function () {\n  (typeof ngJitMode === \"undefined\" || ngJitMode) && ɵngcc0.ɵɵsetNgModuleScope(MdcListModule, {\n    declarations: function () {\n      return [MdcList, MdcListDivider, MdcListGroup, MdcListGroupSubheader, MdcListItem, MdcListItemGraphic, MdcListItemMeta, MdcListItemSecondary, MdcListItemText];\n    },\n    imports: function () {\n      return [CommonModule];\n    },\n    exports: function () {\n      return [MdcList, MdcListDivider, MdcListGroup, MdcListGroupSubheader, MdcListItem, MdcListItemGraphic, MdcListItemMeta, MdcListItemSecondary, MdcListItemText];\n    }\n  });\n})();\n\nexport { MDC_LIST_PARENT_COMPONENT, MdcList, MdcListDivider, MdcListGroup, MdcListGroupSubheader, MdcListItem, MdcListItemChange, MdcListItemGraphic, MdcListItemMeta, MdcListItemSecondary, MdcListItemText, MdcListModule, MdcListSelectionChange }; //# sourceMappingURL=list.js.map","map":null,"metadata":{},"sourceType":"module"}