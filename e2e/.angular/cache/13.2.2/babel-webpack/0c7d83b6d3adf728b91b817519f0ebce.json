{"ast":null,"code":"/**\n * @license\n * Copyright (c) Dominic Carretto\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://github.com/trimox/angular-mdc-web/blob/master/LICENSE\n */\nimport { InjectionToken, Component, ChangeDetectionStrategy, ViewEncapsulation, ChangeDetectorRef, ElementRef, Inject, ViewChild, NgZone, NgModule, Injectable, Injector, Optional, SkipSelf, ɵɵdefineInjectable, ɵɵinject, INJECTOR } from '@angular/core';\nimport { CommonModule } from '@angular/common';\nimport { OverlayModule, Overlay } from '@angular/cdk/overlay';\nimport { BasePortalOutlet, CdkPortalOutlet, PortalModule, PortalInjector, ComponentPortal } from '@angular/cdk/portal';\nimport { MdcButtonModule } from '@angular-mdc/web/button';\nimport { LiveAnnouncer } from '@angular/cdk/a11y';\nimport { MDCComponent } from '@angular-mdc/web/base';\nimport { Subject } from 'rxjs';\nimport { MDCSnackbarFoundation } from '@material/snackbar';\nimport { take } from 'rxjs/operators';\n/**\n * @fileoverview added by tsickle\n * Generated from: snackbar/snackbar-ref.ts\n * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n\n/**\n * Reference to a snackbar dispatched from the snackbar service.\n * @template T\n */\n\nimport * as ɵngcc0 from '@angular/core';\nimport * as ɵngcc1 from '@angular/cdk/a11y';\nimport * as ɵngcc2 from '@angular/common';\nimport * as ɵngcc3 from '@angular/cdk/portal';\nimport * as ɵngcc4 from '@angular/cdk/overlay';\nconst _c0 = [\"label\"];\nconst _c1 = [\"action\"];\nconst _c2 = [\"dismiss\"];\n\nfunction MdcSnackbarComponent_div_5_button_4_Template(rf, ctx) {\n  if (rf & 1) {\n    const _r7 = ɵngcc0.ɵɵgetCurrentView();\n\n    ɵngcc0.ɵɵelementStart(0, \"button\", 9, 10);\n    ɵngcc0.ɵɵlistener(\"click\", function MdcSnackbarComponent_div_5_button_4_Template_button_click_0_listener($event) {\n      ɵngcc0.ɵɵrestoreView(_r7);\n      const ctx_r6 = ɵngcc0.ɵɵnextContext(2);\n      return ctx_r6._onActionIconClick($event);\n    });\n    ɵngcc0.ɵɵtext(2, \"close\");\n    ɵngcc0.ɵɵelementEnd();\n  }\n}\n\nfunction MdcSnackbarComponent_div_5_Template(rf, ctx) {\n  if (rf & 1) {\n    const _r9 = ɵngcc0.ɵɵgetCurrentView();\n\n    ɵngcc0.ɵɵelementStart(0, \"div\", 5);\n    ɵngcc0.ɵɵelementStart(1, \"button\", 6, 7);\n    ɵngcc0.ɵɵlistener(\"click\", function MdcSnackbarComponent_div_5_Template_button_click_1_listener($event) {\n      ɵngcc0.ɵɵrestoreView(_r9);\n      const ctx_r8 = ɵngcc0.ɵɵnextContext();\n      return ctx_r8._onActionClick($event);\n    });\n    ɵngcc0.ɵɵtext(3);\n    ɵngcc0.ɵɵelementEnd();\n    ɵngcc0.ɵɵtemplate(4, MdcSnackbarComponent_div_5_button_4_Template, 3, 0, \"button\", 8);\n    ɵngcc0.ɵɵelementEnd();\n  }\n\n  if (rf & 2) {\n    const ctx_r2 = ɵngcc0.ɵɵnextContext();\n    ɵngcc0.ɵɵadvance(3);\n    ɵngcc0.ɵɵtextInterpolate(ctx_r2.data.action);\n    ɵngcc0.ɵɵadvance(1);\n    ɵngcc0.ɵɵproperty(\"ngIf\", ctx_r2.config.dismiss);\n  }\n}\n\nfunction MdcSnackbarContainer_ng_template_0_Template(rf, ctx) {}\n\nclass MdcSnackbarRef {\n  /**\n   * @param {?} containerInstance\n   * @param {?} _overlayRef\n   */\n  constructor(containerInstance, _overlayRef) {\n    this.containerInstance = containerInstance;\n    this._overlayRef = _overlayRef;\n    /**\n     * Subject for notifying the user that the snackbar has been dismissed.\n     */\n\n    this._afterDismiss = new Subject();\n    this.componentInstance = containerInstance;\n  }\n  /**\n   * Gets an observable that is notified when the snackbar is finished closing.\n   * @return {?}\n   */\n\n\n  afterDismiss() {\n    return this._afterDismiss.asObservable();\n  }\n  /**\n   * @param {?=} reason\n   * @return {?}\n   */\n\n\n  dismiss(reason) {\n    if (!this._afterDismiss.closed) {\n      this._dismissedReason = reason;\n\n      this._finishDismiss();\n    }\n  }\n  /**\n   * Cleans up the DOM after closing.\n   * @private\n   * @return {?}\n   */\n\n\n  _finishDismiss() {\n    this._overlayRef.dispose();\n\n    this._afterDismiss.next(this._dismissedReason);\n\n    this._afterDismiss.complete();\n  }\n\n}\n/**\n * @fileoverview added by tsickle\n * Generated from: snackbar/snackbar-config.ts\n * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n\n/**\n * Injection token that can be used to access the data that was passed in to a snackbar.\n * @type {?}\n */\n\n\nconst MDC_SNACKBAR_DATA = new InjectionToken('MdcSnackbarData');\n/**\n * @template D\n */\n\nclass MdcSnackbarConfig {\n  constructor() {\n    /**\n     * Data being injected into the child component.\n     */\n    this.data = null;\n    /**\n     * Positions the action button/icon below the label instead of alongside it.\n     */\n\n    this.stacked = false;\n    /**\n     * Positions the snackbar on the leading edge of the screen\n     */\n\n    this.leading = false;\n    /**\n     * Positions the snackbar on the trailing edge of the screen\n     */\n\n    this.trailing = false;\n    /**\n     * The layout direction of the snackbar content\n     */\n\n    this.direction = 'ltr';\n    /**\n     * Show dismiss (\"X\") icon\n     */\n\n    this.dismiss = false;\n    /**\n     * Whether the snackbar closes when it is focused and the user presses the ESC key\n     */\n\n    this.closeOnEscape = true;\n    /**\n     * The politeness level for the screen reader announcement.\n     */\n\n    this.politeness = 'polite';\n  }\n\n}\n/**\n * @fileoverview added by tsickle\n * Generated from: snackbar/snackbar.component.ts\n * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n\n\nlet MdcSnackbarComponent = /*#__PURE__*/(() => {\n  class MdcSnackbarComponent extends MDCComponent {\n    /**\n     * @param {?} _changeDetectorRef\n     * @param {?} _liveAnnouncer\n     * @param {?} elementRef\n     * @param {?} snackbarRef\n     * @param {?} data\n     */\n    constructor(_changeDetectorRef, _liveAnnouncer, elementRef, snackbarRef, data) {\n      super(elementRef);\n      this._changeDetectorRef = _changeDetectorRef;\n      this._liveAnnouncer = _liveAnnouncer;\n      this.elementRef = elementRef;\n      this.snackbarRef = snackbarRef;\n      this.data = data;\n    }\n    /**\n     * @return {?}\n     */\n\n\n    get config() {\n      return this.snackbarRef.componentInstance.snackbarConfig;\n    }\n    /**\n     * @return {?}\n     */\n\n\n    getDefaultFoundation() {\n      /** @type {?} */\n      const adapter = {\n        addClass:\n        /**\n        * @param {?} className\n        * @return {?}\n        */\n        className => this._getHostElement().classList.add(className),\n        removeClass:\n        /**\n        * @param {?} className\n        * @return {?}\n        */\n        className => this._getHostElement().classList.remove(className),\n        announce:\n        /**\n        * @return {?}\n        */\n        () => this.label.nativeElement ? this._liveAnnouncer.announce(this.config.data.message, this.config.politeness, this.config.timeoutMs || MDCSnackbarFoundation.numbers.ARIA_LIVE_DELAY_MS) : {},\n        notifyClosing:\n        /**\n        * @return {?}\n        */\n        () => {},\n        notifyOpened:\n        /**\n        * @return {?}\n        */\n        () => {},\n        notifyOpening:\n        /**\n        * @return {?}\n        */\n        () => {},\n        notifyClosed:\n        /**\n        * @param {?} reason\n        * @return {?}\n        */\n        reason => this.snackbarRef.dismiss(reason)\n      };\n      return new MDCSnackbarFoundation(adapter);\n    }\n    /**\n     * @return {?}\n     */\n\n\n    ngOnInit() {\n      this._changeDetectorRef.detectChanges();\n\n      this._applyClasses();\n\n      this._applyConfig();\n    }\n    /**\n     * @return {?}\n     */\n\n\n    ngOnDestroy() {\n      if (this._foundation) {\n        this._foundation.destroy();\n      }\n    }\n    /**\n     * @param {?} evt\n     * @return {?}\n     */\n\n\n    _onKeydown(evt) {\n      this._foundation.handleKeyDown(evt);\n    }\n    /**\n     * @param {?} evt\n     * @return {?}\n     */\n\n\n    _onActionClick(evt) {\n      this._foundation.handleActionButtonClick(evt);\n    }\n    /**\n     * @param {?} evt\n     * @return {?}\n     */\n\n\n    _onActionIconClick(evt) {\n      this._foundation.handleActionIconClick(evt);\n    }\n    /**\n     * @return {?}\n     */\n\n\n    open() {\n      this._foundation.open();\n    }\n    /**\n     * @param {?=} reason\n     * @return {?}\n     */\n\n\n    close(reason) {\n      this._foundation.close(reason !== undefined ? reason.action ? 'action' : reason.dismiss ? 'dismiss' : '' : '');\n    }\n    /**\n     * @private\n     * @return {?}\n     */\n\n\n    _applyClasses() {\n      /** @type {?} */\n      const classes = this.config.classes;\n\n      if (classes) {\n        if (classes instanceof Array) {\n          this._getHostElement().classList.add(...\n          /** @type {?} */\n          this.config.classes);\n        } else {\n          this._getHostElement().classList.toggle(classes);\n        }\n      }\n      /** @type {?} */\n\n\n      const actionClasses = this.config.actionClasses;\n\n      if (actionClasses && this.action) {\n        if (actionClasses instanceof Array) {\n          this.action.nativeElement.classList.add(...\n          /** @type {?} */\n          this.config.actionClasses);\n        } else {\n          this.action.nativeElement.classList.toggle(actionClasses);\n        }\n      }\n\n      if (this.dismiss) {\n        /** @type {?} */\n        const dismissClasses = this.config.dismissClasses;\n\n        if (dismissClasses) {\n          if (dismissClasses instanceof Array) {\n            this.dismiss.nativeElement.classList.add(...\n            /** @type {?} */\n            this.config.dismissClasses);\n          } else {\n            this.dismiss.nativeElement.classList.toggle(dismissClasses);\n          }\n        }\n      }\n    }\n    /**\n     * @private\n     * @return {?}\n     */\n\n\n    _applyConfig() {\n      if (this.config.timeoutMs) {\n        this._foundation.setTimeoutMs(this.config.timeoutMs);\n      }\n\n      if (this.config.dismiss) {\n        this._foundation.setCloseOnEscape(this.config.closeOnEscape ? true : false);\n      }\n    }\n    /**\n     * Retrieves the DOM element of the component host.\n     * @private\n     * @return {?}\n     */\n\n\n    _getHostElement() {\n      return this.elementRef.nativeElement;\n    }\n\n  }\n\n  MdcSnackbarComponent.ɵfac = function MdcSnackbarComponent_Factory(t) {\n    return new (t || MdcSnackbarComponent)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ChangeDetectorRef), ɵngcc0.ɵɵdirectiveInject(ɵngcc1.LiveAnnouncer), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef), ɵngcc0.ɵɵdirectiveInject(MdcSnackbarRef), ɵngcc0.ɵɵdirectiveInject(MDC_SNACKBAR_DATA));\n  };\n\n  MdcSnackbarComponent.ɵcmp = /*@__PURE__*/ɵngcc0.ɵɵdefineComponent({\n    type: MdcSnackbarComponent,\n    selectors: [[\"mdc-snackbar\"]],\n    viewQuery: function MdcSnackbarComponent_Query(rf, ctx) {\n      if (rf & 1) {\n        ɵngcc0.ɵɵviewQuery(_c0, 7);\n        ɵngcc0.ɵɵviewQuery(_c1, 5);\n        ɵngcc0.ɵɵviewQuery(_c2, 5);\n      }\n\n      if (rf & 2) {\n        let _t;\n\n        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.label = _t.first);\n        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.action = _t.first);\n        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.dismiss = _t.first);\n      }\n    },\n    hostAttrs: [1, \"mdc-snackbar\"],\n    hostVars: 7,\n    hostBindings: function MdcSnackbarComponent_HostBindings(rf, ctx) {\n      if (rf & 1) {\n        ɵngcc0.ɵɵlistener(\"keydown\", function MdcSnackbarComponent_keydown_HostBindingHandler($event) {\n          return ctx._onKeydown($event);\n        });\n      }\n\n      if (rf & 2) {\n        ɵngcc0.ɵɵhostProperty(\"dir\", ctx.config.direction);\n        ɵngcc0.ɵɵclassProp(\"mdc-snackbar--stacked\", ctx.config.stacked)(\"mdc-snackbar--leading\", ctx.config.leading)(\"ngx-mdc-snackbar--trailing\", ctx.config.trailing);\n      }\n    },\n    features: [ɵngcc0.ɵɵProvidersFeature([LiveAnnouncer]), ɵngcc0.ɵɵInheritDefinitionFeature],\n    decls: 6,\n    vars: 2,\n    consts: [[1, \"mdc-snackbar__surface\"], [\"surface\", \"\"], [\"role\", \"status\", \"aria-live\", \"polite\", 1, \"mdc-snackbar__label\"], [\"label\", \"\"], [\"class\", \"mdc-snackbar__actions\", 4, \"ngIf\"], [1, \"mdc-snackbar__actions\"], [\"type\", \"button\", 1, \"mdc-button\", \"mdc-snackbar__action\", 3, \"click\"], [\"action\", \"\"], [\"class\", \"mdc-icon-button mdc-snackbar__dismiss material-icons\", \"title\", \"Dismiss\", 3, \"click\", 4, \"ngIf\"], [\"title\", \"Dismiss\", 1, \"mdc-icon-button\", \"mdc-snackbar__dismiss\", \"material-icons\", 3, \"click\"], [\"dismiss\", \"\"]],\n    template: function MdcSnackbarComponent_Template(rf, ctx) {\n      if (rf & 1) {\n        ɵngcc0.ɵɵelementStart(0, \"div\", 0, 1);\n        ɵngcc0.ɵɵelementStart(2, \"div\", 2, 3);\n        ɵngcc0.ɵɵtext(4);\n        ɵngcc0.ɵɵelementEnd();\n        ɵngcc0.ɵɵtemplate(5, MdcSnackbarComponent_div_5_Template, 5, 2, \"div\", 4);\n        ɵngcc0.ɵɵelementEnd();\n      }\n\n      if (rf & 2) {\n        ɵngcc0.ɵɵadvance(4);\n        ɵngcc0.ɵɵtextInterpolate(ctx.data.message);\n        ɵngcc0.ɵɵadvance(1);\n        ɵngcc0.ɵɵproperty(\"ngIf\", ctx.data.action);\n      }\n    },\n    directives: [ɵngcc2.NgIf],\n    encapsulation: 2,\n    changeDetection: 0\n  });\n  /** @nocollapse */\n\n  return MdcSnackbarComponent;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n/**\n * @fileoverview added by tsickle\n * Generated from: snackbar/snackbar-container.ts\n * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n\n\nlet MdcSnackbarContainer = /*#__PURE__*/(() => {\n  class MdcSnackbarContainer extends BasePortalOutlet {\n    /**\n     * @param {?} _ngZone\n     * @param {?} snackbarConfig\n     */\n    constructor(_ngZone, snackbarConfig) {\n      super();\n      this._ngZone = _ngZone;\n      this.snackbarConfig = snackbarConfig;\n      /**\n       * Subject for notifying that the snackbar has exited from view.\n       */\n\n      this._onExit = new Subject();\n    }\n    /**\n     * Attach a component portal as content to this snackbar container.\n     * @template T\n     * @param {?} portal\n     * @return {?}\n     */\n\n\n    attachComponentPortal(portal) {\n      return this._portalOutlet.attachComponentPortal(portal);\n    }\n    /**\n     * Attach a template portal as content to this snackbar container.\n     * @template C\n     * @param {?} portal\n     * @return {?}\n     */\n\n\n    attachTemplatePortal(portal) {\n      return this._portalOutlet.attachTemplatePortal(portal);\n    }\n    /**\n     * @return {?}\n     */\n\n\n    ngOnDestroy() {\n      this._completeExit();\n    }\n    /**\n     * Waits for the zone to settle before removing the element. Helps prevent\n     * errors where we end up removing an element which is in the middle of an animation.\n     * @private\n     * @return {?}\n     */\n\n\n    _completeExit() {\n      this._ngZone.onMicrotaskEmpty.asObservable().pipe(take(1)).subscribe(\n      /**\n      * @return {?}\n      */\n      () => {\n        this._onExit.next();\n\n        this._onExit.complete();\n      });\n    }\n\n  }\n\n  MdcSnackbarContainer.ɵfac = function MdcSnackbarContainer_Factory(t) {\n    return new (t || MdcSnackbarContainer)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.NgZone), ɵngcc0.ɵɵdirectiveInject(MdcSnackbarConfig));\n  };\n\n  MdcSnackbarContainer.ɵcmp = /*@__PURE__*/ɵngcc0.ɵɵdefineComponent({\n    type: MdcSnackbarContainer,\n    selectors: [[\"mdc-snackbar-container\"]],\n    viewQuery: function MdcSnackbarContainer_Query(rf, ctx) {\n      if (rf & 1) {\n        ɵngcc0.ɵɵviewQuery(CdkPortalOutlet, 7);\n      }\n\n      if (rf & 2) {\n        let _t;\n\n        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx._portalOutlet = _t.first);\n      }\n    },\n    features: [ɵngcc0.ɵɵInheritDefinitionFeature],\n    decls: 1,\n    vars: 0,\n    consts: [[\"cdkPortalOutlet\", \"\"]],\n    template: function MdcSnackbarContainer_Template(rf, ctx) {\n      if (rf & 1) {\n        ɵngcc0.ɵɵtemplate(0, MdcSnackbarContainer_ng_template_0_Template, 0, 0, \"ng-template\", 0);\n      }\n    },\n    directives: [ɵngcc3.CdkPortalOutlet],\n    encapsulation: 2,\n    changeDetection: 0\n  });\n  /** @nocollapse */\n\n  return MdcSnackbarContainer;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n/**\n * @fileoverview added by tsickle\n * Generated from: snackbar/module.ts\n * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n\n\nlet MdcSnackbarModule = /*#__PURE__*/(() => {\n  class MdcSnackbarModule {}\n\n  MdcSnackbarModule.ɵfac = function MdcSnackbarModule_Factory(t) {\n    return new (t || MdcSnackbarModule)();\n  };\n\n  MdcSnackbarModule.ɵmod = /*@__PURE__*/ɵngcc0.ɵɵdefineNgModule({\n    type: MdcSnackbarModule\n  });\n  MdcSnackbarModule.ɵinj = /*@__PURE__*/ɵngcc0.ɵɵdefineInjector({\n    imports: [[CommonModule, OverlayModule, PortalModule, MdcButtonModule]]\n  });\n  return MdcSnackbarModule;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\n(function () {\n  (typeof ngJitMode === \"undefined\" || ngJitMode) && ɵngcc0.ɵɵsetNgModuleScope(MdcSnackbarModule, {\n    declarations: function () {\n      return [MdcSnackbarContainer, MdcSnackbarComponent];\n    },\n    imports: function () {\n      return [CommonModule, OverlayModule, PortalModule, MdcButtonModule];\n    },\n    exports: function () {\n      return [MdcSnackbarContainer];\n    }\n  });\n})();\n/**\n * @fileoverview added by tsickle\n * Generated from: snackbar/snackbar.ts\n * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n\n/**\n * Injection token that can be used to specify default snackbar.\n * @type {?}\n */\n\n\nconst MDC_SNACKBAR_DEFAULT_OPTIONS = new InjectionToken('mdc-snackbar-default-options', {\n  providedIn: 'root',\n  factory: MDC_SNACKBAR_DEFAULT_OPTIONS_FACTORY\n});\n/**\n * \\@docs-private\n * @return {?}\n */\n\nfunction MDC_SNACKBAR_DEFAULT_OPTIONS_FACTORY() {\n  return new MdcSnackbarConfig();\n}\n\nclass MdcSnackbar {\n  /**\n   * @param {?} _overlay\n   * @param {?} _injector\n   * @param {?} _parentSnackBar\n   * @param {?} _defaultConfig\n   */\n  constructor(_overlay, _injector, _parentSnackBar, _defaultConfig) {\n    this._overlay = _overlay;\n    this._injector = _injector;\n    this._parentSnackBar = _parentSnackBar;\n    this._defaultConfig = _defaultConfig;\n    /**\n     * Reference to the current snackbar in the view *at this level* (in the Angular injector tree).\n     * If there is a parent snack-bar service, all operations should delegate to that parent\n     * via `_openedSnackBarRef`.\n     */\n\n    this._snackBarRefAtThisLevel = null;\n  }\n  /**\n   * Reference to the currently opened snackbar at *any* level.\n   * @return {?}\n   */\n\n\n  get _openedSnackbarRef() {\n    /** @type {?} */\n    const parent = this._parentSnackBar;\n    return parent ? parent._openedSnackbarRef : this._snackBarRefAtThisLevel;\n  }\n  /**\n   * @param {?} value\n   * @return {?}\n   */\n\n\n  set _openedSnackbarRef(value) {\n    if (this._parentSnackBar) {\n      this._parentSnackBar._openedSnackbarRef = value;\n    } else {\n      this._snackBarRefAtThisLevel = value;\n    }\n  }\n  /**\n   * Creates and dispatches a snackbar with a custom component for the content, removing any\n   * currently opened snackbars.\n   *\n   * @template T\n   * @param {?} component Component to be instantiated.\n   * @param {?=} config Extra configuration for the snackbar.\n   * @return {?}\n   */\n\n\n  openFromComponent(component, config) {\n    return (\n      /** @type {?} */\n      this._attach(component, config)\n    );\n  }\n  /**\n   * Opens a snackbar with a message and an optional action.\n   * @param {?} message Message text.\n   * @param {?=} action The label for the snackbar action.\n   * @param {?=} config Additional configuration options for the snackbar.\n   * @return {?}\n   */\n\n\n  open(message, action = '', config) {\n    /** @type {?} */\n    const _config = Object.assign(Object.assign({}, this._defaultConfig), config); // Since the user doesn't have access to the component, we can\n    // override the data to pass in our own message and action.\n\n\n    _config.data = {\n      message,\n      action\n    };\n    return this.openFromComponent(MdcSnackbarComponent, _config);\n  }\n  /**\n   * Dismisses the currently-visible snackbar.\n   * @return {?}\n   */\n\n\n  dismiss() {\n    if (this._openedSnackbarRef) {\n      if (this._openedSnackbarRef.instance instanceof MdcSnackbarComponent) {\n        /** @type {?} */\n        this._openedSnackbarRef.instance.close();\n      }\n\n      this._openedSnackbarRef.dismiss();\n    }\n  }\n  /**\n   * @return {?}\n   */\n\n\n  ngOnDestroy() {\n    // Only dismiss the snackbar at the current level on destroy.\n    if (this._snackBarRefAtThisLevel) {\n      this._snackBarRefAtThisLevel.dismiss();\n    }\n  }\n  /**\n   * Attaches the snackbar container component to the overlay.\n   * @private\n   * @param {?} overlayRef\n   * @param {?} config\n   * @return {?}\n   */\n\n\n  _attachSnackbarContainer(overlayRef, config) {\n    /** @type {?} */\n    const userInjector = config && config.viewContainerRef && config.viewContainerRef.injector;\n    /** @type {?} */\n\n    const injector = new PortalInjector(userInjector || this._injector, new WeakMap([[MdcSnackbarConfig, config]]));\n    /** @type {?} */\n\n    const containerPortal = new ComponentPortal(MdcSnackbarContainer, config.viewContainerRef, injector);\n    /** @type {?} */\n\n    const containerRef = overlayRef.attach(containerPortal);\n    containerRef.instance.snackbarConfig = config;\n    return containerRef.instance;\n  }\n  /**\n   * Places a new component or a template as the content of the snackbar container.\n   * @private\n   * @template T\n   * @param {?} content\n   * @param {?=} userConfig\n   * @return {?}\n   */\n\n\n  _attach(content, userConfig) {\n    /** @type {?} */\n    const config = Object.assign(Object.assign(Object.assign({}, new MdcSnackbarConfig()), this._defaultConfig), userConfig);\n    /** @type {?} */\n\n    const overlayRef = this._createOverlay();\n    /** @type {?} */\n\n\n    const container = this._attachSnackbarContainer(overlayRef, config);\n    /** @type {?} */\n\n\n    const snackbarRef = new MdcSnackbarRef(container, overlayRef);\n    /** @type {?} */\n\n    const injector = this._createInjector(config, snackbarRef);\n    /** @type {?} */\n\n\n    const portal = new ComponentPortal(content, undefined, injector);\n    /** @type {?} */\n\n    const contentRef = container.attachComponentPortal(portal); // We can't pass this via the injector, because the injector is created earlier.\n\n    snackbarRef.instance = contentRef.instance;\n\n    this._loadListeners(snackbarRef);\n\n    this._openedSnackbarRef = snackbarRef;\n\n    if (snackbarRef.instance instanceof MdcSnackbarComponent) {\n      /** @type {?} */\n      snackbarRef.instance.open();\n    }\n\n    return this._openedSnackbarRef;\n  }\n  /**\n   * @private\n   * @param {?} snackbarRef\n   * @return {?}\n   */\n\n\n  _loadListeners(snackbarRef) {\n    // When the snackbar is dismissed, clear the reference to it.\n    snackbarRef.afterDismiss().subscribe(\n    /**\n    * @return {?}\n    */\n    () => {\n      // Clear the snackbar ref if it hasn't already been replaced by a newer snackbar.\n      if (this._openedSnackbarRef === snackbarRef) {\n        this._openedSnackbarRef = null;\n      }\n    });\n\n    if (this._openedSnackbarRef) {\n      this._openedSnackbarRef.dismiss();\n    }\n  }\n  /**\n   * Creates a new overlay and places it in the correct location.\n   * @private\n   * @return {?}\n   */\n\n\n  _createOverlay() {\n    return this._overlay.create();\n  }\n  /**\n   * Creates an injector to be used inside of a snackbar component.\n   * @private\n   * @template T\n   * @param {?} config Config that was used to create the snackbar.\n   * @param {?} snackbarRef Reference to the snackbar.\n   * @return {?}\n   */\n\n\n  _createInjector(config, snackbarRef) {\n    /** @type {?} */\n    const userInjector = config && config.viewContainerRef && config.viewContainerRef.injector;\n    return new PortalInjector(userInjector || this._injector, new WeakMap([[MdcSnackbarRef, snackbarRef], [MDC_SNACKBAR_DATA, config.data]]));\n  }\n\n}\n\nMdcSnackbar.ɵfac = function MdcSnackbar_Factory(t) {\n  return new (t || MdcSnackbar)(ɵngcc0.ɵɵinject(ɵngcc4.Overlay), ɵngcc0.ɵɵinject(ɵngcc0.Injector), ɵngcc0.ɵɵinject(MdcSnackbar, 12), ɵngcc0.ɵɵinject(MDC_SNACKBAR_DEFAULT_OPTIONS));\n};\n\nMdcSnackbar.ɵprov = /*@__PURE__*/ɵngcc0.ɵɵdefineInjectable({\n  token: MdcSnackbar,\n  factory: MdcSnackbar.ɵfac,\n  providedIn: MdcSnackbarModule\n});\n/** @nocollapse */\n\n/** @nocollapse */\nMdcSnackbar.ɵprov31 = ɵɵdefineInjectable({\n  factory: function MdcSnackbar_Factory() {\n    return new MdcSnackbar(ɵɵinject(Overlay), ɵɵinject(INJECTOR), ɵɵinject(MdcSnackbar, 12), ɵɵinject(MDC_SNACKBAR_DEFAULT_OPTIONS));\n  },\n  token: MdcSnackbar,\n  providedIn: MdcSnackbarModule\n});\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\nexport { MDC_SNACKBAR_DATA, MDC_SNACKBAR_DEFAULT_OPTIONS, MDC_SNACKBAR_DEFAULT_OPTIONS_FACTORY, MdcSnackbar, MdcSnackbarComponent, MdcSnackbarConfig, MdcSnackbarContainer, MdcSnackbarModule, MdcSnackbarRef }; //# sourceMappingURL=snackbar.js.map","map":null,"metadata":{},"sourceType":"module"}