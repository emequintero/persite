{"ast":null,"code":"/**\n * @license\n * Copyright (c) Dominic Carretto\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://github.com/trimox/angular-mdc-web/blob/master/LICENSE\n */\nimport { forwardRef, EventEmitter, Component, ChangeDetectionStrategy, ViewEncapsulation, ChangeDetectorRef, ElementRef, Optional, Input, Output, ViewChild, NgModule } from '@angular/core';\nimport { MdcFormFieldControl, MdcFormField, MdcFormFieldModule } from '@angular-mdc/web/form-field';\nimport { __awaiter } from 'tslib';\nimport { NG_VALUE_ACCESSOR } from '@angular/forms';\nimport { supportsPassiveEventListeners } from '@angular/cdk/platform';\nimport { coerceBooleanProperty } from '@angular/cdk/coercion';\nimport { MDCSwitchFoundation } from '@material/switch';\nimport { MDCRippleFoundation } from '@material/ripple';\nimport { matches } from '@angular-mdc/web/dom';\nimport { MDCComponent } from '@angular-mdc/web/base';\nimport { MdcRipple } from '@angular-mdc/web/ripple';\n/**\n * @fileoverview added by tsickle\n * Generated from: switch/switch.ts\n * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n\n/** @type {?} */\n\nimport * as ɵngcc0 from '@angular/core';\nimport * as ɵngcc1 from '@angular-mdc/web/ripple';\nimport * as ɵngcc2 from '@angular-mdc/web/form-field';\nconst _c0 = [\"input\"];\nconst _c1 = [\"thumbUnderlay\"];\nconst MDC_SWITCH_CONTROL_VALUE_ACCESSOR = {\n  provide: NG_VALUE_ACCESSOR,\n  useExisting: forwardRef(\n  /**\n  * @return {?}\n  */\n  () => MdcSwitch),\n  multi: true\n};\n/**\n * Change event object emitted by MdcSwitch.\n */\n\nclass MdcSwitchChange {\n  /**\n   * @param {?} source\n   * @param {?} checked\n   */\n  constructor(source, checked) {\n    this.source = source;\n    this.checked = checked;\n  }\n\n}\n/** @type {?} */\n\n\nlet nextUniqueId = 0;\nlet MdcSwitch = /*#__PURE__*/(() => {\n  class MdcSwitch extends MDCComponent {\n    /**\n     * @param {?} _changeDetectorRef\n     * @param {?} ripple\n     * @param {?} elementRef\n     * @param {?} _parentFormField\n     */\n    constructor(_changeDetectorRef, ripple, elementRef, _parentFormField) {\n      super(elementRef);\n      this._changeDetectorRef = _changeDetectorRef;\n      this.ripple = ripple;\n      this.elementRef = elementRef;\n      this._parentFormField = _parentFormField;\n      this._uniqueId = `mdc-switch-${++nextUniqueId}`;\n      this._initialized = false;\n      this.id = this._uniqueId;\n      this.name = null;\n      this.tabIndex = 0;\n      /**\n       * The value attribute of the native input element\n       */\n\n      this.value = null;\n      this._checked = false;\n      this._disabled = false;\n      this._required = false;\n      /**\n       * Used to set the aria-label attribute on the underlying input element.\n       */\n\n      this.ariaLabel = null;\n      /**\n       * Used to set the aria-labelledby attribute on the underlying input element.\n       */\n\n      this.ariaLabelledby = null;\n      this.change = new EventEmitter();\n      /**\n       * View to model callback called when value changes\n       */\n\n      this._onChange =\n      /**\n      * @param {?} _\n      * @return {?}\n      */\n      _ => {};\n      /**\n       * View to model callback called when control has been touched\n       */\n\n\n      this._onTouched =\n      /**\n      * @return {?}\n      */\n      () => {};\n\n      this._root = this.elementRef.nativeElement;\n\n      if (this._parentFormField) {\n        _parentFormField.elementRef.nativeElement.classList.add('mdc-form-field');\n      }\n    }\n    /**\n     * @return {?}\n     */\n\n\n    get checked() {\n      return this._checked;\n    }\n    /**\n     * @param {?} value\n     * @return {?}\n     */\n\n\n    set checked(value) {\n      if (this.disabled) {\n        return;\n      }\n\n      this._checked = coerceBooleanProperty(value);\n\n      this._changeDetectorRef.markForCheck();\n    }\n    /**\n     * @return {?}\n     */\n\n\n    get disabled() {\n      return this._disabled;\n    }\n    /**\n     * @param {?} value\n     * @return {?}\n     */\n\n\n    set disabled(value) {\n      this.setDisabledState(value);\n    }\n    /**\n     * @return {?}\n     */\n\n\n    get required() {\n      return this._required;\n    }\n    /**\n     * @param {?} value\n     * @return {?}\n     */\n\n\n    set required(value) {\n      this._required = coerceBooleanProperty(value);\n    }\n    /**\n     * @return {?}\n     */\n\n\n    get inputId() {\n      return `${this.id || this._uniqueId}-input`;\n    }\n    /**\n     * @return {?}\n     */\n\n\n    getDefaultFoundation() {\n      // Do not initialize foundation until ngAfterViewInit runs\n      if (!this._initialized) {\n        return undefined;\n      }\n      /** @type {?} */\n\n\n      const adapter = {\n        addClass:\n        /**\n        * @param {?} className\n        * @return {?}\n        */\n        className => this._getHostElement().classList.add(className),\n        removeClass:\n        /**\n        * @param {?} className\n        * @return {?}\n        */\n        className => this._getHostElement().classList.remove(className),\n        setNativeControlChecked:\n        /**\n        * @param {?} checked\n        * @return {?}\n        */\n        checked => this._getInputElement().checked = checked,\n        setNativeControlDisabled:\n        /**\n        * @param {?} disabled\n        * @return {?}\n        */\n        disabled => this._getInputElement().disabled = disabled,\n        setNativeControlAttr:\n        /**\n        * @param {?} attr\n        * @param {?} value\n        * @return {?}\n        */\n        (attr, value) => this._getInputElement().setAttribute(attr, value)\n      };\n      return new MDCSwitchFoundation(adapter);\n    }\n    /**\n     * @return {?}\n     */\n\n\n    ngAfterViewInit() {\n      this._initialized = true;\n      this.ripple = this._createRipple();\n      this.ripple.init();\n\n      this._asyncBuildFoundation().then(\n      /**\n      * @return {?}\n      */\n      () => {\n        this._foundation.init();\n\n        this.setDisabledState(this._inputElement.nativeElement.disabled);\n      });\n    }\n    /**\n     * @return {?}\n     */\n\n\n    ngOnDestroy() {\n      this.ripple.destroy();\n      this.destroy();\n    }\n    /**\n     * @return {?}\n     */\n\n\n    _asyncBuildFoundation() {\n      return __awaiter(this, void 0, void 0, function* () {\n        this._foundation = this.getDefaultFoundation();\n      });\n    }\n    /**\n     * @param {?} evt\n     * @return {?}\n     */\n\n\n    onChange(evt) {\n      evt.stopPropagation();\n\n      this._foundation.handleChange(evt);\n\n      this._checked = this._inputElement.nativeElement.checked;\n\n      this._foundation.setChecked(this._checked);\n\n      this._emitChangeEvent();\n\n      this._changeDetectorRef.markForCheck();\n    }\n    /**\n     * @param {?} evt\n     * @return {?}\n     */\n\n\n    onInputClick(evt) {\n      evt.stopPropagation();\n    }\n    /**\n     * @return {?}\n     */\n\n\n    onBlur() {\n      this._onTouched();\n    }\n    /**\n     * @param {?} value\n     * @return {?}\n     */\n\n\n    writeValue(value) {\n      this.checked = !!value;\n    }\n    /**\n     * @param {?} fn\n     * @return {?}\n     */\n\n\n    registerOnChange(fn) {\n      this._onChange = fn;\n    }\n    /**\n     * @param {?} fn\n     * @return {?}\n     */\n\n\n    registerOnTouched(fn) {\n      this._onTouched = fn;\n    }\n    /**\n     * Toggles the checked state of the switch.\n     * @return {?}\n     */\n\n\n    toggle() {\n      this.checked = !this.checked;\n\n      this._onChange(this.checked);\n    }\n    /**\n     * @param {?} disabled\n     * @return {?}\n     */\n\n\n    setDisabledState(disabled) {\n      var _a;\n      /** @type {?} */\n\n\n      const newValue = coerceBooleanProperty(disabled);\n\n      if (newValue !== this._disabled) {\n        this._disabled = newValue;\n        (_a = this._foundation) === null || _a === void 0 ? void 0 : _a.setDisabled(newValue);\n\n        this._changeDetectorRef.markForCheck();\n      }\n    }\n    /**\n     * @return {?}\n     */\n\n\n    focus() {\n      this._inputElement.nativeElement.focus();\n    }\n    /**\n     * @private\n     * @return {?}\n     */\n\n\n    _createRipple() {\n      /** @type {?} */\n      const rippleSurface =\n      /** @type {?} */\n      this.thumbUnderlay.nativeElement;\n      /** @type {?} */\n\n      const adapter = Object.assign(Object.assign({}, MdcRipple.createAdapter(this)), {\n        addClass:\n        /**\n        * @param {?} className\n        * @return {?}\n        */\n        className => rippleSurface.classList.add(className),\n        computeBoundingRect:\n        /**\n        * @return {?}\n        */\n        () => rippleSurface.getBoundingClientRect(),\n        deregisterInteractionHandler:\n        /**\n        * @param {?} evtType\n        * @param {?} handler\n        * @return {?}\n        */\n        (evtType, handler) => this._inputElement.nativeElement.removeEventListener(evtType, handler, supportsPassiveEventListeners()),\n        isSurfaceActive:\n        /**\n        * @return {?}\n        */\n        () => matches(this._inputElement.nativeElement, ':active'),\n        isUnbounded:\n        /**\n        * @return {?}\n        */\n        () => true,\n        registerInteractionHandler:\n        /**\n        * @param {?} evtType\n        * @param {?} handler\n        * @return {?}\n        */\n        (evtType, handler) => this._inputElement.nativeElement.addEventListener(evtType, handler, supportsPassiveEventListeners()),\n        removeClass:\n        /**\n        * @param {?} className\n        * @return {?}\n        */\n        className => rippleSurface.classList.remove(className),\n        updateCssVariable:\n        /**\n        * @param {?} varName\n        * @param {?} value\n        * @return {?}\n        */\n        (varName, value) => rippleSurface.style.setProperty(varName, value)\n      });\n      return new MdcRipple(this.elementRef, new MDCRippleFoundation(adapter));\n    }\n    /**\n     * Emits a change event on the `change` output. Also notifies the FormControl about the change.\n     * @private\n     * @return {?}\n     */\n\n\n    _emitChangeEvent() {\n      this._onChange(this.checked);\n\n      this.change.emit(new MdcSwitchChange(this, this.checked));\n    }\n    /**\n     * Retrieves the DOM element of the component input.\n     * @private\n     * @return {?}\n     */\n\n\n    _getInputElement() {\n      return this._inputElement.nativeElement;\n    }\n    /**\n     * Retrieves the DOM element of the component host.\n     * @private\n     * @return {?}\n     */\n\n\n    _getHostElement() {\n      return this.elementRef.nativeElement;\n    }\n\n  }\n\n  MdcSwitch.ɵfac = function MdcSwitch_Factory(t) {\n    return new (t || MdcSwitch)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ChangeDetectorRef), ɵngcc0.ɵɵdirectiveInject(ɵngcc1.MdcRipple), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef), ɵngcc0.ɵɵdirectiveInject(ɵngcc2.MdcFormField, 8));\n  };\n\n  MdcSwitch.ɵcmp = /*@__PURE__*/ɵngcc0.ɵɵdefineComponent({\n    type: MdcSwitch,\n    selectors: [[\"mdc-switch\"]],\n    viewQuery: function MdcSwitch_Query(rf, ctx) {\n      if (rf & 1) {\n        ɵngcc0.ɵɵviewQuery(_c0, 7);\n        ɵngcc0.ɵɵviewQuery(_c1, 5);\n      }\n\n      if (rf & 2) {\n        let _t;\n\n        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx._inputElement = _t.first);\n        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.thumbUnderlay = _t.first);\n      }\n    },\n    hostAttrs: [1, \"mdc-switch\"],\n    hostVars: 5,\n    hostBindings: function MdcSwitch_HostBindings(rf, ctx) {\n      if (rf & 1) {\n        ɵngcc0.ɵɵlistener(\"focus\", function MdcSwitch_focus_HostBindingHandler() {\n          return ctx._inputElement.nativeElement.focus();\n        });\n      }\n\n      if (rf & 2) {\n        ɵngcc0.ɵɵhostProperty(\"id\", ctx.id);\n        ɵngcc0.ɵɵclassProp(\"mdc-switch--checked\", ctx.checked)(\"mdc-switch--disabled\", ctx.disabled);\n      }\n    },\n    inputs: {\n      id: \"id\",\n      name: \"name\",\n      tabIndex: \"tabIndex\",\n      value: \"value\",\n      ariaLabel: [\"aria-label\", \"ariaLabel\"],\n      ariaLabelledby: [\"aria-labelledby\", \"ariaLabelledby\"],\n      checked: \"checked\",\n      disabled: \"disabled\",\n      required: \"required\"\n    },\n    outputs: {\n      change: \"change\"\n    },\n    features: [ɵngcc0.ɵɵProvidersFeature([MDC_SWITCH_CONTROL_VALUE_ACCESSOR, {\n      provide: MdcFormFieldControl,\n      useExisting: MdcSwitch\n    }, MdcRipple]), ɵngcc0.ɵɵInheritDefinitionFeature],\n    decls: 6,\n    vars: 8,\n    consts: [[1, \"mdc-switch__track\"], [1, \"mdc-switch__thumb-underlay\"], [\"thumbUnderlay\", \"\"], [1, \"mdc-switch__thumb\"], [\"type\", \"checkbox\", \"role\", \"switch\", 1, \"mdc-switch__native-control\", 3, \"id\", \"tabIndex\", \"disabled\", \"required\", \"checked\", \"blur\", \"click\", \"change\"], [\"input\", \"\"]],\n    template: function MdcSwitch_Template(rf, ctx) {\n      if (rf & 1) {\n        ɵngcc0.ɵɵelement(0, \"div\", 0);\n        ɵngcc0.ɵɵelementStart(1, \"div\", 1, 2);\n        ɵngcc0.ɵɵelement(3, \"div\", 3);\n        ɵngcc0.ɵɵelementStart(4, \"input\", 4, 5);\n        ɵngcc0.ɵɵlistener(\"blur\", function MdcSwitch_Template_input_blur_4_listener() {\n          return ctx.onBlur();\n        })(\"click\", function MdcSwitch_Template_input_click_4_listener($event) {\n          return ctx.onInputClick($event);\n        })(\"change\", function MdcSwitch_Template_input_change_4_listener($event) {\n          return ctx.onChange($event);\n        });\n        ɵngcc0.ɵɵelementEnd();\n        ɵngcc0.ɵɵelementEnd();\n      }\n\n      if (rf & 2) {\n        ɵngcc0.ɵɵadvance(4);\n        ɵngcc0.ɵɵproperty(\"id\", ctx.inputId)(\"tabIndex\", ctx.tabIndex)(\"disabled\", ctx.disabled)(\"required\", ctx.required)(\"checked\", ctx.checked);\n        ɵngcc0.ɵɵattribute(\"name\", ctx.name)(\"aria-label\", ctx.ariaLabel)(\"aria-labelledby\", ctx.ariaLabelledby);\n      }\n    },\n    encapsulation: 2,\n    changeDetection: 0\n  });\n  /** @nocollapse */\n\n  return MdcSwitch;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n/**\n * @fileoverview added by tsickle\n * Generated from: switch/module.ts\n * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n\n\nlet MdcSwitchModule = /*#__PURE__*/(() => {\n  class MdcSwitchModule {}\n\n  MdcSwitchModule.ɵfac = function MdcSwitchModule_Factory(t) {\n    return new (t || MdcSwitchModule)();\n  };\n\n  MdcSwitchModule.ɵmod = /*@__PURE__*/ɵngcc0.ɵɵdefineNgModule({\n    type: MdcSwitchModule\n  });\n  MdcSwitchModule.ɵinj = /*@__PURE__*/ɵngcc0.ɵɵdefineInjector({\n    imports: [[MdcFormFieldModule], MdcFormFieldModule]\n  });\n  return MdcSwitchModule;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\n(function () {\n  (typeof ngJitMode === \"undefined\" || ngJitMode) && ɵngcc0.ɵɵsetNgModuleScope(MdcSwitchModule, {\n    declarations: function () {\n      return [MdcSwitch];\n    },\n    imports: function () {\n      return [MdcFormFieldModule];\n    },\n    exports: function () {\n      return [MdcFormFieldModule, MdcSwitch];\n    }\n  });\n})();\n\nexport { MDC_SWITCH_CONTROL_VALUE_ACCESSOR, MdcSwitch, MdcSwitchChange, MdcSwitchModule }; //# sourceMappingURL=switch.js.map","map":null,"metadata":{},"sourceType":"module"}