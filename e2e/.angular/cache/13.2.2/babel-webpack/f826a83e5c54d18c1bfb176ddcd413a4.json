{"ast":null,"code":"/**\n * @license\n * Copyright (c) Dominic Carretto\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://github.com/trimox/angular-mdc-web/blob/master/LICENSE\n */\nimport { forwardRef, EventEmitter, Component, ViewEncapsulation, ChangeDetectionStrategy, NgZone, ChangeDetectorRef, ElementRef, Optional, Input, Output, ViewChild, NgModule } from '@angular/core';\nimport { CommonModule } from '@angular/common';\nimport { MdcFormFieldControl, MdcFormField, MdcFormFieldModule } from '@angular-mdc/web/form-field';\nimport { __awaiter } from 'tslib';\nimport { NG_VALUE_ACCESSOR } from '@angular/forms';\nimport { coerceBooleanProperty } from '@angular/cdk/coercion';\nimport { supportsPassiveEventListeners, Platform } from '@angular/cdk/platform';\nimport { Subject, fromEvent } from 'rxjs';\nimport { takeUntil, filter } from 'rxjs/operators';\nimport { matches } from '@angular-mdc/web/dom';\nimport { MDCRippleFoundation } from '@material/ripple';\nimport { MDCCheckboxFoundation } from '@material/checkbox';\nimport { MDCComponent } from '@angular-mdc/web/base';\nimport { MdcRipple } from '@angular-mdc/web/ripple';\n/**\n * @fileoverview added by tsickle\n * Generated from: checkbox/checkbox.ts\n * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n\n/** @type {?} */\n\nimport * as ɵngcc0 from '@angular/core';\nimport * as ɵngcc1 from '@angular/cdk/platform';\nimport * as ɵngcc2 from '@angular-mdc/web/ripple';\nimport * as ɵngcc3 from '@angular-mdc/web/form-field';\nimport * as ɵngcc4 from '@angular/common';\nconst _c0 = [\"input\"];\n\nfunction MdcCheckbox_div_6_Template(rf, ctx) {\n  if (rf & 1) {\n    ɵngcc0.ɵɵelement(0, \"div\", 7);\n  }\n}\n\nlet nextUniqueId = 0;\n/**\n * Change event object emitted by MdcCheckbox.\n */\n\nclass MdcCheckboxChange {\n  /**\n   * @param {?} source\n   * @param {?} checked\n   */\n  constructor(source, checked) {\n    this.source = source;\n    this.checked = checked;\n  }\n\n}\n/** @type {?} */\n\n\nconst MDC_CHECKBOX_CONTROL_VALUE_ACCESSOR = {\n  provide: NG_VALUE_ACCESSOR,\n  useExisting: forwardRef(\n  /**\n  * @return {?}\n  */\n  () => MdcCheckbox),\n  multi: true\n};\nlet MdcCheckbox = /*#__PURE__*/(() => {\n  class MdcCheckbox extends MDCComponent {\n    /**\n     * @param {?} _platform\n     * @param {?} _ngZone\n     * @param {?} _changeDetectorRef\n     * @param {?} elementRef\n     * @param {?} ripple\n     * @param {?} _parentFormField\n     */\n    constructor(_platform, _ngZone, _changeDetectorRef, elementRef, ripple, _parentFormField) {\n      super(elementRef);\n      this._platform = _platform;\n      this._ngZone = _ngZone;\n      this._changeDetectorRef = _changeDetectorRef;\n      this.elementRef = elementRef;\n      this.ripple = ripple;\n      this._parentFormField = _parentFormField;\n      /**\n       * Emits whenever the component is destroyed.\n       */\n\n      this._destroy = new Subject();\n      this._initialized = false;\n      this._uniqueId = `mdc-checkbox-${++nextUniqueId}`;\n      this.id = this._uniqueId;\n      this.name = null;\n      this._checked = false;\n      this._touch = false;\n      this._disabled = false;\n      /**\n       * The value attribute of the native input element\n       */\n\n      this.value = null;\n      this._indeterminate = false;\n      this._indeterminateToChecked = true;\n      this._disableRipple = false;\n      this.tabIndex = 0;\n      this.ariaLabel = '';\n      this.ariaLabelledby = null;\n      /**\n       * Fired when checkbox is checked or unchecked, but not when set\n       * indeterminate. Sends the state of [checked].\n       */\n\n      this.change = new EventEmitter();\n      /**\n       * Fired when checkbox goes in and out of indeterminate state, but not when\n       * set to checked. Sends the state of [indeterminate];\n       */\n\n      this.indeterminateChange = new EventEmitter();\n      /**\n       * View to model callback called when value changes\n       */\n\n      this._onChange =\n      /**\n      * @return {?}\n      */\n      () => {};\n      /**\n       * View to model callback called when component has been touched\n       */\n\n\n      this._onTouched =\n      /**\n      * @return {?}\n      */\n      () => {};\n\n      this._root = this.elementRef.nativeElement;\n\n      if (this._parentFormField) {\n        _parentFormField.elementRef.nativeElement.classList.add('mdc-form-field');\n      }\n    }\n    /**\n     * Returns the unique id for the visual hidden input.\n     * @return {?}\n     */\n\n\n    get inputId() {\n      return `${this.id || this._uniqueId}-input`;\n    }\n    /**\n     * @return {?}\n     */\n\n\n    get checked() {\n      return this._checked;\n    }\n    /**\n     * @param {?} value\n     * @return {?}\n     */\n\n\n    set checked(value) {\n      if (value !== this.checked) {\n        this._checked = coerceBooleanProperty(value);\n\n        this._changeDetectorRef.markForCheck();\n      }\n    }\n    /**\n     * @return {?}\n     */\n\n\n    get touch() {\n      return this._touch;\n    }\n    /**\n     * @param {?} value\n     * @return {?}\n     */\n\n\n    set touch(value) {\n      this._touch = coerceBooleanProperty(value);\n    }\n    /**\n     * @return {?}\n     */\n\n\n    get disabled() {\n      return this._disabled;\n    }\n    /**\n     * @param {?} value\n     * @return {?}\n     */\n\n\n    set disabled(value) {\n      this.setDisabledState(value);\n    }\n    /**\n     * Alternative state of the checkbox, not user set-able state. Between\n     * [checked] and [indeterminate], only one can be true, though both can be\n     * false.\n     * `true` is INDETERMINATE and `false` is not.\n     * @return {?}\n     */\n\n\n    get indeterminate() {\n      return this._indeterminate;\n    }\n    /**\n     * @param {?} value\n     * @return {?}\n     */\n\n\n    set indeterminate(value) {\n      var _a;\n\n      if (this.disabled) {\n        return;\n      }\n      /** @type {?} */\n\n\n      const newValue = coerceBooleanProperty(value);\n\n      if (newValue !== this._indeterminate) {\n        this._indeterminate = newValue;\n\n        if (newValue) {\n          this.checked = false;\n        }\n\n        this.indeterminateChange.emit({\n          source: this,\n          indeterminate: this._indeterminate\n        });\n\n        this._changeDetectorRef.markForCheck();\n\n        (_a = this._foundation) === null || _a === void 0 ? void 0 : _a.handleChange();\n      }\n    }\n    /**\n     * Determines the state to go into when [indeterminate] state is toggled.\n     * `true` will go to checked and `false` will go to unchecked.\n     * @return {?}\n     */\n\n\n    get indeterminateToChecked() {\n      return this._indeterminateToChecked;\n    }\n    /**\n     * @param {?} value\n     * @return {?}\n     */\n\n\n    set indeterminateToChecked(value) {\n      this._indeterminateToChecked = coerceBooleanProperty(value);\n\n      this._changeDetectorRef.markForCheck();\n    }\n    /**\n     * Whether the ripple ink is disabled.\n     * @return {?}\n     */\n\n\n    get disableRipple() {\n      return this._disableRipple;\n    }\n    /**\n     * @param {?} value\n     * @return {?}\n     */\n\n\n    set disableRipple(value) {\n      this._disableRipple = coerceBooleanProperty(value);\n    }\n    /**\n     * @return {?}\n     */\n\n\n    getDefaultFoundation() {\n      // Do not initialize foundation until ngAfterViewInit runs\n      if (!this._initialized) {\n        return undefined;\n      }\n      /** @type {?} */\n\n\n      const adapter = {\n        addClass:\n        /**\n        * @param {?} className\n        * @return {?}\n        */\n        className => this._root.classList.add(className),\n        removeClass:\n        /**\n        * @param {?} className\n        * @return {?}\n        */\n        className => this._root.classList.remove(className),\n        setNativeControlAttr:\n        /**\n        * @param {?} attr\n        * @param {?} value\n        * @return {?}\n        */\n        (attr, value) => this._inputElement.nativeElement.setAttribute(attr, value),\n        removeNativeControlAttr:\n        /**\n        * @param {?} attr\n        * @return {?}\n        */\n        attr => this._inputElement.nativeElement.removeAttribute(attr),\n        isIndeterminate:\n        /**\n        * @return {?}\n        */\n        () => this.indeterminate,\n        isChecked:\n        /**\n        * @return {?}\n        */\n        () => this.checked,\n        hasNativeControl:\n        /**\n        * @return {?}\n        */\n        () => true,\n        setNativeControlDisabled:\n        /**\n        * @param {?} disabled\n        * @return {?}\n        */\n        disabled => this._inputElement.nativeElement.disabled = disabled,\n        forceLayout:\n        /**\n        * @return {?}\n        */\n        () =>\n        /** @type {?} */\n        this._root.offsetWidth,\n        isAttachedToDOM:\n        /**\n        * @return {?}\n        */\n        () => true\n      };\n      return new MDCCheckboxFoundation(adapter);\n    }\n    /**\n     * @return {?}\n     */\n\n\n    _asyncBuildFoundation() {\n      return __awaiter(this, void 0, void 0, function* () {\n        this._foundation = this.getDefaultFoundation();\n      });\n    }\n    /**\n     * @return {?}\n     */\n\n\n    ngAfterViewInit() {\n      this._initialized = true;\n\n      this._asyncBuildFoundation().then(\n      /**\n      * @return {?}\n      */\n      () => {\n        this._foundation.init();\n\n        this.setDisabledState(this._inputElement.nativeElement.disabled);\n        this.ripple = this._createRipple();\n        this.ripple.init();\n      });\n\n      this._loadListeners();\n    }\n    /**\n     * @return {?}\n     */\n\n\n    ngOnDestroy() {\n      this._destroy.next();\n\n      this._destroy.complete();\n\n      this.ripple.destroy();\n\n      this._foundation.destroy();\n    }\n    /**\n     * @param {?} value\n     * @return {?}\n     */\n\n\n    writeValue(value) {\n      this.checked = !!value;\n    }\n    /**\n     * @param {?} fn\n     * @return {?}\n     */\n\n\n    registerOnChange(fn) {\n      this._onChange = fn;\n    }\n    /**\n     * @param {?} fn\n     * @return {?}\n     */\n\n\n    registerOnTouched(fn) {\n      this._onTouched = fn;\n    }\n    /**\n     * Focuses the checkbox.\n     * @return {?}\n     */\n\n\n    focus() {\n      if (!this.disabled) {\n        this._inputElement.nativeElement.focus();\n      }\n    }\n    /**\n     * @param {?=} checked\n     * @return {?}\n     */\n\n\n    toggle(checked) {\n      this._setState(checked);\n    }\n    /**\n     * @param {?} evt\n     * @return {?}\n     */\n\n\n    _onInteraction(evt) {\n      // We have to stop propagation for click events on the visual hidden input element.\n      // Preventing bubbling for the second event will solve that issue.\n      evt.stopPropagation();\n\n      this._setState();\n\n      this._onChange(this.checked);\n\n      this._changeDetectorRef.markForCheck();\n\n      this.change.emit(new MdcCheckboxChange(this, this.checked));\n    }\n    /**\n     * @param {?} evt\n     * @return {?}\n     */\n\n\n    _onInputClick(evt) {\n      evt.stopPropagation();\n    }\n    /**\n     * @param {?} disabled\n     * @return {?}\n     */\n\n\n    setDisabledState(disabled) {\n      var _a;\n      /** @type {?} */\n\n\n      const newValue = coerceBooleanProperty(disabled);\n\n      if (newValue !== this._disabled) {\n        this._disabled = newValue;\n        (_a = this._foundation) === null || _a === void 0 ? void 0 : _a.setDisabled(newValue);\n\n        this._changeDetectorRef.markForCheck();\n      }\n    }\n    /**\n     * @private\n     * @param {?=} checked\n     * @return {?}\n     */\n\n\n    _setState(checked) {\n      if (this.disabled) {\n        return;\n      }\n\n      if (this.indeterminate) {\n        this._checked = this.indeterminateToChecked;\n        this.indeterminate = false;\n      } else {\n        this.checked = checked || !this.checked;\n      } // Reset native input when clicked with noop. The native checkbox becomes checked after\n      // click, reset it to be align with `checked` value of `mdc-checkbox`.\n\n\n      this._inputElement.nativeElement.checked = this.checked;\n\n      this._ngZone.runOutsideAngular(\n      /**\n      * @return {?}\n      */\n      () => requestAnimationFrame(\n      /**\n      * @return {?}\n      */\n      () => this._foundation.handleChange()));\n    }\n    /**\n     * @private\n     * @return {?}\n     */\n\n\n    _createRipple() {\n      /** @type {?} */\n      const adapter = Object.assign(Object.assign({}, MdcRipple.createAdapter(this)), {\n        isSurfaceActive:\n        /**\n        * @return {?}\n        */\n        () => matches(this._inputElement.nativeElement, ':active'),\n        isUnbounded:\n        /**\n        * @return {?}\n        */\n        () => true,\n        isSurfaceDisabled:\n        /**\n        * @return {?}\n        */\n        () => this.disableRipple,\n        deregisterInteractionHandler:\n        /**\n        * @param {?} evtType\n        * @param {?} handler\n        * @return {?}\n        */\n        (evtType, handler) => this._inputElement.nativeElement.removeEventListener(evtType, handler, supportsPassiveEventListeners()),\n        registerInteractionHandler:\n        /**\n        * @param {?} evtType\n        * @param {?} handler\n        * @return {?}\n        */\n        (evtType, handler) => this._inputElement.nativeElement.addEventListener(evtType, handler, supportsPassiveEventListeners())\n      });\n      return new MdcRipple(this.elementRef, new MDCRippleFoundation(adapter));\n    }\n    /**\n     * @private\n     * @return {?}\n     */\n\n\n    _loadListeners() {\n      if (!this._platform.isBrowser) {\n        return;\n      }\n\n      this._ngZone.runOutsideAngular(\n      /**\n      * @return {?}\n      */\n      () => fromEvent(this._root, 'animationend').pipe(takeUntil(this._destroy), filter(\n      /**\n      * @param {?} e\n      * @return {?}\n      */\n      e => e.target === this._root)).subscribe(\n      /**\n      * @return {?}\n      */\n      () => this._ngZone.run(\n      /**\n      * @return {?}\n      */\n      () => this._foundation.handleAnimationEnd())));\n    }\n\n  }\n\n  MdcCheckbox.ɵfac = function MdcCheckbox_Factory(t) {\n    return new (t || MdcCheckbox)(ɵngcc0.ɵɵdirectiveInject(ɵngcc1.Platform), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.NgZone), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ChangeDetectorRef), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef), ɵngcc0.ɵɵdirectiveInject(ɵngcc2.MdcRipple), ɵngcc0.ɵɵdirectiveInject(ɵngcc3.MdcFormField, 8));\n  };\n\n  MdcCheckbox.ɵcmp = /*@__PURE__*/ɵngcc0.ɵɵdefineComponent({\n    type: MdcCheckbox,\n    selectors: [[\"mdc-checkbox\"]],\n    viewQuery: function MdcCheckbox_Query(rf, ctx) {\n      if (rf & 1) {\n        ɵngcc0.ɵɵviewQuery(_c0, 7);\n      }\n\n      if (rf & 2) {\n        let _t;\n\n        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx._inputElement = _t.first);\n      }\n    },\n    hostAttrs: [1, \"mdc-checkbox\"],\n    hostVars: 3,\n    hostBindings: function MdcCheckbox_HostBindings(rf, ctx) {\n      if (rf & 2) {\n        ɵngcc0.ɵɵhostProperty(\"id\", ctx.id);\n        ɵngcc0.ɵɵclassProp(\"mdc-checkbox--touch\", ctx.touch);\n      }\n    },\n    inputs: {\n      id: \"id\",\n      name: \"name\",\n      value: \"value\",\n      tabIndex: \"tabIndex\",\n      ariaLabel: [\"aria-label\", \"ariaLabel\"],\n      ariaLabelledby: [\"aria-labelledby\", \"ariaLabelledby\"],\n      checked: \"checked\",\n      touch: \"touch\",\n      disabled: \"disabled\",\n      indeterminate: \"indeterminate\",\n      indeterminateToChecked: \"indeterminateToChecked\",\n      disableRipple: \"disableRipple\"\n    },\n    outputs: {\n      change: \"change\",\n      indeterminateChange: \"indeterminateChange\"\n    },\n    exportAs: [\"mdcCheckbox\"],\n    features: [ɵngcc0.ɵɵProvidersFeature([MDC_CHECKBOX_CONTROL_VALUE_ACCESSOR, MdcRipple, {\n      provide: MdcFormFieldControl,\n      useExisting: MdcCheckbox\n    }]), ɵngcc0.ɵɵInheritDefinitionFeature],\n    decls: 7,\n    vars: 10,\n    consts: [[\"type\", \"checkbox\", 1, \"mdc-checkbox__native-control\", 3, \"id\", \"tabIndex\", \"disabled\", \"checked\", \"indeterminate\", \"change\", \"click\"], [\"input\", \"\"], [1, \"mdc-checkbox__background\"], [\"viewBox\", \"0 0 24 24\", \"focusable\", \"false\", 1, \"mdc-checkbox__checkmark\"], [\"fill\", \"none\", \"d\", \"M1.73,12.91 8.1,19.28 22.79,4.59\", 1, \"mdc-checkbox__checkmark-path\"], [1, \"mdc-checkbox__mixedmark\"], [\"class\", \"mdc-checkbox__ripple\", 4, \"ngIf\"], [1, \"mdc-checkbox__ripple\"]],\n    template: function MdcCheckbox_Template(rf, ctx) {\n      if (rf & 1) {\n        ɵngcc0.ɵɵelementStart(0, \"input\", 0, 1);\n        ɵngcc0.ɵɵlistener(\"change\", function MdcCheckbox_Template_input_change_0_listener($event) {\n          return ctx._onInteraction($event);\n        })(\"click\", function MdcCheckbox_Template_input_click_0_listener($event) {\n          return ctx._onInputClick($event);\n        });\n        ɵngcc0.ɵɵelementEnd();\n        ɵngcc0.ɵɵelementStart(2, \"div\", 2);\n        ɵngcc0.ɵɵnamespaceSVG();\n        ɵngcc0.ɵɵelementStart(3, \"svg\", 3);\n        ɵngcc0.ɵɵelement(4, \"path\", 4);\n        ɵngcc0.ɵɵelementEnd();\n        ɵngcc0.ɵɵnamespaceHTML();\n        ɵngcc0.ɵɵelement(5, \"div\", 5);\n        ɵngcc0.ɵɵelementEnd();\n        ɵngcc0.ɵɵtemplate(6, MdcCheckbox_div_6_Template, 1, 0, \"div\", 6);\n      }\n\n      if (rf & 2) {\n        ɵngcc0.ɵɵproperty(\"id\", ctx.inputId)(\"tabIndex\", ctx.tabIndex)(\"disabled\", ctx.disabled)(\"checked\", ctx.checked)(\"indeterminate\", ctx.indeterminate);\n        ɵngcc0.ɵɵattribute(\"name\", ctx.name)(\"aria-label\", ctx.ariaLabel || null)(\"aria-labelledby\", ctx.ariaLabelledby)(\"value\", ctx.value);\n        ɵngcc0.ɵɵadvance(6);\n        ɵngcc0.ɵɵproperty(\"ngIf\", !ctx.disableRipple && !ctx.disabled);\n      }\n    },\n    directives: [ɵngcc4.NgIf],\n    encapsulation: 2,\n    changeDetection: 0\n  });\n  /** @nocollapse */\n\n  return MdcCheckbox;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n/**\n * @fileoverview added by tsickle\n * Generated from: checkbox/module.ts\n * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n\n\nlet MdcCheckboxModule = /*#__PURE__*/(() => {\n  class MdcCheckboxModule {}\n\n  MdcCheckboxModule.ɵfac = function MdcCheckboxModule_Factory(t) {\n    return new (t || MdcCheckboxModule)();\n  };\n\n  MdcCheckboxModule.ɵmod = /*@__PURE__*/ɵngcc0.ɵɵdefineNgModule({\n    type: MdcCheckboxModule\n  });\n  MdcCheckboxModule.ɵinj = /*@__PURE__*/ɵngcc0.ɵɵdefineInjector({\n    imports: [[CommonModule, MdcFormFieldModule], MdcFormFieldModule]\n  });\n  return MdcCheckboxModule;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\n(function () {\n  (typeof ngJitMode === \"undefined\" || ngJitMode) && ɵngcc0.ɵɵsetNgModuleScope(MdcCheckboxModule, {\n    declarations: function () {\n      return [MdcCheckbox];\n    },\n    imports: function () {\n      return [CommonModule, MdcFormFieldModule];\n    },\n    exports: function () {\n      return [MdcFormFieldModule, MdcCheckbox];\n    }\n  });\n})();\n\nexport { MDC_CHECKBOX_CONTROL_VALUE_ACCESSOR, MdcCheckbox, MdcCheckboxChange, MdcCheckboxModule }; //# sourceMappingURL=checkbox.js.map","map":null,"metadata":{},"sourceType":"module"}