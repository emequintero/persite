{"ast":null,"code":"/**\n * @license\n * Copyright (c) Dominic Carretto\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://github.com/trimox/angular-mdc-web/blob/master/LICENSE\n */\nimport { forwardRef, EventEmitter, Component, ChangeDetectionStrategy, ViewEncapsulation, NgZone, ChangeDetectorRef, ElementRef, Attribute, Input, Output, ViewChild, NgModule } from '@angular/core';\nimport { CommonModule } from '@angular/common';\nimport { __awaiter } from 'tslib';\nimport { NG_VALUE_ACCESSOR } from '@angular/forms';\nimport { coerceBooleanProperty, coerceNumberProperty } from '@angular/cdk/coercion';\nimport { Platform, supportsPassiveEventListeners } from '@angular/cdk/platform';\nimport { Subject, fromEvent } from 'rxjs';\nimport { auditTime, takeUntil } from 'rxjs/operators';\nimport { MDCComponent } from '@angular-mdc/web/base';\nimport { MDCSliderFoundation } from '@material/slider';\n/**\n * @fileoverview added by tsickle\n * Generated from: slider/slider.ts\n * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n\n/** @type {?} */\n\nimport * as ɵngcc0 from '@angular/core';\nimport * as ɵngcc1 from '@angular/cdk/platform';\nimport * as ɵngcc2 from '@angular/common';\nconst _c0 = [\"thumbcontainer\"];\nconst _c1 = [\"sliderThumb\"];\nconst _c2 = [\"track\"];\nconst _c3 = [\"pin\"];\nconst _c4 = [\"markercontainer\"];\n\nfunction MdcSlider_div_3_Template(rf, ctx) {\n  if (rf & 1) {\n    ɵngcc0.ɵɵelement(0, \"div\", 11, 12);\n  }\n}\n\nfunction MdcSlider_div_6_Template(rf, ctx) {\n  if (rf & 1) {\n    ɵngcc0.ɵɵelementStart(0, \"div\", 13);\n    ɵngcc0.ɵɵelement(1, \"span\", 14, 15);\n    ɵngcc0.ɵɵelementEnd();\n  }\n}\n\nconst MDC_SLIDER_CONTROL_VALUE_ACCESSOR = {\n  provide: NG_VALUE_ACCESSOR,\n  useExisting: forwardRef(\n  /**\n  * @return {?}\n  */\n  () => MdcSlider),\n  multi: true\n};\n\nclass MdcSliderChange {\n  /**\n   * @param {?} source\n   * @param {?} value\n   */\n  constructor(source, value) {\n    this.source = source;\n    this.value = value;\n  }\n\n}\n\nlet MdcSlider = /*#__PURE__*/(() => {\n  class MdcSlider extends MDCComponent {\n    /**\n     * @param {?} _platform\n     * @param {?} _ngZone\n     * @param {?} _changeDetectorRef\n     * @param {?} elementRef\n     * @param {?} tabIndex\n     */\n    constructor(_platform, _ngZone, _changeDetectorRef, elementRef, tabIndex) {\n      super(elementRef);\n      this._platform = _platform;\n      this._ngZone = _ngZone;\n      this._changeDetectorRef = _changeDetectorRef;\n      this.elementRef = elementRef;\n      /**\n       * Emits whenever the component is destroyed.\n       */\n\n      this._destroyed = new Subject();\n      this._initialized = false;\n      this.tabIndex = 0;\n      this._discrete = false;\n      this._markers = false;\n      this._min = 0;\n      this._max = 100;\n      this._step = 1;\n      this._value = null;\n      this._disabled = false;\n      this.change = new EventEmitter();\n      this.input = new EventEmitter();\n      /**\n       * Emits when the raw value of the slider changes. This is here primarily\n       * to facilitate the two-way binding for the `value` input.\n       */\n\n      this.valueChange = new EventEmitter();\n      /**\n       * Function when touched\n       */\n\n      this._onTouched =\n      /**\n      * @return {?}\n      */\n      () => {};\n      /**\n       * Function when changed\n       */\n\n\n      this._controlValueAccessorChangeFn =\n      /**\n      * @return {?}\n      */\n      () => {};\n\n      this.tabIndex = parseInt(tabIndex, 10) || 0;\n      this._root = this.elementRef.nativeElement;\n    }\n    /**\n     * @return {?}\n     */\n\n\n    get discrete() {\n      return this._discrete;\n    }\n    /**\n     * @param {?} value\n     * @return {?}\n     */\n\n\n    set discrete(value) {\n      this._discrete = coerceBooleanProperty(value);\n    }\n    /**\n     * @return {?}\n     */\n\n\n    get markers() {\n      return this._markers;\n    }\n    /**\n     * @param {?} value\n     * @return {?}\n     */\n\n\n    set markers(value) {\n      this._markers = coerceBooleanProperty(value);\n    }\n    /**\n     * @return {?}\n     */\n\n\n    get min() {\n      return this._min;\n    }\n    /**\n     * @param {?} value\n     * @return {?}\n     */\n\n\n    set min(value) {\n      /** @type {?} */\n      const min = coerceNumberProperty(value);\n\n      if (min !== this._min) {\n        this._min = min;\n      }\n    }\n    /**\n     * @return {?}\n     */\n\n\n    get max() {\n      return this._max;\n    }\n    /**\n     * @param {?} value\n     * @return {?}\n     */\n\n\n    set max(value) {\n      /** @type {?} */\n      const max = coerceNumberProperty(value);\n\n      if (max !== this._max) {\n        this._max = max;\n      }\n    }\n    /**\n     * @return {?}\n     */\n\n\n    get step() {\n      return this._step;\n    }\n    /**\n     * @param {?} value\n     * @return {?}\n     */\n\n\n    set step(value) {\n      /** @type {?} */\n      const step = coerceNumberProperty(value, this._step);\n\n      if (step !== this._step) {\n        this._step = step;\n      }\n    }\n    /**\n     * @return {?}\n     */\n\n\n    get value() {\n      if (this._value === null) {\n        this.value = this.min;\n      }\n\n      return this._value;\n    }\n    /**\n     * @param {?} newValue\n     * @return {?}\n     */\n\n\n    set value(newValue) {\n      this._value = coerceNumberProperty(newValue, null);\n    }\n    /**\n     * @return {?}\n     */\n\n\n    get disabled() {\n      return this._disabled;\n    }\n    /**\n     * @param {?} value\n     * @return {?}\n     */\n\n\n    set disabled(value) {\n      this.setDisabledState(value);\n    }\n    /**\n     * @return {?}\n     */\n\n\n    getDefaultFoundation() {\n      /** @type {?} */\n      const adapter = {\n        hasClass:\n        /**\n        * @param {?} className\n        * @return {?}\n        */\n        className => this._root.classList.contains(className),\n        addClass:\n        /**\n        * @param {?} className\n        * @return {?}\n        */\n        className => this._root.classList.add(className),\n        removeClass:\n        /**\n        * @param {?} className\n        * @return {?}\n        */\n        className => this._root.classList.remove(className),\n        getAttribute:\n        /**\n        * @param {?} name\n        * @return {?}\n        */\n        name => this._root.getAttribute(name),\n        setAttribute:\n        /**\n        * @param {?} name\n        * @param {?} value\n        * @return {?}\n        */\n        (name, value) => this._root.setAttribute(name, value),\n        removeAttribute:\n        /**\n        * @param {?} name\n        * @return {?}\n        */\n        name => this._root.removeAttribute(name),\n        computeBoundingRect:\n        /**\n        * @return {?}\n        */\n        () => this._root.getBoundingClientRect(),\n        getTabIndex:\n        /**\n        * @return {?}\n        */\n        () =>\n        /** @type {?} */\n        this._root.tabIndex,\n        registerInteractionHandler:\n        /**\n        * @template K\n        * @param {?} evtType\n        * @param {?} handler\n        * @return {?}\n        */\n        (evtType, handler) =>\n        /** @type {?} */\n        this._root.addEventListener(evtType, handler),\n        deregisterInteractionHandler:\n        /**\n        * @template K\n        * @param {?} evtType\n        * @param {?} handler\n        * @return {?}\n        */\n        (evtType, handler) =>\n        /** @type {?} */\n        this._root.removeEventListener(evtType, handler),\n        registerThumbContainerInteractionHandler:\n        /**\n        * @template K\n        * @param {?} evtType\n        * @param {?} handler\n        * @return {?}\n        */\n        (evtType, handler) => {\n          this._ngZone.runOutsideAngular(\n          /**\n          * @return {?}\n          */\n          () => {\n            this.thumbContainer.nativeElement.addEventListener(evtType, handler, supportsPassiveEventListeners());\n          });\n        },\n        deregisterThumbContainerInteractionHandler:\n        /**\n        * @template K\n        * @param {?} evtType\n        * @param {?} handler\n        * @return {?}\n        */\n        (evtType, handler) => this.thumbContainer.nativeElement.removeEventListener(evtType, handler, supportsPassiveEventListeners()),\n        registerBodyInteractionHandler:\n        /**\n        * @template K\n        * @param {?} evtType\n        * @param {?} handler\n        * @return {?}\n        */\n        (evtType, handler) => document.body.addEventListener(evtType, handler),\n        deregisterBodyInteractionHandler:\n        /**\n        * @template K\n        * @param {?} evtType\n        * @param {?} handler\n        * @return {?}\n        */\n        (evtType, handler) => document.body.removeEventListener(evtType, handler),\n        registerResizeHandler:\n        /**\n        * @return {?}\n        */\n        () => {},\n        deregisterResizeHandler:\n        /**\n        * @return {?}\n        */\n        () => {},\n        notifyInput:\n        /**\n        * @return {?}\n        */\n        () => {\n          /** @type {?} */\n          const newValue = this._foundation.getValue();\n\n          if (newValue !== this.value) {\n            this.value = newValue;\n            this.input.emit(this._createChangeEvent(newValue));\n          }\n        },\n        notifyChange:\n        /**\n        * @return {?}\n        */\n        () => {\n          this.value = this._foundation.getValue();\n\n          this._emitChangeEvent(\n          /** @type {?} */\n          this.value);\n        },\n        setThumbContainerStyleProperty:\n        /**\n        * @param {?} propertyName\n        * @param {?} value\n        * @return {?}\n        */\n        (propertyName, value) => this.thumbContainer.nativeElement.style.setProperty(propertyName, value),\n        setTrackStyleProperty:\n        /**\n        * @param {?} propertyName\n        * @param {?} value\n        * @return {?}\n        */\n        (propertyName, value) => this.track.nativeElement.style.setProperty(propertyName, value),\n        setMarkerValue:\n        /**\n        * @param {?} value\n        * @return {?}\n        */\n        value => {\n          this._changeDetectorRef.markForCheck();\n\n          /** @type {?} */\n          this.pinValueMarker.nativeElement.innerText = value !== null ? value.toString() : null;\n        },\n        setTrackMarkers:\n        /**\n        * @param {?} step\n        * @param {?} max\n        * @param {?} min\n        * @return {?}\n        */\n        (step, max, min) =>\n        /** @type {?} */\n        this.trackMarkerContainer.nativeElement.style.setProperty('background', this._getTrackMarkersBackground(step, min, max)),\n        isRTL:\n        /**\n        * @return {?}\n        */\n        () => this._platform.isBrowser ? window.getComputedStyle(this._root).getPropertyValue('direction') === 'rtl' : false\n      };\n      return new MDCSliderFoundation(adapter);\n    }\n    /**\n     * @param {?} changes\n     * @return {?}\n     */\n\n\n    ngOnChanges(changes) {\n      if (!this._initialized) {\n        return;\n      }\n\n      if (changes['step']) {\n        this._syncStepWithFoundation();\n      }\n\n      if (changes['max']) {\n        this._syncMaxWithFoundation();\n      }\n\n      if (changes['min']) {\n        this._syncMinWithFoundation();\n      }\n\n      if (changes['value']) {\n        this._syncValueWithFoundation();\n      }\n\n      if (changes['markers'] || changes['discrete']) {\n        this._refreshTrackMarkers();\n      }\n    }\n    /**\n     * @return {?}\n     */\n\n\n    _asyncInitializeFoundation() {\n      return __awaiter(this, void 0, void 0, function* () {\n        this._foundation.init();\n      });\n    }\n    /**\n     * @return {?}\n     */\n\n\n    ngAfterViewInit() {\n      if (this._platform.isBrowser) {\n        this._initialized = true;\n\n        this._asyncInitializeFoundation().then(\n        /**\n        * @return {?}\n        */\n        () => {\n          this._syncStepWithFoundation();\n\n          this._syncMaxWithFoundation();\n\n          this._syncMinWithFoundation();\n\n          this._syncValueWithFoundation();\n\n          this._foundation.setupTrackMarker();\n\n          this._loadListeners();\n\n          this._changeDetectorRef.markForCheck();\n        });\n      }\n    }\n    /**\n     * @return {?}\n     */\n\n\n    ngOnDestroy() {\n      this._destroyed.next();\n\n      this._destroyed.complete();\n\n      this.destroy();\n    }\n    /**\n     * @param {?} value\n     * @return {?}\n     */\n\n\n    writeValue(value) {\n      this.value = value;\n\n      this._syncValueWithFoundation();\n    }\n    /**\n     * @param {?} fn\n     * @return {?}\n     */\n\n\n    registerOnChange(fn) {\n      this._controlValueAccessorChangeFn = fn;\n    }\n    /**\n     * @param {?} fn\n     * @return {?}\n     */\n\n\n    registerOnTouched(fn) {\n      this._onTouched = fn;\n    }\n    /**\n     * @param {?} disabled\n     * @return {?}\n     */\n\n\n    setDisabledState(disabled) {\n      this._disabled = coerceBooleanProperty(disabled);\n\n      this._foundation.setDisabled(disabled);\n\n      this._changeDetectorRef.markForCheck();\n    }\n    /**\n     * @return {?}\n     */\n\n\n    layout() {\n      this._foundation.layout();\n    }\n    /**\n     * @private\n     * @return {?}\n     */\n\n\n    _loadListeners() {\n      this._ngZone.runOutsideAngular(\n      /**\n      * @return {?}\n      */\n      () => fromEvent(window, 'resize').pipe(auditTime(16), takeUntil(this._destroyed)).subscribe(\n      /**\n      * @return {?}\n      */\n      () => this.layout()));\n    }\n    /**\n     * @private\n     * @return {?}\n     */\n\n\n    _syncValueWithFoundation() {\n      this._foundation.setValue(\n      /** @type {?} */\n      this.value);\n    }\n    /**\n     * @private\n     * @return {?}\n     */\n\n\n    _syncStepWithFoundation() {\n      this._foundation.setStep(this.step);\n    }\n    /**\n     * @private\n     * @return {?}\n     */\n\n\n    _syncMinWithFoundation() {\n      this._foundation.setMin(this.min);\n    }\n    /**\n     * @private\n     * @return {?}\n     */\n\n\n    _syncMaxWithFoundation() {\n      this._foundation.setMax(this.max);\n    }\n    /**\n     * @private\n     * @param {?} newValue\n     * @return {?}\n     */\n\n\n    _createChangeEvent(newValue) {\n      return new MdcSliderChange(this, newValue);\n    }\n    /**\n     * @private\n     * @param {?} newValue\n     * @return {?}\n     */\n\n\n    _emitChangeEvent(newValue) {\n      this._controlValueAccessorChangeFn(newValue);\n\n      this.valueChange.emit(newValue);\n      this.change.emit(this._createChangeEvent(newValue));\n    }\n    /**\n     * Keep calculation in css for better rounding/subpixel behavior.\n     * @private\n     * @param {?} step\n     * @param {?} min\n     * @param {?} max\n     * @return {?}\n     */\n\n\n    _getTrackMarkersBackground(step, min, max) {\n      /** @type {?} */\n      const stepStr = step.toLocaleString();\n      /** @type {?} */\n\n      const maxStr = max.toLocaleString();\n      /** @type {?} */\n\n      const minStr = min.toLocaleString();\n      /** @type {?} */\n\n      const markerAmount = `((${maxStr} - ${minStr}) / ${stepStr})`;\n      /** @type {?} */\n\n      const markerWidth = `2px`;\n      /** @type {?} */\n\n      const markerBkgdImage = `linear-gradient(to right, currentColor ${markerWidth}, transparent 0)`;\n      /** @type {?} */\n\n      const markerBkgdLayout = `0 center / calc((100% - ${markerWidth}) / ${markerAmount}) 100% repeat-x`;\n      return `${markerBkgdImage} ${markerBkgdLayout}`;\n    }\n    /**\n     * Method that ensures that track markers are refreshed.\n     * @private\n     * @return {?}\n     */\n\n\n    _refreshTrackMarkers() {\n      /** @type {?} */\n      this._foundation.hasTrackMarker_ = this.markers;\n\n      this._foundation.setupTrackMarker();\n    }\n\n  }\n\n  MdcSlider.ɵfac = function MdcSlider_Factory(t) {\n    return new (t || MdcSlider)(ɵngcc0.ɵɵdirectiveInject(ɵngcc1.Platform), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.NgZone), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ChangeDetectorRef), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef), ɵngcc0.ɵɵinjectAttribute('tabindex'));\n  };\n\n  MdcSlider.ɵcmp = /*@__PURE__*/ɵngcc0.ɵɵdefineComponent({\n    type: MdcSlider,\n    selectors: [[\"mdc-slider\"]],\n    viewQuery: function MdcSlider_Query(rf, ctx) {\n      if (rf & 1) {\n        ɵngcc0.ɵɵviewQuery(_c0, 5);\n        ɵngcc0.ɵɵviewQuery(_c1, 5);\n        ɵngcc0.ɵɵviewQuery(_c2, 5);\n        ɵngcc0.ɵɵviewQuery(_c3, 5);\n        ɵngcc0.ɵɵviewQuery(_c4, 5);\n      }\n\n      if (rf & 2) {\n        let _t;\n\n        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.thumbContainer = _t.first);\n        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx._sliderThumb = _t.first);\n        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.track = _t.first);\n        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.pinValueMarker = _t.first);\n        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.trackMarkerContainer = _t.first);\n      }\n    },\n    hostAttrs: [\"role\", \"slider\", \"aria-orientation\", \"horizontal\", 1, \"mdc-slider\"],\n    hostVars: 5,\n    hostBindings: function MdcSlider_HostBindings(rf, ctx) {\n      if (rf & 1) {\n        ɵngcc0.ɵɵlistener(\"blur\", function MdcSlider_blur_HostBindingHandler() {\n          return ctx._onTouched();\n        });\n      }\n\n      if (rf & 2) {\n        ɵngcc0.ɵɵattribute(\"tabindex\", ctx.tabIndex || 0);\n        ɵngcc0.ɵɵclassProp(\"mdc-slider--discrete\", ctx.discrete)(\"mdc-slider--display-markers\", ctx.markers && ctx.discrete);\n      }\n    },\n    inputs: {\n      tabIndex: \"tabIndex\",\n      discrete: \"discrete\",\n      markers: \"markers\",\n      min: \"min\",\n      max: \"max\",\n      step: \"step\",\n      value: \"value\",\n      disabled: \"disabled\"\n    },\n    outputs: {\n      change: \"change\",\n      input: \"input\",\n      valueChange: \"valueChange\"\n    },\n    exportAs: [\"mdcSlider\"],\n    features: [ɵngcc0.ɵɵProvidersFeature([MDC_SLIDER_CONTROL_VALUE_ACCESSOR]), ɵngcc0.ɵɵInheritDefinitionFeature, ɵngcc0.ɵɵNgOnChangesFeature],\n    decls: 11,\n    vars: 2,\n    consts: [[1, \"mdc-slider__track-container\"], [1, \"mdc-slider__track\"], [\"track\", \"\"], [\"class\", \"mdc-slider__track-marker-container\", 4, \"ngIf\"], [1, \"mdc-slider__thumb-container\"], [\"thumbcontainer\", \"\"], [\"class\", \"mdc-slider__pin\", 4, \"ngIf\"], [\"width\", \"21\", \"height\", \"21\", \"focusable\", \"false\", 1, \"mdc-slider__thumb\"], [\"sliderThumb\", \"\"], [\"cx\", \"10.5\", \"cy\", \"10.5\", \"r\", \"7.875\"], [1, \"mdc-slider__focus-ring\"], [1, \"mdc-slider__track-marker-container\"], [\"markercontainer\", \"\"], [1, \"mdc-slider__pin\"], [1, \"mdc-slider__pin-value-marker\"], [\"pin\", \"\"]],\n    template: function MdcSlider_Template(rf, ctx) {\n      if (rf & 1) {\n        ɵngcc0.ɵɵelementStart(0, \"div\", 0);\n        ɵngcc0.ɵɵelement(1, \"div\", 1, 2);\n        ɵngcc0.ɵɵtemplate(3, MdcSlider_div_3_Template, 2, 0, \"div\", 3);\n        ɵngcc0.ɵɵelementEnd();\n        ɵngcc0.ɵɵelementStart(4, \"div\", 4, 5);\n        ɵngcc0.ɵɵtemplate(6, MdcSlider_div_6_Template, 3, 0, \"div\", 6);\n        ɵngcc0.ɵɵnamespaceSVG();\n        ɵngcc0.ɵɵelementStart(7, \"svg\", 7, 8);\n        ɵngcc0.ɵɵelement(9, \"circle\", 9);\n        ɵngcc0.ɵɵelementEnd();\n        ɵngcc0.ɵɵnamespaceHTML();\n        ɵngcc0.ɵɵelement(10, \"div\", 10);\n        ɵngcc0.ɵɵelementEnd();\n      }\n\n      if (rf & 2) {\n        ɵngcc0.ɵɵadvance(3);\n        ɵngcc0.ɵɵproperty(\"ngIf\", ctx.markers);\n        ɵngcc0.ɵɵadvance(3);\n        ɵngcc0.ɵɵproperty(\"ngIf\", ctx.discrete);\n      }\n    },\n    directives: [ɵngcc2.NgIf],\n    encapsulation: 2,\n    changeDetection: 0\n  });\n  /** @nocollapse */\n\n  return MdcSlider;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n/**\n * @fileoverview added by tsickle\n * Generated from: slider/module.ts\n * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n\n\nlet MdcSliderModule = /*#__PURE__*/(() => {\n  class MdcSliderModule {}\n\n  MdcSliderModule.ɵfac = function MdcSliderModule_Factory(t) {\n    return new (t || MdcSliderModule)();\n  };\n\n  MdcSliderModule.ɵmod = /*@__PURE__*/ɵngcc0.ɵɵdefineNgModule({\n    type: MdcSliderModule\n  });\n  MdcSliderModule.ɵinj = /*@__PURE__*/ɵngcc0.ɵɵdefineInjector({\n    imports: [[CommonModule]]\n  });\n  return MdcSliderModule;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\n(function () {\n  (typeof ngJitMode === \"undefined\" || ngJitMode) && ɵngcc0.ɵɵsetNgModuleScope(MdcSliderModule, {\n    declarations: function () {\n      return [MdcSlider];\n    },\n    imports: function () {\n      return [CommonModule];\n    },\n    exports: function () {\n      return [MdcSlider];\n    }\n  });\n})();\n\nexport { MDC_SLIDER_CONTROL_VALUE_ACCESSOR, MdcSlider, MdcSliderChange, MdcSliderModule }; //# sourceMappingURL=slider.js.map","map":null,"metadata":{},"sourceType":"module"}