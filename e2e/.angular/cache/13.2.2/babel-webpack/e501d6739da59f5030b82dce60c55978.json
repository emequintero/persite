{"ast":null,"code":"/**\n * @license\n * Copyright (c) Dominic Carretto\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://github.com/trimox/angular-mdc-web/blob/master/LICENSE\n */\nimport { EventEmitter, Component, ChangeDetectionStrategy, ViewEncapsulation, ChangeDetectorRef, ElementRef, Input, Output, ContentChild, ContentChildren, NgModule } from '@angular/core';\nimport { MdcTabIndicatorModule } from '@angular-mdc/web/tab-indicator';\nimport { MDC_TAB_BAR_PARENT_COMPONENT, MdcTab, MdcTabModule } from '@angular-mdc/web/tab';\nimport { MdcTabScroller, MdcTabScrollerModule } from '@angular-mdc/web/tab-scroller';\nimport { coerceBooleanProperty } from '@angular/cdk/coercion';\nimport { Platform } from '@angular/cdk/platform';\nimport { Subject, merge } from 'rxjs';\nimport { startWith } from 'rxjs/operators';\nimport { MDCComponent } from '@angular-mdc/web/base';\nimport { MDCTabBarFoundation } from '@material/tab-bar';\n/**\n * @fileoverview added by tsickle\n * Generated from: tab-bar/tab-bar.ts\n * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n\nimport * as ɵngcc0 from '@angular/core';\nimport * as ɵngcc1 from '@angular/cdk/platform';\nconst _c0 = [\"mdcTabBar\", \"\"];\nconst _c1 = [\"*\"];\n\nclass MdcTabActivatedEvent {\n  /**\n   * @param {?} source\n   * @param {?} index\n   * @param {?} tab\n   */\n  constructor(source, index, tab) {\n    this.source = source;\n    this.index = index;\n    this.tab = tab;\n  }\n\n}\n\nlet MdcTabBar = /*#__PURE__*/(() => {\n  class MdcTabBar extends MDCComponent {\n    /**\n     * @param {?} _platform\n     * @param {?} _changeDetectorRef\n     * @param {?} elementRef\n     */\n    constructor(_platform, _changeDetectorRef, elementRef) {\n      super(elementRef);\n      this._platform = _platform;\n      this._changeDetectorRef = _changeDetectorRef;\n      this.elementRef = elementRef;\n      /**\n       * Emits whenever the component is destroyed.\n       */\n\n      this._destroy = new Subject();\n      this._fade = false;\n      this._stacked = false;\n      this._fixed = false;\n      this._align = null;\n      this._iconIndicator = null;\n      this._useAutomaticActivation = true;\n      this._activeTabIndex = 0;\n      this._focusOnActivate = true;\n      this.activated = new EventEmitter();\n      /**\n       * Subscription to changes in tabs.\n       */\n\n      this._changeSubscription = null;\n      /**\n       * Subscription to interaction events in tabs.\n       */\n\n      this._tabInteractionSubscription = null;\n    }\n    /**\n     * @return {?}\n     */\n\n\n    get fade() {\n      return this._fade;\n    }\n    /**\n     * @param {?} value\n     * @return {?}\n     */\n\n\n    set fade(value) {\n      this._fade = coerceBooleanProperty(value);\n\n      this._syncTabs();\n    }\n    /**\n     * @return {?}\n     */\n\n\n    get stacked() {\n      return this._stacked;\n    }\n    /**\n     * @param {?} value\n     * @return {?}\n     */\n\n\n    set stacked(value) {\n      this._stacked = coerceBooleanProperty(value);\n\n      this._syncTabs();\n    }\n    /**\n     * @return {?}\n     */\n\n\n    get fixed() {\n      return this._fixed;\n    }\n    /**\n     * @param {?} value\n     * @return {?}\n     */\n\n\n    set fixed(value) {\n      this._fixed = coerceBooleanProperty(value);\n\n      this._syncTabs();\n    }\n    /**\n     * @return {?}\n     */\n\n\n    get align() {\n      return this._align;\n    }\n    /**\n     * @param {?} value\n     * @return {?}\n     */\n\n\n    set align(value) {\n      this._align = value || 'start';\n      this.tabScroller.align = this.align;\n    }\n    /**\n     * @return {?}\n     */\n\n\n    get iconIndicator() {\n      return this._iconIndicator;\n    }\n    /**\n     * @param {?} value\n     * @return {?}\n     */\n\n\n    set iconIndicator(value) {\n      this._iconIndicator = value;\n\n      this._syncTabs();\n    }\n    /**\n     * @return {?}\n     */\n\n\n    get useAutomaticActivation() {\n      return this._useAutomaticActivation;\n    }\n    /**\n     * @param {?} value\n     * @return {?}\n     */\n\n\n    set useAutomaticActivation(value) {\n      this._useAutomaticActivation = coerceBooleanProperty(value);\n\n      this._foundation.setUseAutomaticActivation(this._useAutomaticActivation);\n    }\n    /**\n     * @return {?}\n     */\n\n\n    get activeTabIndex() {\n      return this._activeTabIndex;\n    }\n    /**\n     * @param {?} value\n     * @return {?}\n     */\n\n\n    set activeTabIndex(value) {\n      if (this.activeTabIndex !== value) {\n        this._activeTabIndex = value;\n        this.activateTab(this.activeTabIndex);\n      }\n    }\n    /**\n     * @return {?}\n     */\n\n\n    get focusOnActivate() {\n      return this._focusOnActivate;\n    }\n    /**\n     * @param {?} value\n     * @return {?}\n     */\n\n\n    set focusOnActivate(value) {\n      this._focusOnActivate = coerceBooleanProperty(value);\n\n      this._syncTabs();\n    }\n    /**\n     * Combined stream of all of the tab interaction events.\n     * @return {?}\n     */\n\n\n    get tabInteractions() {\n      return merge(...this.tabs.map(\n      /**\n      * @param {?} tab\n      * @return {?}\n      */\n      tab => tab.interacted));\n    }\n    /**\n     * @return {?}\n     */\n\n\n    getDefaultFoundation() {\n      /** @type {?} */\n      const adapter = {\n        scrollTo:\n        /**\n        * @param {?} scrollX\n        * @return {?}\n        */\n        scrollX => this.tabScroller.scrollTo(scrollX),\n        incrementScroll:\n        /**\n        * @param {?} scrollXIncrement\n        * @return {?}\n        */\n        scrollXIncrement => this.tabScroller.incrementScroll(scrollXIncrement),\n        getScrollPosition:\n        /**\n        * @return {?}\n        */\n        () => this.tabScroller.getScrollPosition(),\n        getScrollContentWidth:\n        /**\n        * @return {?}\n        */\n        () => this.tabScroller.getScrollContentWidth(),\n        getOffsetWidth:\n        /**\n        * @return {?}\n        */\n        () => this._getHostElement().offsetWidth,\n        isRTL:\n        /**\n        * @return {?}\n        */\n        () => this._platform.isBrowser ? window.getComputedStyle(this._getHostElement()).getPropertyValue('direction') === 'rtl' : false,\n        setActiveTab:\n        /**\n        * @param {?} index\n        * @return {?}\n        */\n        index => this.activateTab(index),\n        activateTabAtIndex:\n        /**\n        * @param {?} index\n        * @param {?=} clientRect\n        * @return {?}\n        */\n        (index, clientRect) => {\n          if (this._indexIsInRange(index)) {\n            this.tabs.toArray()[index].activate(clientRect);\n          }\n        },\n        deactivateTabAtIndex:\n        /**\n        * @param {?} index\n        * @return {?}\n        */\n        index => {\n          if (this._indexIsInRange(index)) {\n            this.tabs.toArray()[index].deactivate();\n          }\n        },\n        focusTabAtIndex:\n        /**\n        * @param {?} index\n        * @return {?}\n        */\n        index => this.tabs.toArray()[index].focus(),\n        getTabIndicatorClientRectAtIndex:\n        /**\n        * @param {?} previousActiveIndex\n        * @return {?}\n        */\n        previousActiveIndex => {\n          if (!this._platform.isBrowser) {\n            return {\n              height: 0,\n              width: 0,\n              bottom: 0,\n              top: 0,\n              left: 0,\n              right: 0\n            };\n          }\n\n          if (!this._indexIsInRange(previousActiveIndex)) {\n            previousActiveIndex = this.activeTabIndex;\n          }\n\n          return this.tabs.toArray()[previousActiveIndex].computeIndicatorClientRect();\n        },\n        getTabDimensionsAtIndex:\n        /**\n        * @param {?} index\n        * @return {?}\n        */\n        index => this.tabs.toArray()[index].computeDimensions(),\n        getPreviousActiveTabIndex:\n        /**\n        * @return {?}\n        */\n        () => this.tabs.toArray().findIndex(\n        /**\n        * @param {?} _\n        * @return {?}\n        */\n        _ => _.active),\n        getFocusedTabIndex:\n        /**\n        * @return {?}\n        */\n        () => this._platform.isBrowser ? this.tabs.toArray().findIndex(\n        /**\n        * @param {?} tab\n        * @return {?}\n        */\n        tab => tab.elementRef.nativeElement ===\n        /** @type {?} */\n        document.activeElement) : -1,\n        getIndexOfTabById:\n        /**\n        * @param {?} id\n        * @return {?}\n        */\n        id => this.tabs.toArray().findIndex(\n        /**\n        * @param {?} tab\n        * @return {?}\n        */\n        tab => id === tab.id),\n        getTabListLength:\n        /**\n        * @return {?}\n        */\n        () => this.tabs.length,\n        notifyTabActivated:\n        /**\n        * @param {?} index\n        * @return {?}\n        */\n        index => this.activated.emit({\n          source: this,\n          index: index,\n          tab: this.tabs.toArray()[index]\n        })\n      };\n      return new MDCTabBarFoundation(adapter);\n    }\n    /**\n     * @return {?}\n     */\n\n\n    ngAfterContentInit() {\n      this._foundation.init(); // When the list changes, re-subscribe\n\n\n      this._changeSubscription = this.tabs.changes.pipe(startWith(null)).subscribe(\n      /**\n      * @return {?}\n      */\n      () => {\n        Promise.resolve().then(\n        /**\n        * @return {?}\n        */\n        () => {\n          if (this.tabs.length) {\n            this._syncTabs();\n\n            this.activateTab(this.activeTabIndex);\n\n            this._resetTabSubscriptions();\n          }\n        });\n      });\n    }\n    /**\n     * @return {?}\n     */\n\n\n    ngOnDestroy() {\n      this._destroy.next();\n\n      this._destroy.complete();\n\n      if (this._changeSubscription) {\n        this._changeSubscription.unsubscribe();\n      }\n\n      this._dropSubscriptions();\n    }\n    /**\n     * @private\n     * @return {?}\n     */\n\n\n    _syncTabs() {\n      if (!this.tabs) {\n        return;\n      }\n\n      this.tabs.forEach(\n      /**\n      * @param {?} tab\n      * @return {?}\n      */\n      tab => {\n        tab.stacked = this._stacked;\n        tab.fixed = this._fixed;\n        tab.tabIndicator.fade = this._fade;\n        tab.tabIndicator.icon = this._iconIndicator;\n        tab.focusOnActivate = this._focusOnActivate;\n      });\n    }\n    /**\n     * @private\n     * @return {?}\n     */\n\n\n    _resetTabSubscriptions() {\n      this._dropSubscriptions();\n\n      this._listenToTabInteraction();\n    }\n    /**\n     * @private\n     * @return {?}\n     */\n\n\n    _dropSubscriptions() {\n      if (this._tabInteractionSubscription) {\n        this._tabInteractionSubscription.unsubscribe();\n\n        this._tabInteractionSubscription = null;\n      }\n    }\n    /**\n     * Listens to interaction events on each tab.\n     * @private\n     * @return {?}\n     */\n\n\n    _listenToTabInteraction() {\n      this._tabInteractionSubscription = this.tabInteractions.subscribe(\n      /**\n      * @param {?} event\n      * @return {?}\n      */\n      event => {\n        /** @type {?} */\n        const previousTab = this.getActiveTab();\n\n        if (previousTab) {\n          previousTab.tabIndicator.active = false;\n        }\n\n        event.detail.tab.tabIndicator.active = true;\n\n        this._foundation.handleTabInteraction(\n        /** @type {?} */\n        event);\n      });\n    }\n    /**\n     * Activates the tab at the given index\n     * @param {?} index\n     * @return {?}\n     */\n\n\n    activateTab(index) {\n      if (!this.tabs) {\n        return;\n      }\n\n      this.activeTabIndex = index;\n\n      if (this._platform.isBrowser) {\n        this._foundation.activateTab(index);\n      }\n\n      this._changeDetectorRef.markForCheck();\n    }\n    /**\n     * Scrolls the tab at the given index into view\n     * @param {?} index\n     * @return {?}\n     */\n\n\n    scrollIntoView(index) {\n      this._foundation.scrollIntoView(index);\n    }\n    /**\n     * @return {?}\n     */\n\n\n    getActiveTabIndex() {\n      return this.tabs.toArray().findIndex(\n      /**\n      * @param {?} _\n      * @return {?}\n      */\n      _ => _.active);\n    }\n    /**\n     * @return {?}\n     */\n\n\n    getActiveTab() {\n      return this.tabs.toArray().find(\n      /**\n      * @param {?} _\n      * @return {?}\n      */\n      _ => _.active);\n    }\n    /**\n     * Returns an index for given tab\n     * @param {?} tab\n     * @return {?}\n     */\n\n\n    getTabIndex(tab) {\n      return this.tabs.toArray().indexOf(tab);\n    }\n    /**\n     * Disable or enable the tab at the given index\n     * @param {?} index\n     * @param {?} disabled\n     * @return {?}\n     */\n\n\n    disableTab(index, disabled) {\n      if (!this.tabs) {\n        return;\n      }\n\n      this.tabs.toArray()[index].disabled = coerceBooleanProperty(disabled);\n    }\n    /**\n     * @param {?} evt\n     * @return {?}\n     */\n\n\n    _onKeydown(evt) {\n      this._foundation.handleKeyDown(evt);\n    }\n    /**\n     * @private\n     * @param {?} index\n     * @return {?}\n     */\n\n\n    _indexIsInRange(index) {\n      return index >= 0 && index < this.tabs.length;\n    }\n    /**\n     * Retrieves the DOM element of the component host.\n     * @private\n     * @return {?}\n     */\n\n\n    _getHostElement() {\n      return this.elementRef.nativeElement;\n    }\n\n  }\n\n  MdcTabBar.ɵfac = function MdcTabBar_Factory(t) {\n    return new (t || MdcTabBar)(ɵngcc0.ɵɵdirectiveInject(ɵngcc1.Platform), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ChangeDetectorRef), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef));\n  };\n\n  MdcTabBar.ɵcmp = /*@__PURE__*/ɵngcc0.ɵɵdefineComponent({\n    type: MdcTabBar,\n    selectors: [[\"\", \"mdcTabBar\", \"\"], [\"mdc-tab-bar\"]],\n    contentQueries: function MdcTabBar_ContentQueries(rf, ctx, dirIndex) {\n      if (rf & 1) {\n        ɵngcc0.ɵɵcontentQuery(dirIndex, MdcTabScroller, 7);\n        ɵngcc0.ɵɵcontentQuery(dirIndex, MdcTab, 5);\n      }\n\n      if (rf & 2) {\n        let _t;\n\n        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.tabScroller = _t.first);\n        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.tabs = _t);\n      }\n    },\n    hostAttrs: [\"role\", \"tablist\", 1, \"mdc-tab-bar\"],\n    hostBindings: function MdcTabBar_HostBindings(rf, ctx) {\n      if (rf & 1) {\n        ɵngcc0.ɵɵlistener(\"keydown\", function MdcTabBar_keydown_HostBindingHandler($event) {\n          return ctx._onKeydown($event);\n        });\n      }\n    },\n    inputs: {\n      fade: \"fade\",\n      stacked: \"stacked\",\n      fixed: \"fixed\",\n      align: \"align\",\n      iconIndicator: \"iconIndicator\",\n      useAutomaticActivation: \"useAutomaticActivation\",\n      activeTabIndex: \"activeTabIndex\",\n      focusOnActivate: \"focusOnActivate\"\n    },\n    outputs: {\n      activated: \"activated\"\n    },\n    exportAs: [\"mdcTabBar\"],\n    features: [ɵngcc0.ɵɵProvidersFeature([{\n      provide: MDC_TAB_BAR_PARENT_COMPONENT,\n      useExisting: MdcTabBar\n    }]), ɵngcc0.ɵɵInheritDefinitionFeature],\n    attrs: _c0,\n    ngContentSelectors: _c1,\n    decls: 1,\n    vars: 0,\n    template: function MdcTabBar_Template(rf, ctx) {\n      if (rf & 1) {\n        ɵngcc0.ɵɵprojectionDef();\n        ɵngcc0.ɵɵprojection(0);\n      }\n    },\n    encapsulation: 2,\n    changeDetection: 0\n  });\n  /** @nocollapse */\n\n  return MdcTabBar;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n/**\n * @fileoverview added by tsickle\n * Generated from: tab-bar/module.ts\n * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n\n\nlet MdcTabBarModule = /*#__PURE__*/(() => {\n  class MdcTabBarModule {}\n\n  MdcTabBarModule.ɵfac = function MdcTabBarModule_Factory(t) {\n    return new (t || MdcTabBarModule)();\n  };\n\n  MdcTabBarModule.ɵmod = /*@__PURE__*/ɵngcc0.ɵɵdefineNgModule({\n    type: MdcTabBarModule\n  });\n  MdcTabBarModule.ɵinj = /*@__PURE__*/ɵngcc0.ɵɵdefineInjector({\n    imports: [[MdcTabIndicatorModule, MdcTabModule, MdcTabScrollerModule], MdcTabIndicatorModule, MdcTabModule, MdcTabScrollerModule]\n  });\n  return MdcTabBarModule;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\n(function () {\n  (typeof ngJitMode === \"undefined\" || ngJitMode) && ɵngcc0.ɵɵsetNgModuleScope(MdcTabBarModule, {\n    declarations: function () {\n      return [MdcTabBar];\n    },\n    imports: function () {\n      return [MdcTabIndicatorModule, MdcTabModule, MdcTabScrollerModule];\n    },\n    exports: function () {\n      return [MdcTabBar, MdcTabIndicatorModule, MdcTabModule, MdcTabScrollerModule];\n    }\n  });\n})();\n\nexport { MdcTabActivatedEvent, MdcTabBar, MdcTabBarModule }; //# sourceMappingURL=tab-bar.js.map","map":null,"metadata":{},"sourceType":"module"}