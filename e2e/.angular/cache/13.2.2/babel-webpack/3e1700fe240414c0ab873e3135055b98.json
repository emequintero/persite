{"ast":null,"code":"/**\n * @license\n * Copyright (c) Dominic Carretto\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://github.com/trimox/angular-mdc-web/blob/master/LICENSE\n */\nimport { EventEmitter, Directive, ChangeDetectorRef, NgZone, Optional, ElementRef, Input, Output, Component, ViewEncapsulation, ChangeDetectionStrategy, NgModule } from '@angular/core';\nimport { coerceBooleanProperty } from '@angular/cdk/coercion';\nimport { Platform } from '@angular/cdk/platform';\nimport { Subject, fromEvent } from 'rxjs';\nimport { takeUntil } from 'rxjs/operators';\nimport { MDCComponent } from '@angular-mdc/web/base';\nimport { Corner, MDCMenuSurfaceFoundation, util } from '@material/menu-surface';\n/**\n * @fileoverview added by tsickle\n * Generated from: menu-surface/menu-surface-base.ts\n * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n\n/** @type {?} */\n\nimport * as ɵngcc0 from '@angular/core';\nimport * as ɵngcc1 from '@angular/cdk/platform';\nconst _c0 = [\"*\"];\nconst ANCHOR_CORNER_MAP = {\n  topEnd: Corner.TOP_END,\n  topStart: Corner.TOP_START,\n  bottomEnd: Corner.BOTTOM_END,\n  bottomStart: Corner.BOTTOM_START\n};\n/**\n * @abstract\n */\n\nlet MdcMenuSurfaceBase = /*#__PURE__*/(() => {\n  class MdcMenuSurfaceBase extends MDCComponent {\n    /**\n     * @param {?} changeDetectorRef\n     * @param {?} platform\n     * @param {?} _ngZone\n     * @param {?} elementRef\n     */\n    constructor(changeDetectorRef, platform, _ngZone, elementRef) {\n      super(elementRef);\n      this.changeDetectorRef = changeDetectorRef;\n      this.platform = platform;\n      this._ngZone = _ngZone;\n      this.elementRef = elementRef;\n      /**\n       * Emits whenever the component is destroyed.\n       */\n\n      this._destroy = new Subject();\n      this._open = false;\n      this._anchorCorner = 'topStart';\n      this._quickOpen = false;\n      this._fixed = false;\n      this._coordinates = {\n        x: 0,\n        y: 0\n      };\n      this._anchorMargin = {};\n      this._hoistToBody = false;\n      /**\n       * Emits an event whenever the menu surface is opened.\n       */\n\n      this.opened = new EventEmitter();\n      /**\n       * Emits an event whenever the menu surface is closed.\n       */\n\n      this.closed = new EventEmitter();\n      /**\n       * Subscription to interaction events in menu-surface.\n       */\n\n      this._windowClickSubscription = null;\n    }\n    /**\n     * @return {?}\n     */\n\n\n    get open() {\n      return this._open;\n    }\n    /**\n     * @param {?} value\n     * @return {?}\n     */\n\n\n    set open(value) {\n      /** @type {?} */\n      const newValue = coerceBooleanProperty(value);\n\n      if (newValue !== this._open) {\n        this._open = coerceBooleanProperty(value);\n\n        if (this._open) {\n          this._foundation.open();\n        } else {\n          this._foundation.close();\n        }\n      }\n    }\n    /**\n     * @return {?}\n     */\n\n\n    get anchorElement() {\n      return this._anchorElement;\n    }\n    /**\n     * @param {?} element\n     * @return {?}\n     */\n\n\n    set anchorElement(element) {\n      this._anchorElement = element;\n    }\n    /**\n     * @return {?}\n     */\n\n\n    get anchorCorner() {\n      return this._anchorCorner;\n    }\n    /**\n     * @param {?} value\n     * @return {?}\n     */\n\n\n    set anchorCorner(value) {\n      this._anchorCorner = value !== null && value !== void 0 ? value : 'topStart';\n\n      this._foundation.setAnchorCorner(ANCHOR_CORNER_MAP[this._anchorCorner]);\n    }\n    /**\n     * @return {?}\n     */\n\n\n    get quickOpen() {\n      return this._quickOpen;\n    }\n    /**\n     * @param {?} value\n     * @return {?}\n     */\n\n\n    set quickOpen(value) {\n      this._quickOpen = coerceBooleanProperty(value);\n\n      this._foundation.setQuickOpen(this._quickOpen);\n    }\n    /**\n     * @return {?}\n     */\n\n\n    get fixed() {\n      return this._fixed;\n    }\n    /**\n     * @param {?} value\n     * @return {?}\n     */\n\n\n    set fixed(value) {\n      this._fixed = coerceBooleanProperty(value);\n\n      if (this._fixed) {\n        this._getHostElement().classList.add('mdc-menu-surface--fixed');\n      } else {\n        this._getHostElement().classList.remove('mdc-menu-surface--fixed');\n      }\n\n      this._foundation.setFixedPosition(this._fixed);\n    }\n    /**\n     * @return {?}\n     */\n\n\n    get coordinates() {\n      return this._coordinates;\n    }\n    /**\n     * @param {?} value\n     * @return {?}\n     */\n\n\n    set coordinates(value) {\n      this._coordinates = value;\n\n      this._foundation.setAbsolutePosition(value.x, value.y);\n    }\n    /**\n     * @return {?}\n     */\n\n\n    get anchorMargin() {\n      return this._anchorMargin;\n    }\n    /**\n     * @param {?} value\n     * @return {?}\n     */\n\n\n    set anchorMargin(value) {\n      this._anchorMargin = value;\n\n      this._foundation.setAnchorMargin(this._anchorMargin);\n    }\n    /**\n     * @return {?}\n     */\n\n\n    get hoistToBody() {\n      return this._hoistToBody;\n    }\n    /**\n     * @param {?} value\n     * @return {?}\n     */\n\n\n    set hoistToBody(value) {\n      this._hoistToBody = coerceBooleanProperty(value);\n\n      if (this._hoistToBody) {\n        this.setHoistToBody();\n      }\n    }\n    /**\n     * @return {?}\n     */\n\n\n    getDefaultFoundation() {\n      /** @type {?} */\n      const adapter = {\n        addClass:\n        /**\n        * @param {?} className\n        * @return {?}\n        */\n        className => this._getHostElement().classList.add(className),\n        removeClass:\n        /**\n        * @param {?} className\n        * @return {?}\n        */\n        className => this._getHostElement().classList.remove(className),\n        hasClass:\n        /**\n        * @param {?} className\n        * @return {?}\n        */\n        className => this._getHostElement().classList.contains(className),\n        hasAnchor:\n        /**\n        * @return {?}\n        */\n        () => !!this.anchorElement,\n        notifyClose:\n        /**\n        * @return {?}\n        */\n        () => {\n          this.closed.emit();\n\n          this._deregisterWindowClickListener();\n        },\n        notifyOpen:\n        /**\n        * @return {?}\n        */\n        () => {\n          this.opened.emit();\n\n          this._registerWindowClickListener();\n        },\n        isElementInContainer:\n        /**\n        * @param {?} el\n        * @return {?}\n        */\n        el => this._getHostElement() === el || this._getHostElement().contains(el),\n        isRtl:\n        /**\n        * @return {?}\n        */\n        () => this.platform.isBrowser ? window.getComputedStyle(this._getHostElement()).getPropertyValue('direction') === 'rtl' : false,\n        setTransformOrigin:\n        /**\n        * @param {?} origin\n        * @return {?}\n        */\n        origin => this.platform.isBrowser ? this._getHostElement().style[\n        /** @type {?} */\n        `${util.getTransformPropertyName(window)}-origin`] = origin : false,\n        isFocused:\n        /**\n        * @return {?}\n        */\n        () => {\n          var _a, _b;\n\n          return _b = ((_a = document) === null || _a === void 0 ? void 0 : _a.activeElement) === this._getHostElement(), _b !== null && _b !== void 0 ? _b : false;\n        },\n        saveFocus:\n        /**\n        * @return {?}\n        */\n        () => {\n          var _a, _b;\n\n          return this._previousFocus = (_b = (_a = document) === null || _a === void 0 ? void 0 : _a.activeElement, _b !== null && _b !== void 0 ? _b : undefined);\n        },\n        restoreFocus:\n        /**\n        * @return {?}\n        */\n        () => {\n          var _a;\n\n          if (this.platform.isBrowser) {\n            if (this._getHostElement().contains(document.activeElement)) {\n              (_a =\n              /** @type {?} */\n              this._previousFocus) === null || _a === void 0 ? void 0 : _a.focus();\n            }\n          }\n        },\n        getInnerDimensions:\n        /**\n        * @return {?}\n        */\n        () => ({\n          width: this._getHostElement().offsetWidth,\n          height: this._getHostElement().offsetHeight\n        }),\n        getAnchorDimensions:\n        /**\n        * @return {?}\n        */\n        () => this.platform.isBrowser || !this.anchorElement ?\n        /** @type {?} */\n        this._anchorElement.getBoundingClientRect() : {\n          top: 0,\n          right: 0,\n          bottom: 0,\n          left: 0,\n          width: 0,\n          height: 0\n        },\n        getWindowDimensions:\n        /**\n        * @return {?}\n        */\n        () => ({\n          width: this.platform.isBrowser ? window.innerWidth : 0,\n          height: this.platform.isBrowser ? window.innerHeight : 0\n        }),\n        getBodyDimensions:\n        /**\n        * @return {?}\n        */\n        () => ({\n          width: this.platform.isBrowser ?\n          /** @type {?} */\n          document.body.clientWidth : 0,\n          height: this.platform.isBrowser ?\n          /** @type {?} */\n          document.body.clientHeight : 0\n        }),\n        getWindowScroll:\n        /**\n        * @return {?}\n        */\n        () => ({\n          x: this.platform.isBrowser ? window.pageXOffset : 0,\n          y: this.platform.isBrowser ? window.pageYOffset : 0\n        }),\n        setPosition:\n        /**\n        * @param {?} position\n        * @return {?}\n        */\n        position => {\n          this._getHostElement().style.left = 'left' in position ? `${position.left}px` : '';\n          this._getHostElement().style.right = 'right' in position ? `${position.right}px` : '';\n          this._getHostElement().style.top = 'top' in position ? `${position.top}px` : '';\n          this._getHostElement().style.bottom = 'bottom' in position ? `${position.bottom}px` : '';\n        },\n        setMaxHeight:\n        /**\n        * @param {?} height\n        * @return {?}\n        */\n        height => this._getHostElement().style.maxHeight = height\n      };\n      return new MDCMenuSurfaceFoundation(adapter);\n    }\n    /**\n     * @protected\n     * @return {?}\n     */\n\n\n    initMenuSurface() {\n      var _a;\n\n      this._foundation.init();\n\n      this.anchorElement = (_a = this._getHostElement().parentElement, _a !== null && _a !== void 0 ? _a : this.anchorElement);\n\n      this._registerKeydownListener();\n    }\n    /**\n     * @protected\n     * @return {?}\n     */\n\n\n    destroyMenuSurface() {\n      this._destroy.next();\n\n      this._destroy.complete();\n\n      this._deregisterWindowClickListener(); // add platform check due to use of cancelAnimationFrame inside destroy()\n\n\n      if (this.platform.isBrowser) {\n        this._foundation.destroy();\n      }\n\n      if (this.hoistToBody) {\n        /** @type {?} */\n        document.body.removeChild(this._getHostElement());\n      }\n    }\n    /**\n     * Removes the menu-surface from it's current location and appends it to the\n     * body to overcome any overflow:hidden issues.\n     * @protected\n     * @return {?}\n     */\n\n\n    setHoistToBody() {\n      if (!this.platform.isBrowser) {\n        return;\n      }\n      /** @type {?} */\n\n\n      const parentEl = this._getHostElement().parentElement;\n\n      if (parentEl) {\n        /** @type {?} */\n        document.body.appendChild(parentEl.removeChild(this._getHostElement()));\n\n        this._foundation.setIsHoisted(true);\n      }\n    }\n    /**\n     * @private\n     * @return {?}\n     */\n\n\n    _registerKeydownListener() {\n      fromEvent(this._getHostElement(), 'keydown').pipe(takeUntil(this._destroy)).subscribe(\n      /**\n      * @param {?} evt\n      * @return {?}\n      */\n      evt => {\n        this._foundation.handleKeydown(evt);\n\n        this._open = this._foundation.isOpen();\n      });\n    }\n    /**\n     * @private\n     * @return {?}\n     */\n\n\n    _registerWindowClickListener() {\n      if (!this.platform.isBrowser) {\n        return;\n      }\n\n      this._windowClickSubscription = this._ngZone.runOutsideAngular(\n      /**\n      * @return {?}\n      */\n      () => fromEvent(window, 'click').subscribe(\n      /**\n      * @param {?} evt\n      * @return {?}\n      */\n      evt => this._ngZone.run(\n      /**\n      * @return {?}\n      */\n      () => {\n        this._foundation.handleBodyClick(evt);\n\n        this._open = this._foundation.isOpen();\n      })));\n    }\n    /**\n     * @private\n     * @return {?}\n     */\n\n\n    _deregisterWindowClickListener() {\n      var _a;\n\n      (_a = this._windowClickSubscription) === null || _a === void 0 ? void 0 : _a.unsubscribe();\n    }\n    /**\n     * Retrieves the DOM element of the component host.\n     * @protected\n     * @return {?}\n     */\n\n\n    _getHostElement() {\n      return this.elementRef.nativeElement;\n    }\n\n  }\n\n  MdcMenuSurfaceBase.ɵfac = function MdcMenuSurfaceBase_Factory(t) {\n    return new (t || MdcMenuSurfaceBase)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ChangeDetectorRef), ɵngcc0.ɵɵdirectiveInject(ɵngcc1.Platform), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.NgZone, 8), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef));\n  };\n\n  MdcMenuSurfaceBase.ɵdir = /*@__PURE__*/ɵngcc0.ɵɵdefineDirective({\n    type: MdcMenuSurfaceBase,\n    inputs: {\n      open: \"open\",\n      anchorElement: \"anchorElement\",\n      anchorCorner: \"anchorCorner\",\n      quickOpen: \"quickOpen\",\n      fixed: \"fixed\",\n      coordinates: \"coordinates\",\n      anchorMargin: \"anchorMargin\",\n      hoistToBody: \"hoistToBody\"\n    },\n    outputs: {\n      opened: \"opened\",\n      closed: \"closed\"\n    },\n    features: [ɵngcc0.ɵɵInheritDefinitionFeature]\n  });\n  /** @nocollapse */\n\n  return MdcMenuSurfaceBase;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n/**\n * @fileoverview added by tsickle\n * Generated from: menu-surface/menu-surface.ts\n * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n\n\nlet MdcMenuSurface = /*#__PURE__*/(() => {\n  class MdcMenuSurface extends MdcMenuSurfaceBase {\n    /**\n     * @return {?}\n     */\n    ngOnInit() {\n      this.initMenuSurface();\n    }\n    /**\n     * @return {?}\n     */\n\n\n    ngOnDestroy() {\n      this.destroyMenuSurface();\n    }\n\n  }\n\n  MdcMenuSurface.ɵfac = /*@__PURE__*/function () {\n    let ɵMdcMenuSurface_BaseFactory;\n    return function MdcMenuSurface_Factory(t) {\n      return (ɵMdcMenuSurface_BaseFactory || (ɵMdcMenuSurface_BaseFactory = ɵngcc0.ɵɵgetInheritedFactory(MdcMenuSurface)))(t || MdcMenuSurface);\n    };\n  }();\n\n  MdcMenuSurface.ɵcmp = /*@__PURE__*/ɵngcc0.ɵɵdefineComponent({\n    type: MdcMenuSurface,\n    selectors: [[\"mdc-menu-surface\"]],\n    hostAttrs: [1, \"mdc-menu-surface\"],\n    exportAs: [\"mdcMenuSurface\"],\n    features: [ɵngcc0.ɵɵInheritDefinitionFeature],\n    ngContentSelectors: _c0,\n    decls: 1,\n    vars: 0,\n    template: function MdcMenuSurface_Template(rf, ctx) {\n      if (rf & 1) {\n        ɵngcc0.ɵɵprojectionDef();\n        ɵngcc0.ɵɵprojection(0);\n      }\n    },\n    encapsulation: 2,\n    changeDetection: 0\n  });\n  return MdcMenuSurface;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n/**\n * @fileoverview added by tsickle\n * Generated from: menu-surface/menu-surface-anchor.ts\n * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n\n\nlet MdcMenuSurfaceAnchor = /*#__PURE__*/(() => {\n  class MdcMenuSurfaceAnchor {\n    /**\n     * @param {?} elementRef\n     */\n    constructor(elementRef) {\n      this.elementRef = elementRef;\n    }\n\n  }\n\n  MdcMenuSurfaceAnchor.ɵfac = function MdcMenuSurfaceAnchor_Factory(t) {\n    return new (t || MdcMenuSurfaceAnchor)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef));\n  };\n\n  MdcMenuSurfaceAnchor.ɵdir = /*@__PURE__*/ɵngcc0.ɵɵdefineDirective({\n    type: MdcMenuSurfaceAnchor,\n    selectors: [[\"\", \"mdcMenuSurfaceAnchor\", \"\"], [\"mdc-menu-surface-anchor\"]],\n    hostAttrs: [1, \"mdc-menu-surface--anchor\"]\n  });\n  /** @nocollapse */\n\n  return MdcMenuSurfaceAnchor;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n/**\n * @fileoverview added by tsickle\n * Generated from: menu-surface/module.ts\n * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n\n/** @type {?} */\n\n\nconst MENU_SURFACE_DECLARATIONS = [MdcMenuSurface, MdcMenuSurfaceAnchor];\nlet MdcMenuSurfaceModule = /*#__PURE__*/(() => {\n  class MdcMenuSurfaceModule {}\n\n  MdcMenuSurfaceModule.ɵfac = function MdcMenuSurfaceModule_Factory(t) {\n    return new (t || MdcMenuSurfaceModule)();\n  };\n\n  MdcMenuSurfaceModule.ɵmod = /*@__PURE__*/ɵngcc0.ɵɵdefineNgModule({\n    type: MdcMenuSurfaceModule\n  });\n  MdcMenuSurfaceModule.ɵinj = /*@__PURE__*/ɵngcc0.ɵɵdefineInjector({});\n  return MdcMenuSurfaceModule;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\n(function () {\n  (typeof ngJitMode === \"undefined\" || ngJitMode) && ɵngcc0.ɵɵsetNgModuleScope(MdcMenuSurfaceModule, {\n    declarations: [MdcMenuSurface, MdcMenuSurfaceAnchor],\n    exports: [MdcMenuSurface, MdcMenuSurfaceAnchor]\n  });\n})();\n\nexport { MdcMenuSurface, MdcMenuSurfaceAnchor, MdcMenuSurfaceBase, MdcMenuSurfaceModule }; //# sourceMappingURL=menu-surface.js.map","map":null,"metadata":{},"sourceType":"module"}