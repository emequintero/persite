{"ast":null,"code":"/**\n * @license\n * Copyright (c) Dominic Carretto\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://github.com/trimox/angular-mdc-web/blob/master/LICENSE\n */\nimport { EventEmitter, Component, ViewEncapsulation, ChangeDetectionStrategy, Input, Output, ContentChild, Directive, ElementRef, NgModule } from '@angular/core';\nimport { MdcMenuSurfaceBase, MdcMenuSurfaceModule } from '@angular-mdc/web/menu-surface';\nimport { coerceBooleanProperty, coerceNumberProperty } from '@angular/cdk/coercion';\nimport { Subject } from 'rxjs';\nimport { takeUntil } from 'rxjs/operators';\nimport { MdcList } from '@angular-mdc/web/list';\nimport { closest } from '@angular-mdc/web/dom';\nimport { cssClasses, MDCMenuFoundation } from '@material/menu';\n/**\n * @fileoverview added by tsickle\n * Generated from: menu/menu.ts\n * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n\nimport * as ɵngcc0 from '@angular/core';\nconst _c0 = [\"*\"];\n\nclass MdcMenuSelectedEvent {\n  /**\n   * @param {?} index\n   * @param {?} source\n   */\n  constructor(index, source) {\n    this.index = index;\n    this.source = source;\n  }\n\n}\n/** @type {?} */\n\n\nlet nextUniqueId = 0;\nlet MdcMenu = /*#__PURE__*/(() => {\n  class MdcMenu extends MdcMenuSurfaceBase {\n    constructor() {\n      super(...arguments);\n      /**\n       * Emits whenever the component is destroyed.\n       */\n\n      this._destroyed = new Subject();\n      this._uniqueId = `${cssClasses.ROOT}-${++nextUniqueId}`;\n      this.id = this._uniqueId;\n      this._wrapFocus = false;\n      this._closeSurfaceOnSelection = true;\n      this.selected = new EventEmitter();\n      this._menuFoundation = new MDCMenuFoundation(this._createAdapter());\n    }\n    /**\n     * @return {?}\n     */\n\n\n    get wrapFocus() {\n      return this._wrapFocus;\n    }\n    /**\n     * @param {?} value\n     * @return {?}\n     */\n\n\n    set wrapFocus(value) {\n      /** @type {?} */\n      const newValue = coerceBooleanProperty(value);\n\n      if (newValue !== this._wrapFocus) {\n        this._wrapFocus = newValue;\n\n        /** @type {?} */\n        this._list.wrapFocus = newValue;\n      }\n    }\n    /**\n     * @return {?}\n     */\n\n\n    get closeSurfaceOnSelection() {\n      return this._closeSurfaceOnSelection;\n    }\n    /**\n     * @param {?} value\n     * @return {?}\n     */\n\n\n    set closeSurfaceOnSelection(value) {\n      /** @type {?} */\n      const newValue = coerceBooleanProperty(value);\n\n      if (newValue !== this._closeSurfaceOnSelection) {\n        this._closeSurfaceOnSelection = newValue;\n      }\n    }\n    /**\n     * @return {?}\n     */\n\n\n    get defaultFocusState() {\n      return this._defaultFocusState;\n    }\n    /**\n     * @param {?} value\n     * @return {?}\n     */\n\n\n    set defaultFocusState(value) {\n      if (value !== this._defaultFocusState) {\n        this._defaultFocusState = coerceNumberProperty(value, 0);\n\n        this._menuFoundation.setDefaultFocusState(this._defaultFocusState);\n      }\n    }\n    /**\n     * @private\n     * @return {?}\n     */\n\n\n    _createAdapter() {\n      return Object.assign({\n        addClassToElementAtIndex:\n        /**\n        * @param {?} index\n        * @param {?} className\n        * @return {?}\n        */\n        (index, className) =>\n        /** @type {?} */\n        this._list.items.toArray()[index].getListItemElement().classList.add(className),\n        removeClassFromElementAtIndex:\n        /**\n        * @param {?} index\n        * @param {?} className\n        * @return {?}\n        */\n        (index, className) =>\n        /** @type {?} */\n        this._list.items.toArray()[index].getListItemElement().classList.remove(className),\n        addAttributeToElementAtIndex:\n        /**\n        * @param {?} index\n        * @param {?} attr\n        * @param {?} value\n        * @return {?}\n        */\n        (index, attr, value) =>\n        /** @type {?} */\n        this._list.items.toArray()[index].getListItemElement().setAttribute(attr, value),\n        removeAttributeFromElementAtIndex:\n        /**\n        * @param {?} index\n        * @param {?} attr\n        * @return {?}\n        */\n        (index, attr) =>\n        /** @type {?} */\n        this._list.items.toArray()[index].getListItemElement().removeAttribute(attr),\n        elementContainsClass:\n        /**\n        * @param {?} element\n        * @param {?} className\n        * @return {?}\n        */\n        (element, className) => element.classList.contains(className),\n        closeSurface:\n        /**\n        * @param {?} skipRestoreFocus\n        * @return {?}\n        */\n        skipRestoreFocus => {\n          if (this.closeSurfaceOnSelection) {\n            this._foundation.close(skipRestoreFocus);\n          }\n        },\n        getElementIndex:\n        /**\n        * @param {?} element\n        * @return {?}\n        */\n        element =>\n        /** @type {?} */\n        this._list.items.toArray().findIndex(\n        /**\n        * @param {?} _\n        * @return {?}\n        */\n        _ => _.getListItemElement() === element),\n        notifySelected:\n        /**\n        * @param {?} evtData\n        * @return {?}\n        */\n        evtData => this.selected.emit(new MdcMenuSelectedEvent(evtData.index,\n        /** @type {?} */\n        this._list.items.toArray()[evtData.index])),\n        getMenuItemCount:\n        /**\n        * @return {?}\n        */\n        () =>\n        /** @type {?} */\n        this._list.items.toArray().length,\n        focusItemAtIndex:\n        /**\n        * @param {?} index\n        * @return {?}\n        */\n        index =>\n        /** @type {?} */\n        this._list.items.toArray()[index].focus(),\n        focusListRoot:\n        /**\n        * @return {?}\n        */\n        () =>\n        /** @type {?} */\n        this._list.focus(),\n        isSelectableItemAtIndex:\n        /**\n        * @param {?} index\n        * @return {?}\n        */\n        index => !!closest(\n        /** @type {?} */\n        this._list.items.toArray()[index].getListItemElement(), `.${cssClasses.MENU_SELECTION_GROUP}`),\n        getSelectedSiblingOfItemAtIndex:\n        /**\n        * @param {?} index\n        * @return {?}\n        */\n        index => {\n          /** @type {?} */\n          const selectionGroupEl =\n          /** @type {?} */\n          closest(\n          /** @type {?} */\n          this._list.items.toArray()[index].getListItemElement(), `.${cssClasses.MENU_SELECTION_GROUP}`);\n          /** @type {?} */\n\n          const selectedItemEl = selectionGroupEl.querySelector(`.${cssClasses.MENU_SELECTED_LIST_ITEM}`);\n          return selectedItemEl ?\n          /** @type {?} */\n          this._list.items.toArray().findIndex(\n          /**\n          * @param {?} _\n          * @return {?}\n          */\n          _ => _.elementRef.nativeElement === selectedItemEl) : -1;\n        }\n      });\n    }\n    /**\n     * @return {?}\n     */\n\n\n    ngAfterContentInit() {\n      this.initMenuSurface();\n\n      this._initList();\n\n      this.opened.pipe(takeUntil(this._destroyed)).subscribe(\n      /**\n      * @return {?}\n      */\n      () => this._menuFoundation.handleMenuSurfaceOpened());\n    }\n    /**\n     * @return {?}\n     */\n\n\n    ngOnDestroy() {\n      this._destroyed.next();\n\n      this._destroyed.complete();\n\n      this.destroyMenuSurface();\n\n      this._menuFoundation.destroy();\n    }\n    /**\n     * @param {?} evt\n     * @return {?}\n     */\n\n\n    _handleKeydown(evt) {\n      this._menuFoundation.handleKeydown(evt);\n    }\n    /**\n     * @private\n     * @return {?}\n     */\n\n\n    _initList() {\n      if (!this._list) {\n        return;\n      }\n\n      this._list.setRole('menu');\n\n      this._list.wrapFocus = this._wrapFocus;\n\n      this._list.setTabIndex(-1); // When the list items change, re-subscribe\n\n\n      this._list.items.changes.pipe(takeUntil(this._destroyed)).subscribe(\n      /**\n      * @return {?}\n      */\n      () =>\n      /** @type {?} */\n      this._list.items.forEach(\n      /**\n      * @param {?} item\n      * @return {?}\n      */\n      item => item.setRole('menuitem')));\n\n      /** @type {?} */\n      this._list.actionEvent.pipe(takeUntil(this._destroyed)).subscribe(\n      /**\n      * @param {?} event\n      * @return {?}\n      */\n      event => this._menuFoundation.handleItemAction(\n      /** @type {?} */\n      this._list.items.toArray()[event.index].getListItemElement()));\n    }\n\n  }\n\n  MdcMenu.ɵfac = /*@__PURE__*/function () {\n    let ɵMdcMenu_BaseFactory;\n    return function MdcMenu_Factory(t) {\n      return (ɵMdcMenu_BaseFactory || (ɵMdcMenu_BaseFactory = ɵngcc0.ɵɵgetInheritedFactory(MdcMenu)))(t || MdcMenu);\n    };\n  }();\n\n  MdcMenu.ɵcmp = /*@__PURE__*/ɵngcc0.ɵɵdefineComponent({\n    type: MdcMenu,\n    selectors: [[\"mdc-menu\"]],\n    contentQueries: function MdcMenu_ContentQueries(rf, ctx, dirIndex) {\n      if (rf & 1) {\n        ɵngcc0.ɵɵcontentQuery(dirIndex, MdcList, 5);\n      }\n\n      if (rf & 2) {\n        let _t;\n\n        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx._list = _t.first);\n      }\n    },\n    hostAttrs: [1, \"mdc-menu\", \"mdc-menu-surface\"],\n    hostVars: 1,\n    hostBindings: function MdcMenu_HostBindings(rf, ctx) {\n      if (rf & 1) {\n        ɵngcc0.ɵɵlistener(\"keydown\", function MdcMenu_keydown_HostBindingHandler($event) {\n          return ctx._handleKeydown($event);\n        });\n      }\n\n      if (rf & 2) {\n        ɵngcc0.ɵɵhostProperty(\"id\", ctx.id);\n      }\n    },\n    inputs: {\n      id: \"id\",\n      wrapFocus: \"wrapFocus\",\n      closeSurfaceOnSelection: \"closeSurfaceOnSelection\",\n      defaultFocusState: \"defaultFocusState\"\n    },\n    outputs: {\n      selected: \"selected\"\n    },\n    exportAs: [\"mdcMenu\"],\n    features: [ɵngcc0.ɵɵInheritDefinitionFeature],\n    ngContentSelectors: _c0,\n    decls: 1,\n    vars: 0,\n    template: function MdcMenu_Template(rf, ctx) {\n      if (rf & 1) {\n        ɵngcc0.ɵɵprojectionDef();\n        ɵngcc0.ɵɵprojection(0);\n      }\n    },\n    encapsulation: 2,\n    changeDetection: 0\n  });\n  return MdcMenu;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n/**\n * @fileoverview added by tsickle\n * Generated from: menu/menu-directives.ts\n * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n\n\nlet MdcMenuSelectionGroup = /*#__PURE__*/(() => {\n  class MdcMenuSelectionGroup {\n    /**\n     * @param {?} elementRef\n     */\n    constructor(elementRef) {\n      this.elementRef = elementRef;\n    }\n\n  }\n\n  MdcMenuSelectionGroup.ɵfac = function MdcMenuSelectionGroup_Factory(t) {\n    return new (t || MdcMenuSelectionGroup)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef));\n  };\n\n  MdcMenuSelectionGroup.ɵdir = /*@__PURE__*/ɵngcc0.ɵɵdefineDirective({\n    type: MdcMenuSelectionGroup,\n    selectors: [[\"\", \"mdcMenuSelectionGroup\", \"\"], [\"mdc-menu-selection-group\"]],\n    hostAttrs: [1, \"mdc-menu__selection-group\"],\n    exportAs: [\"mdcMenuSelectionGroup\"]\n  });\n  /** @nocollapse */\n\n  return MdcMenuSelectionGroup;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\nlet MdcMenuSelectionGroupIcon = /*#__PURE__*/(() => {\n  class MdcMenuSelectionGroupIcon {\n    /**\n     * @param {?} elementRef\n     */\n    constructor(elementRef) {\n      this.elementRef = elementRef;\n    }\n\n  }\n\n  MdcMenuSelectionGroupIcon.ɵfac = function MdcMenuSelectionGroupIcon_Factory(t) {\n    return new (t || MdcMenuSelectionGroupIcon)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef));\n  };\n\n  MdcMenuSelectionGroupIcon.ɵdir = /*@__PURE__*/ɵngcc0.ɵɵdefineDirective({\n    type: MdcMenuSelectionGroupIcon,\n    selectors: [[\"\", \"mdcMenuSelectionGroupIcon\", \"\"], [\"mdc-menu-selection-group-icon\"]],\n    hostAttrs: [1, \"mdc-menu__selection-group-icon\"],\n    exportAs: [\"mdcMenuSelectionGroupIcon\"]\n  });\n  /** @nocollapse */\n\n  return MdcMenuSelectionGroupIcon;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n/**\n * @fileoverview added by tsickle\n * Generated from: menu/module.ts\n * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n\n/** @type {?} */\n\n\nconst MENU_DECLARATIONS = [MdcMenu, MdcMenuSelectionGroup, MdcMenuSelectionGroupIcon];\nlet MdcMenuModule = /*#__PURE__*/(() => {\n  class MdcMenuModule {}\n\n  MdcMenuModule.ɵfac = function MdcMenuModule_Factory(t) {\n    return new (t || MdcMenuModule)();\n  };\n\n  MdcMenuModule.ɵmod = /*@__PURE__*/ɵngcc0.ɵɵdefineNgModule({\n    type: MdcMenuModule\n  });\n  MdcMenuModule.ɵinj = /*@__PURE__*/ɵngcc0.ɵɵdefineInjector({\n    imports: [[MdcMenuSurfaceModule], MdcMenuSurfaceModule]\n  });\n  return MdcMenuModule;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\n(function () {\n  (typeof ngJitMode === \"undefined\" || ngJitMode) && ɵngcc0.ɵɵsetNgModuleScope(MdcMenuModule, {\n    declarations: function () {\n      return [MdcMenu, MdcMenuSelectionGroup, MdcMenuSelectionGroupIcon];\n    },\n    imports: function () {\n      return [MdcMenuSurfaceModule];\n    },\n    exports: function () {\n      return [MdcMenu, MdcMenuSelectionGroup, MdcMenuSelectionGroupIcon, MdcMenuSurfaceModule];\n    }\n  });\n})();\n\nexport { MdcMenu, MdcMenuModule, MdcMenuSelectedEvent, MdcMenuSelectionGroup, MdcMenuSelectionGroupIcon }; //# sourceMappingURL=menu.js.map","map":null,"metadata":{},"sourceType":"module"}