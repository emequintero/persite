{"ast":null,"code":"/**\n * @license\n * Copyright (c) Dominic Carretto\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://github.com/trimox/angular-mdc-web/blob/master/LICENSE\n */\nimport { Directive, ElementRef, Input, InjectionToken, EventEmitter, Component, ViewEncapsulation, ChangeDetectionStrategy, ChangeDetectorRef, Optional, Self, Inject, Output, ViewChild, ContentChildren, NgModule } from '@angular/core';\nimport { CommonModule } from '@angular/common';\nimport { MdcFloatingLabel, MdcFloatingLabelModule } from '@angular-mdc/web/floating-label';\nimport { MdcLineRipple, MdcLineRippleModule } from '@angular-mdc/web/line-ripple';\nimport { MdcNotchedOutline, MdcNotchedOutlineModule } from '@angular-mdc/web/notched-outline';\nimport { mixinErrorState, MdcFormFieldControl, ErrorStateMatcher, MdcFormField, MdcCharacterCounter, MdcFormFieldModule } from '@angular-mdc/web/form-field';\nimport { __awaiter } from 'tslib';\nimport { NgControl, NgForm, FormGroupDirective } from '@angular/forms';\nimport { coerceBooleanProperty, coerceNumberProperty } from '@angular/cdk/coercion';\nimport { Platform } from '@angular/cdk/platform';\nimport { MdcRipple } from '@angular-mdc/web/ripple';\nimport { MDCComponent } from '@angular-mdc/web/base';\nimport { MDCTextFieldIconFoundation, MDCTextFieldFoundation, MDCTextFieldHelperTextFoundation } from '@material/textfield';\n/**\n * @fileoverview added by tsickle\n * Generated from: textfield/text-field-icon.ts\n * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n\nimport * as ɵngcc0 from '@angular/core';\nimport * as ɵngcc1 from '@angular/cdk/platform';\nimport * as ɵngcc2 from '@angular-mdc/web/form-field';\nimport * as ɵngcc3 from '@angular-mdc/web/ripple';\nimport * as ɵngcc4 from '@angular/forms';\nimport * as ɵngcc5 from '@angular/common';\nimport * as ɵngcc6 from '@angular-mdc/web/floating-label';\nimport * as ɵngcc7 from '@angular-mdc/web/line-ripple';\nimport * as ɵngcc8 from '@angular-mdc/web/notched-outline';\nconst _c0 = [\"inputElement\"];\n\nfunction MdcTextField_ng_content_1_Template(rf, ctx) {\n  if (rf & 1) {\n    ɵngcc0.ɵɵprojection(0, 1, [\"*ngIf\", \"leadingIcon || trailingIcon\"]);\n  }\n}\n\nfunction MdcTextField_label_5_Template(rf, ctx) {\n  if (rf & 1) {\n    ɵngcc0.ɵɵelementStart(0, \"label\", 6);\n    ɵngcc0.ɵɵtext(1);\n    ɵngcc0.ɵɵelementEnd();\n  }\n\n  if (rf & 2) {\n    const ctx_r2 = ɵngcc0.ɵɵnextContext();\n    ɵngcc0.ɵɵproperty(\"for\", ctx_r2.id);\n    ɵngcc0.ɵɵadvance(1);\n    ɵngcc0.ɵɵtextInterpolate(ctx_r2.label);\n  }\n}\n\nfunction MdcTextField_mdc_line_ripple_6_Template(rf, ctx) {\n  if (rf & 1) {\n    ɵngcc0.ɵɵelement(0, \"mdc-line-ripple\");\n  }\n}\n\nfunction MdcTextField_mdc_notched_outline_7_Template(rf, ctx) {\n  if (rf & 1) {\n    ɵngcc0.ɵɵelement(0, \"mdc-notched-outline\", 7);\n  }\n\n  if (rf & 2) {\n    const ctx_r4 = ɵngcc0.ɵɵnextContext();\n    ɵngcc0.ɵɵproperty(\"label\", ctx_r4.label)(\"for\", ctx_r4.id);\n  }\n}\n\nconst _c1 = [\"*\", \"*\"];\n\nfunction MdcTextarea_div_0_Template(rf, ctx) {\n  if (rf & 1) {\n    ɵngcc0.ɵɵelement(0, \"div\", 4);\n  }\n}\n\nlet MdcTextFieldIcon = /*#__PURE__*/(() => {\n  class MdcTextFieldIcon extends MDCComponent {\n    /**\n     * @param {?} elementRef\n     */\n    constructor(elementRef) {\n      super(elementRef);\n      this.elementRef = elementRef;\n      this._leading = false;\n      this._trailing = false;\n    }\n    /**\n     * @return {?}\n     */\n\n\n    get leading() {\n      return this._leading;\n    }\n    /**\n     * @param {?} value\n     * @return {?}\n     */\n\n\n    set leading(value) {\n      this._leading = coerceBooleanProperty(value);\n    }\n    /**\n     * @return {?}\n     */\n\n\n    get trailing() {\n      return this._trailing;\n    }\n    /**\n     * @param {?} value\n     * @return {?}\n     */\n\n\n    set trailing(value) {\n      this._trailing = coerceBooleanProperty(value);\n    }\n    /**\n     * @return {?}\n     */\n\n\n    get foundation() {\n      return this._foundation;\n    }\n    /**\n     * @return {?}\n     */\n\n\n    getDefaultFoundation() {\n      /** @type {?} */\n      const adapter = {\n        getAttr:\n        /**\n        * @param {?} attr\n        * @return {?}\n        */\n        attr => this._elementRef.nativeElement.getAttribute(attr),\n        setAttr:\n        /**\n        * @param {?} attr\n        * @param {?} value\n        * @return {?}\n        */\n        (attr, value) => this._elementRef.nativeElement.setAttribute(attr, value),\n        removeAttr:\n        /**\n        * @param {?} attr\n        * @return {?}\n        */\n        attr => this._elementRef.nativeElement.removeAttribute(attr),\n        setContent:\n        /**\n        * @return {?}\n        */\n        () => {},\n        registerInteractionHandler:\n        /**\n        * @return {?}\n        */\n        () => {},\n        deregisterInteractionHandler:\n        /**\n        * @return {?}\n        */\n        () => {},\n        notifyIconAction:\n        /**\n        * @return {?}\n        */\n        () => {}\n      };\n      return new MDCTextFieldIconFoundation(adapter);\n    }\n    /**\n     * @return {?}\n     */\n\n\n    ngOnDestroy() {\n      this.destroy();\n    }\n\n  }\n\n  MdcTextFieldIcon.ɵfac = function MdcTextFieldIcon_Factory(t) {\n    return new (t || MdcTextFieldIcon)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef));\n  };\n\n  MdcTextFieldIcon.ɵdir = /*@__PURE__*/ɵngcc0.ɵɵdefineDirective({\n    type: MdcTextFieldIcon,\n    selectors: [[\"\", \"mdcTextFieldIcon\", \"\"]],\n    hostAttrs: [1, \"mdc-text-field__icon\"],\n    hostVars: 5,\n    hostBindings: function MdcTextFieldIcon_HostBindings(rf, ctx) {\n      if (rf & 2) {\n        ɵngcc0.ɵɵattribute(\"tabindex\", ctx.trailing ? 0 : -1);\n        ɵngcc0.ɵɵclassProp(\"mdc-text-field__icon--leading\", ctx.leading)(\"mdc-text-field__icon--trailing\", ctx.trailing);\n      }\n    },\n    inputs: {\n      leading: \"leading\",\n      trailing: \"trailing\"\n    },\n    exportAs: [\"mdcTextFieldIcon\"],\n    features: [ɵngcc0.ɵɵInheritDefinitionFeature]\n  });\n  /** @nocollapse */\n\n  return MdcTextFieldIcon;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n/**\n * @fileoverview added by tsickle\n * Generated from: textfield/text-field.ts\n * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n\n/**\n * Injection token that can be used to configure the default options for all\n * mdc-text-field usage within an app.\n * @type {?}\n */\n\n\nconst MDC_TEXT_FIELD_DEFAULT_OPTIONS = new InjectionToken('MDC_TEXT_FIELD_DEFAULT_OPTIONS');\n\nclass MdcTextFieldBase extends MDCComponent {\n  /**\n   * @param {?} _elementRef\n   * @param {?} _defaultErrorStateMatcher\n   * @param {?} _parentForm\n   * @param {?} _parentFormGroup\n   * @param {?} ngControl\n   */\n  constructor(_elementRef, _defaultErrorStateMatcher, _parentForm, _parentFormGroup, ngControl) {\n    super(_elementRef);\n    this._elementRef = _elementRef;\n    this._defaultErrorStateMatcher = _defaultErrorStateMatcher;\n    this._parentForm = _parentForm;\n    this._parentFormGroup = _parentFormGroup;\n    this.ngControl = ngControl;\n  }\n\n}\n/** @type {?} */\n\n\nconst _MdcTextFieldMixinBase = mixinErrorState(MdcTextFieldBase);\n/** @type {?} */\n\n\nlet nextUniqueId = 0;\n/**\n * Time in milliseconds for which to ignore mouse events, after\n * receiving a touch event. Used to avoid doing double work for\n * touch devices where the browser fires fake mouse events, in\n * addition to touch events.\n * @type {?}\n */\n\nconst MOUSE_EVENT_IGNORE_TIME = 800;\nlet MdcTextField = /*#__PURE__*/(() => {\n  class MdcTextField extends _MdcTextFieldMixinBase {\n    /**\n     * @param {?} _platform\n     * @param {?} _changeDetectorRef\n     * @param {?} elementRef\n     * @param {?} _defaultErrorStateMatcher\n     * @param {?} _parentFormField\n     * @param {?} _ripple\n     * @param {?} ngControl\n     * @param {?} _parentForm\n     * @param {?} _parentFormGroup\n     * @param {?} _defaults\n     */\n    constructor(_platform, _changeDetectorRef, elementRef, _defaultErrorStateMatcher, _parentFormField, _ripple, ngControl, _parentForm, _parentFormGroup, _defaults) {\n      super(elementRef, _defaultErrorStateMatcher, _parentForm, _parentFormGroup, ngControl);\n      this._platform = _platform;\n      this._changeDetectorRef = _changeDetectorRef;\n      this.elementRef = elementRef;\n      this._defaultErrorStateMatcher = _defaultErrorStateMatcher;\n      this._parentFormField = _parentFormField;\n      this._ripple = _ripple;\n      this.ngControl = ngControl;\n      this._defaults = _defaults;\n      this._uid = `mdc-input-${nextUniqueId++}`;\n      this._initialized = false;\n      /**\n       * Time in milliseconds when the last touchstart event happened.\n       */\n\n      this._lastTouchStartEvent = 0;\n      this.controlType = 'mdc-text-field';\n      this.label = null;\n      this.placeholder = null;\n      this.tabIndex = 0;\n      this._id = '';\n      this._type = 'text';\n      this._outlined = false;\n      this._disabled = false;\n      this._required = false;\n      this._readonly = false;\n      this._fullwidth = false;\n      this._helperText = null;\n      this._useNativeValidation = true;\n      this._characterCounter = false;\n      this.change = new EventEmitter();\n      this.input = new EventEmitter();\n      this.blur = new EventEmitter();\n      this._onFocus = new EventEmitter();\n      /**\n       * View to model callback called when value changes\n       */\n\n      this._onChange =\n      /**\n      * @return {?}\n      */\n      () => {};\n      /**\n       * View to model callback called when text field has been touched\n       */\n\n\n      this._onTouched =\n      /**\n      * @return {?}\n      */\n      () => {};\n\n      if (this.ngControl) {\n        // Note: we provide the value accessor through here, instead of\n        // the `providers` to avoid running into a circular import.\n        this.ngControl.valueAccessor = this;\n      }\n\n      if (this._parentFormField) {\n        _parentFormField.elementRef.nativeElement.classList.add('ngx-form-field-text-field');\n      } // Force setter to be called in case id was not specified.\n\n\n      this.id = this.id;\n\n      this._setDefaultGlobalOptions();\n    }\n    /**\n     * @return {?}\n     */\n\n\n    get id() {\n      return this._id;\n    }\n    /**\n     * @param {?} value\n     * @return {?}\n     */\n\n\n    set id(value) {\n      this._id = value || this._uid;\n    }\n    /**\n     * Input type of the element.\n     * @return {?}\n     */\n\n\n    get type() {\n      return this._type;\n    }\n    /**\n     * @param {?} value\n     * @return {?}\n     */\n\n\n    set type(value) {\n      this._type = value || 'text';\n    }\n    /**\n     * @return {?}\n     */\n\n\n    get outlined() {\n      return this._outlined;\n    }\n    /**\n     * @param {?} value\n     * @return {?}\n     */\n\n\n    set outlined(value) {\n      /** @type {?} */\n      const newValue = coerceBooleanProperty(value);\n      this._outlined = newValue;\n\n      if (this._initialized) {\n        this._layout();\n      }\n    }\n    /**\n     * @return {?}\n     */\n\n\n    get disabled() {\n      return this._disabled;\n    }\n    /**\n     * @param {?} value\n     * @return {?}\n     */\n\n\n    set disabled(value) {\n      this.setDisabledState(value);\n    }\n    /**\n     * @return {?}\n     */\n\n\n    get required() {\n      return this._required;\n    }\n    /**\n     * @param {?} value\n     * @return {?}\n     */\n\n\n    set required(value) {\n      /** @type {?} */\n      const newValue = coerceBooleanProperty(value);\n\n      if (newValue !== this._required) {\n        this._required = newValue;\n\n        if (this._initialized) {\n          if (!this.valid) {\n            this._foundation.setValid(true);\n\n            this._changeDetectorRef.markForCheck();\n          }\n\n          if (this.ngControl) {\n            this._required ? this._getInputElement().setAttribute('required', '') : this._getInputElement().removeAttribute('required');\n          }\n        }\n      }\n    }\n    /**\n     * @return {?}\n     */\n\n\n    get readonly() {\n      return this._readonly;\n    }\n    /**\n     * @param {?} value\n     * @return {?}\n     */\n\n\n    set readonly(value) {\n      this._readonly = coerceBooleanProperty(value);\n    }\n    /**\n     * @return {?}\n     */\n\n\n    get fullwidth() {\n      return this._fullwidth;\n    }\n    /**\n     * @param {?} value\n     * @return {?}\n     */\n\n\n    set fullwidth(value) {\n      /** @type {?} */\n      const newValue = coerceBooleanProperty(value);\n\n      if (newValue !== this._fullwidth) {\n        this._fullwidth = newValue;\n        this.placeholder = this.fullwidth ? this.label : '';\n      }\n    }\n    /**\n     * @return {?}\n     */\n\n\n    get helperText() {\n      return this._helperText;\n    }\n    /**\n     * @param {?} helperText\n     * @return {?}\n     */\n\n\n    set helperText(helperText) {\n      this._helperText = helperText;\n\n      if (this._helperText) {\n        this._initHelperText();\n\n        this._helperText.characterCounter = this._characterCounter;\n      }\n    }\n    /**\n     * Sets the Text Field valid or invalid.\n     * @return {?}\n     */\n\n\n    get valid() {\n      return this._valid;\n    }\n    /**\n     * @param {?} value\n     * @return {?}\n     */\n\n\n    set valid(value) {\n      /** @type {?} */\n      const newValue = coerceBooleanProperty(value);\n\n      if (newValue !== this._valid) {\n        this._valid = value;\n\n        this._foundation.setValid(newValue);\n      }\n    }\n    /**\n     * Enables or disables the use of native validation. Use this for custom validation.\n     * @return {?}\n     */\n\n\n    get useNativeValidation() {\n      return this._useNativeValidation;\n    }\n    /**\n     * @param {?} value\n     * @return {?}\n     */\n\n\n    set useNativeValidation(value) {\n      /** @type {?} */\n      const newValue = coerceBooleanProperty(value);\n\n      if (newValue !== this._useNativeValidation) {\n        this._useNativeValidation = newValue;\n\n        this._foundation.setUseNativeValidation(this._useNativeValidation);\n      }\n    }\n    /**\n     * @return {?}\n     */\n\n\n    get characterCounter() {\n      return this._characterCounter;\n    }\n    /**\n     * @param {?} value\n     * @return {?}\n     */\n\n\n    set characterCounter(value) {\n      /** @type {?} */\n      const newValue = coerceBooleanProperty(value);\n\n      if (newValue !== this._characterCounter) {\n        this._characterCounter = newValue;\n\n        if (this.helperText) {\n          this.helperText.characterCounter = this._characterCounter;\n        }\n      }\n    }\n    /**\n     * @return {?}\n     */\n\n\n    get value() {\n      return this._value;\n    }\n    /**\n     * @param {?} newValue\n     * @return {?}\n     */\n\n\n    set value(newValue) {\n      if (!this._initialized) {\n        this.ngControl ? this._initializeValue() : this._initializeValue(newValue);\n      } else {\n        this.setValue(newValue, true);\n      }\n    }\n    /**\n     * @return {?}\n     */\n\n\n    get textarea() {\n      return this._getHostElement().nodeName.toLowerCase() === 'mdc-textarea';\n    }\n    /**\n     * @return {?}\n     */\n\n\n    get leadingIcon() {\n      var _a;\n\n      return (_a = this._icons) === null || _a === void 0 ? void 0 : _a.find(\n      /**\n      * @param {?} icon\n      * @return {?}\n      */\n      icon => icon.leading);\n    }\n    /**\n     * @return {?}\n     */\n\n\n    get trailingIcon() {\n      var _a;\n\n      return (_a = this._icons) === null || _a === void 0 ? void 0 : _a.find(\n      /**\n      * @param {?} icon\n      * @return {?}\n      */\n      icon => icon.trailing);\n    }\n    /**\n     * @return {?}\n     */\n\n\n    getDefaultFoundation() {\n      /** @type {?} */\n      const adapter = Object.assign(Object.assign(Object.assign(Object.assign(Object.assign({}, this._getRootAdapterMethods()), this._getInputAdapterMethods()), this._getLabelAdapterMethods()), this._getLineRippleAdapterMethods()), this._getOutlineAdapterMethods());\n      return new MDCTextFieldFoundation(adapter, this._getFoundationMap());\n    }\n    /**\n     * @private\n     * @return {?}\n     */\n\n\n    _getRootAdapterMethods() {\n      return {\n        addClass:\n        /**\n        * @param {?} className\n        * @return {?}\n        */\n        className => this._getHostElement().classList.add(className),\n        removeClass:\n        /**\n        * @param {?} className\n        * @return {?}\n        */\n        className => this._getHostElement().classList.remove(className),\n        hasClass:\n        /**\n        * @param {?} className\n        * @return {?}\n        */\n        className => this._getHostElement().classList.contains(className)\n      };\n    }\n    /**\n     * @private\n     * @return {?}\n     */\n\n\n    _getInputAdapterMethods() {\n      return {\n        getNativeInput:\n        /**\n        * @return {?}\n        */\n        () => {\n          var _a;\n\n          return {\n            maxLength: (_a = this.maxlength, _a !== null && _a !== void 0 ? _a : 0),\n            type: this._type,\n            value: this._platform.isBrowser ? this._input.nativeElement.value : this._value,\n            disabled: this._disabled,\n            validity: {\n              valid: this._isValid(),\n              badInput: this._platform.isBrowser ? this._input.nativeElement.validity.badInput : false\n            }\n          };\n        },\n        isFocused:\n        /**\n        * @return {?}\n        */\n        () => this._platform.isBrowser ? document.activeElement === this._getInputElement() : false,\n        registerInputInteractionHandler:\n        /**\n        * @return {?}\n        */\n        () => {},\n        deregisterInputInteractionHandler:\n        /**\n        * @return {?}\n        */\n        () => {}\n      };\n    }\n    /**\n     * @private\n     * @return {?}\n     */\n\n\n    _getLabelAdapterMethods() {\n      return {\n        shakeLabel:\n        /**\n        * @param {?} shouldShake\n        * @return {?}\n        */\n        shouldShake => this._getFloatingLabel().shake(shouldShake),\n        floatLabel:\n        /**\n        * @param {?} shouldFloat\n        * @return {?}\n        */\n        shouldFloat => this._getFloatingLabel().float(shouldFloat),\n        hasLabel:\n        /**\n        * @return {?}\n        */\n        () => this._hasFloatingLabel(),\n        getLabelWidth:\n        /**\n        * @return {?}\n        */\n        () => this._hasFloatingLabel() ? this._getFloatingLabel().getWidth() : 0\n      };\n    }\n    /**\n     * @private\n     * @return {?}\n     */\n\n\n    _getLineRippleAdapterMethods() {\n      return {\n        activateLineRipple:\n        /**\n        * @return {?}\n        */\n        () => {\n          var _a;\n\n          return (_a = this._lineRipple) === null || _a === void 0 ? void 0 : _a.activate();\n        },\n        deactivateLineRipple:\n        /**\n        * @return {?}\n        */\n        () => {\n          var _a;\n\n          return (_a = this._lineRipple) === null || _a === void 0 ? void 0 : _a.deactivate();\n        },\n        setLineRippleTransformOrigin:\n        /**\n        * @param {?} normalizedX\n        * @return {?}\n        */\n        normalizedX => {\n          var _a;\n\n          return (_a = this._lineRipple) === null || _a === void 0 ? void 0 : _a.setRippleCenter(normalizedX);\n        }\n      };\n    }\n    /**\n     * @private\n     * @return {?}\n     */\n\n\n    _getOutlineAdapterMethods() {\n      return {\n        hasOutline:\n        /**\n        * @return {?}\n        */\n        () => !!this._notchedOutline,\n        notchOutline:\n        /**\n        * @param {?} labelWidth\n        * @return {?}\n        */\n        labelWidth =>\n        /** @type {?} */\n        this._notchedOutline.notch(labelWidth),\n        closeOutline:\n        /**\n        * @return {?}\n        */\n        () =>\n        /** @type {?} */\n        this._notchedOutline.closeNotch()\n      };\n    }\n    /**\n     * Returns a map of all subcomponents to subfoundations.\n     * @private\n     * @return {?}\n     */\n\n\n    _getFoundationMap() {\n      var _a, _b, _c, _d, _e;\n\n      return {\n        helperText: (_a = this._helperText) === null || _a === void 0 ? void 0 : _a.foundation,\n        characterCounter: (_c = (_b = this.helperText) === null || _b === void 0 ? void 0 : _b._characterCounterElement) === null || _c === void 0 ? void 0 : _c.foundation,\n        leadingIcon: (_d = this.leadingIcon) === null || _d === void 0 ? void 0 : _d.foundation,\n        trailingIcon: (_e = this.trailingIcon) === null || _e === void 0 ? void 0 : _e.foundation\n      };\n    }\n    /**\n     * @return {?}\n     */\n\n\n    _asyncBuildFoundation() {\n      return __awaiter(this, void 0, void 0, function* () {\n        this._foundation = this.getDefaultFoundation();\n      });\n    }\n    /**\n     * @return {?}\n     */\n\n\n    ngAfterViewInit() {\n      this.init();\n    }\n    /**\n     * @return {?}\n     */\n\n\n    ngOnDestroy() {\n      this.destroy();\n\n      this._foundation.destroy();\n    }\n    /**\n     * @return {?}\n     */\n\n\n    ngDoCheck() {\n      if (this.ngControl) {\n        // We need to re-evaluate this on every change detection cycle, because there are some\n        // error triggers that we can't subscribe to (e.g. parent form submissions). This means\n        // that whatever logic is in here has to be super lean or we risk destroying the performance.\n        this.updateErrorState();\n      }\n    }\n    /**\n     * @return {?}\n     */\n\n\n    init() {\n      this._initialized = true;\n\n      this._asyncBuildFoundation().then(\n      /**\n      * @return {?}\n      */\n      () => {\n        var _a, _b, _c, _d, _e;\n\n        this._foundation.init();\n\n        if (!this.fullwidth && !this.outlined && !this.textarea) {\n          this._ripple = new MdcRipple(this.elementRef);\n\n          this._ripple.init();\n        } else {\n          (_a = this._ripple) === null || _a === void 0 ? void 0 : _a.destroy();\n        }\n\n        this._checkCustomValidity();\n\n        (_c = (_b = this.leadingIcon) === null || _b === void 0 ? void 0 : _b.foundation) === null || _c === void 0 ? void 0 : _c.init();\n        (_e = (_d = this.trailingIcon) === null || _d === void 0 ? void 0 : _d.foundation) === null || _e === void 0 ? void 0 : _e.init();\n        this.disabled = this._input.nativeElement.disabled;\n      });\n    }\n    /**\n     * @return {?}\n     */\n\n\n    onTextFieldInteraction() {\n      if (this._initialized) {\n        this._foundation.handleTextFieldInteraction();\n      }\n    }\n    /**\n     * @param {?} evt\n     * @return {?}\n     */\n\n\n    onInputInteraction(evt) {\n      if (evt instanceof MouseEvent) {\n        /** @type {?} */\n        const isSyntheticEvent = this._lastTouchStartEvent && Date.now() < this._lastTouchStartEvent + MOUSE_EVENT_IGNORE_TIME;\n\n        if (isSyntheticEvent) {\n          return;\n        }\n      } else {\n        this._lastTouchStartEvent = Date.now();\n      }\n\n      this._foundation.setTransformOrigin(evt);\n    }\n    /**\n     * @param {?} evt\n     * @return {?}\n     */\n\n\n    onInput(evt) {\n      /** @type {?} */\n      const value =\n      /** @type {?} */\n      evt.target.value;\n      this.setValue(value, true);\n\n      this._foundation.handleInput();\n\n      this.input.emit(value);\n      evt.stopPropagation();\n    }\n    /**\n     * @return {?}\n     */\n\n\n    onFocus() {\n      if (this._initialized) {\n        this._foundation.activateFocus();\n\n        this._onFocus.emit(true);\n      }\n    }\n    /**\n     * @param {?} evt\n     * @return {?}\n     */\n\n\n    onChange(evt) {\n      /** @type {?} */\n      const value =\n      /** @type {?} */\n      evt.target.value;\n      this.setValue(value, true);\n      this.change.emit(value);\n      evt.stopPropagation();\n    }\n    /**\n     * @return {?}\n     */\n\n\n    onBlur() {\n      this._onTouched();\n\n      this._foundation.deactivateFocus();\n\n      this.blur.emit(this.value);\n\n      this._onFocus.emit(false);\n    }\n    /**\n     * @param {?} value\n     * @return {?}\n     */\n\n\n    writeValue(value) {\n      this.setValue(value);\n    }\n    /**\n     * @param {?} fn\n     * @return {?}\n     */\n\n\n    registerOnChange(fn) {\n      this._onChange = fn;\n    }\n    /**\n     * @param {?} fn\n     * @return {?}\n     */\n\n\n    registerOnTouched(fn) {\n      this._onTouched = fn;\n    }\n    /**\n     * @private\n     * @param {?=} value\n     * @return {?}\n     */\n\n\n    _initializeValue(value) {\n      // Defer setting the value in order to avoid the \"Expression\n      // has changed after it was checked\" errors from Angular.\n      Promise.resolve().then(\n      /**\n      * @return {?}\n      */\n      () => {\n        this.setValue(this.ngControl ? this.ngControl.value : value);\n      });\n    }\n    /**\n     * @param {?} value\n     * @param {?=} isUserInput\n     * @return {?}\n     */\n\n\n    setValue(value, isUserInput) {\n      /** @type {?} */\n      const newValue = this.type === 'number' ? coerceNumberProperty(value, null) : value;\n\n      if (this._value === newValue) {\n        // Reset validity for numeric form inputs\n        if (newValue === null) {\n          this.valid = true;\n        }\n\n        return;\n      }\n\n      this._value = newValue !== undefined ? newValue : null;\n\n      if (this._getInputElement().value !== this._value) {\n        this._getInputElement().value = this._value;\n      }\n\n      this._foundation.setValue(this._value || '');\n\n      if (isUserInput) {\n        this._onChange(this._value);\n      }\n\n      this._changeDetectorRef.markForCheck();\n    }\n    /**\n     * @return {?}\n     */\n\n\n    isBadInput() {\n      /** @type {?} */\n      const validity = this._getInputElement().validity;\n\n      return validity && validity.badInput;\n    }\n    /**\n     * @return {?}\n     */\n\n\n    focus() {\n      var _a;\n\n      (_a = this._getInputElement()) === null || _a === void 0 ? void 0 : _a.focus();\n    }\n    /**\n     * Initializes Text Field's internal state based on the environment state\n     * @private\n     * @return {?}\n     */\n\n\n    _layout() {\n      this.destroy();\n      this.init();\n\n      this._changeDetectorRef.markForCheck();\n\n      setTimeout(\n      /**\n      * @return {?}\n      */\n      () => {\n        if (this._outlined) {\n          this._foundation.notchOutline(this._foundation.shouldFloat);\n        }\n\n        if (this._hasFloatingLabel()) {\n          this._getFloatingLabel().float(this._foundation.shouldFloat);\n        }\n      });\n    }\n    /**\n     * Implemented as part of ControlValueAccessor.\n     * @param {?} isDisabled\n     * @return {?}\n     */\n\n\n    setDisabledState(isDisabled) {\n      /** @type {?} */\n      const newValue = coerceBooleanProperty(isDisabled);\n\n      if (newValue !== this._disabled) {\n        this._disabled = newValue;\n\n        if (this._initialized) {\n          this._foundation.setDisabled(newValue);\n        }\n\n        this._changeDetectorRef.markForCheck();\n      }\n    }\n    /**\n     * Set the default options here.\n     * @private\n     * @return {?}\n     */\n\n\n    _setDefaultGlobalOptions() {\n      if (this._defaults && this._defaults.outlined) {\n        this._outlined = this._defaults.outlined;\n      }\n    }\n    /**\n     * @private\n     * @return {?}\n     */\n\n\n    _checkCustomValidity() {\n      Promise.resolve().then(\n      /**\n      * @return {?}\n      */\n      () => {\n        if (this._valid !== undefined) {\n          this._foundation.setValid(this._valid);\n        }\n      });\n    }\n    /**\n     * @private\n     * @return {?}\n     */\n\n\n    _initHelperText() {\n      /** @type {?} */\n      const helper = this.helperText;\n\n      if (helper) {\n        helper.addHelperTextClass(this.controlType);\n        helper.init(MDCTextFieldHelperTextFoundation);\n      }\n    }\n    /**\n     * Override MdcTextFieldBase destroy method\n     * @return {?}\n     */\n\n\n    destroy() {\n      var _a, _b;\n\n      this._initialized = false;\n      (_a = this._lineRipple) === null || _a === void 0 ? void 0 : _a.destroy();\n      (_b = this._ripple) === null || _b === void 0 ? void 0 : _b.destroy();\n    }\n    /**\n     * @private\n     * @return {?}\n     */\n\n\n    _isValid() {\n      if (this.ngControl) {\n        return !this.errorState;\n      }\n\n      return this._valid ? this._valid : this._platform.isBrowser ? this._input.nativeElement.validity.valid : true;\n    }\n    /**\n     * @private\n     * @return {?}\n     */\n\n\n    _hasFloatingLabel() {\n      return this.label && (this._floatingLabel || this._notchedOutline) ? true : false;\n    }\n    /**\n     * @private\n     * @return {?}\n     */\n\n\n    _getFloatingLabel() {\n      return this._floatingLabel ||\n      /** @type {?} */\n      this._notchedOutline.floatingLabel;\n    }\n    /**\n     * @private\n     * @return {?}\n     */\n\n\n    _getInputElement() {\n      return this._input.nativeElement;\n    }\n    /**\n     * Retrieves the DOM element of the component host.\n     * @private\n     * @return {?}\n     */\n\n\n    _getHostElement() {\n      return this.elementRef.nativeElement;\n    }\n\n  }\n\n  MdcTextField.ɵfac = function MdcTextField_Factory(t) {\n    return new (t || MdcTextField)(ɵngcc0.ɵɵdirectiveInject(ɵngcc1.Platform), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ChangeDetectorRef), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef), ɵngcc0.ɵɵdirectiveInject(ɵngcc2.ErrorStateMatcher), ɵngcc0.ɵɵdirectiveInject(ɵngcc2.MdcFormField, 8), ɵngcc0.ɵɵdirectiveInject(ɵngcc3.MdcRipple, 8), ɵngcc0.ɵɵdirectiveInject(ɵngcc4.NgControl, 10), ɵngcc0.ɵɵdirectiveInject(ɵngcc4.NgForm, 8), ɵngcc0.ɵɵdirectiveInject(ɵngcc4.FormGroupDirective, 8), ɵngcc0.ɵɵdirectiveInject(MDC_TEXT_FIELD_DEFAULT_OPTIONS, 8));\n  };\n\n  MdcTextField.ɵcmp = /*@__PURE__*/ɵngcc0.ɵɵdefineComponent({\n    type: MdcTextField,\n    selectors: [[\"mdc-text-field\"]],\n    contentQueries: function MdcTextField_ContentQueries(rf, ctx, dirIndex) {\n      if (rf & 1) {\n        ɵngcc0.ɵɵcontentQuery(dirIndex, MdcTextFieldIcon, 5);\n      }\n\n      if (rf & 2) {\n        let _t;\n\n        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx._icons = _t);\n      }\n    },\n    viewQuery: function MdcTextField_Query(rf, ctx) {\n      if (rf & 1) {\n        ɵngcc0.ɵɵviewQuery(_c0, 7);\n        ɵngcc0.ɵɵviewQuery(MdcLineRipple, 5);\n        ɵngcc0.ɵɵviewQuery(MdcNotchedOutline, 5);\n        ɵngcc0.ɵɵviewQuery(MdcFloatingLabel, 5);\n      }\n\n      if (rf & 2) {\n        let _t;\n\n        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx._input = _t.first);\n        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx._lineRipple = _t.first);\n        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx._notchedOutline = _t.first);\n        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx._floatingLabel = _t.first);\n      }\n    },\n    hostAttrs: [1, \"mdc-text-field\"],\n    hostVars: 14,\n    hostBindings: function MdcTextField_HostBindings(rf, ctx) {\n      if (rf & 1) {\n        ɵngcc0.ɵɵlistener(\"click\", function MdcTextField_click_HostBindingHandler() {\n          return ctx.onTextFieldInteraction();\n        })(\"keydown\", function MdcTextField_keydown_HostBindingHandler() {\n          return ctx.onTextFieldInteraction();\n        });\n      }\n\n      if (rf & 2) {\n        ɵngcc0.ɵɵclassProp(\"mdc-text-field--disabled\", ctx.disabled)(\"mdc-text-field--outlined\", ctx.outlined)(\"mdc-text-field--fullwidth\", ctx.fullwidth)(\"mdc-text-field--with-leading-icon\", ctx.leadingIcon)(\"mdc-text-field--with-trailing-icon\", ctx.trailingIcon)(\"mdc-text-field--no-label\", !ctx.label || ctx.label && ctx.fullwidth)(\"mdc-text-field--invalid\", ctx.errorState);\n      }\n    },\n    inputs: {\n      label: \"label\",\n      placeholder: \"placeholder\",\n      tabIndex: \"tabIndex\",\n      id: \"id\",\n      type: \"type\",\n      outlined: \"outlined\",\n      disabled: \"disabled\",\n      required: \"required\",\n      readonly: \"readonly\",\n      fullwidth: \"fullwidth\",\n      helperText: \"helperText\",\n      valid: \"valid\",\n      useNativeValidation: \"useNativeValidation\",\n      characterCounter: \"characterCounter\",\n      value: \"value\",\n      name: \"name\",\n      maxlength: \"maxlength\",\n      minlength: \"minlength\",\n      pattern: \"pattern\",\n      autocomplete: \"autocomplete\",\n      max: \"max\",\n      min: \"min\",\n      size: \"size\",\n      step: \"step\",\n      errorStateMatcher: \"errorStateMatcher\"\n    },\n    outputs: {\n      change: \"change\",\n      input: \"input\",\n      blur: \"blur\",\n      _onFocus: \"focus\"\n    },\n    exportAs: [\"mdcTextField\"],\n    features: [ɵngcc0.ɵɵProvidersFeature([MdcRipple, {\n      provide: MdcFormFieldControl,\n      useExisting: MdcTextField\n    }]), ɵngcc0.ɵɵInheritDefinitionFeature],\n    ngContentSelectors: _c1,\n    decls: 8,\n    vars: 21,\n    consts: [[1, \"mdc-text-field__ripple\"], [4, \"ngIf\"], [1, \"mdc-text-field__input\", 3, \"id\", \"type\", \"tabindex\", \"disabled\", \"readonly\", \"required\", \"mousedown\", \"touchstart\", \"focus\", \"input\", \"change\", \"blur\"], [\"inputElement\", \"\"], [\"mdcFloatingLabel\", \"\", 3, \"for\", 4, \"ngIf\"], [3, \"label\", \"for\", 4, \"ngIf\"], [\"mdcFloatingLabel\", \"\", 3, \"for\"], [3, \"label\", \"for\"]],\n    template: function MdcTextField_Template(rf, ctx) {\n      if (rf & 1) {\n        ɵngcc0.ɵɵprojectionDef(_c1);\n        ɵngcc0.ɵɵelement(0, \"div\", 0);\n        ɵngcc0.ɵɵtemplate(1, MdcTextField_ng_content_1_Template, 1, 0, \"ng-content\", 1);\n        ɵngcc0.ɵɵelementStart(2, \"input\", 2, 3);\n        ɵngcc0.ɵɵlistener(\"mousedown\", function MdcTextField_Template_input_mousedown_2_listener($event) {\n          return ctx.onInputInteraction($event);\n        })(\"touchstart\", function MdcTextField_Template_input_touchstart_2_listener($event) {\n          return ctx.onInputInteraction($event);\n        })(\"focus\", function MdcTextField_Template_input_focus_2_listener() {\n          return ctx.onFocus();\n        })(\"input\", function MdcTextField_Template_input_input_2_listener($event) {\n          return ctx.onInput($event);\n        })(\"change\", function MdcTextField_Template_input_change_2_listener($event) {\n          return ctx.onChange($event);\n        })(\"blur\", function MdcTextField_Template_input_blur_2_listener() {\n          return ctx.onBlur();\n        });\n        ɵngcc0.ɵɵelementEnd();\n        ɵngcc0.ɵɵprojection(4);\n        ɵngcc0.ɵɵtemplate(5, MdcTextField_label_5_Template, 2, 2, \"label\", 4);\n        ɵngcc0.ɵɵtemplate(6, MdcTextField_mdc_line_ripple_6_Template, 1, 0, \"mdc-line-ripple\", 1);\n        ɵngcc0.ɵɵtemplate(7, MdcTextField_mdc_notched_outline_7_Template, 1, 2, \"mdc-notched-outline\", 5);\n      }\n\n      if (rf & 2) {\n        ɵngcc0.ɵɵadvance(1);\n        ɵngcc0.ɵɵproperty(\"ngIf\", ctx.leadingIcon || ctx.trailingIcon);\n        ɵngcc0.ɵɵadvance(1);\n        ɵngcc0.ɵɵproperty(\"id\", ctx.id)(\"type\", ctx.type)(\"tabindex\", ctx.tabIndex)(\"disabled\", ctx.disabled)(\"readonly\", ctx.readonly)(\"required\", ctx.required);\n        ɵngcc0.ɵɵattribute(\"name\", ctx.name)(\"aria-invalid\", ctx.errorState)(\"autocomplete\", ctx.autocomplete)(\"pattern\", ctx.pattern)(\"placeholder\", ctx.placeholder)(\"maxlength\", ctx.maxlength)(\"minlength\", ctx.minlength)(\"max\", ctx.max)(\"min\", ctx.min)(\"size\", ctx.size)(\"step\", ctx.step);\n        ɵngcc0.ɵɵadvance(3);\n        ɵngcc0.ɵɵproperty(\"ngIf\", !ctx.placeholder && !ctx.outlined);\n        ɵngcc0.ɵɵadvance(1);\n        ɵngcc0.ɵɵproperty(\"ngIf\", !ctx.outlined && !ctx.textarea);\n        ɵngcc0.ɵɵadvance(1);\n        ɵngcc0.ɵɵproperty(\"ngIf\", ctx.outlined);\n      }\n    },\n    directives: [ɵngcc5.NgIf, ɵngcc6.MdcFloatingLabel, ɵngcc7.MdcLineRipple, ɵngcc8.MdcNotchedOutline],\n    encapsulation: 2,\n    changeDetection: 0\n  });\n  /** @nocollapse */\n\n  return MdcTextField;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n/**\n * @fileoverview added by tsickle\n * Generated from: textfield/textarea.ts\n * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n\n\nlet MdcTextarea = /*#__PURE__*/(() => {\n  class MdcTextarea extends MdcTextField {}\n\n  MdcTextarea.ɵfac = /*@__PURE__*/function () {\n    let ɵMdcTextarea_BaseFactory;\n    return function MdcTextarea_Factory(t) {\n      return (ɵMdcTextarea_BaseFactory || (ɵMdcTextarea_BaseFactory = ɵngcc0.ɵɵgetInheritedFactory(MdcTextarea)))(t || MdcTextarea);\n    };\n  }();\n\n  MdcTextarea.ɵcmp = /*@__PURE__*/ɵngcc0.ɵɵdefineComponent({\n    type: MdcTextarea,\n    selectors: [[\"mdc-textarea\"]],\n    viewQuery: function MdcTextarea_Query(rf, ctx) {\n      if (rf & 1) {\n        ɵngcc0.ɵɵviewQuery(MdcCharacterCounter, 5);\n      }\n\n      if (rf & 2) {\n        let _t;\n\n        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx._characterCounterElement = _t.first);\n      }\n    },\n    hostAttrs: [1, \"mdc-text-field\"],\n    hostVars: 8,\n    hostBindings: function MdcTextarea_HostBindings(rf, ctx) {\n      if (rf & 2) {\n        ɵngcc0.ɵɵclassProp(\"mdc-text-field--textarea\", true)(\"mdc-text-field--no-label\", !ctx.label)(\"mdc-text-field--fullwidth\", ctx.fullwidth)(\"mdc-text-field--invalid\", ctx.errorState);\n      }\n    },\n    inputs: {\n      rows: \"rows\",\n      cols: \"cols\"\n    },\n    exportAs: [\"mdcTextarea\"],\n    features: [ɵngcc0.ɵɵInheritDefinitionFeature],\n    decls: 4,\n    vars: 14,\n    consts: [[\"mdcCharacterCounter\", \"\", 4, \"ngIf\"], [1, \"mdc-text-field__input\", 3, \"id\", \"rows\", \"cols\", \"tabindex\", \"disabled\", \"required\", \"readonly\", \"mousedown\", \"touchstart\", \"focus\", \"input\", \"change\", \"blur\"], [\"inputElement\", \"\"], [3, \"label\", \"for\"], [\"mdcCharacterCounter\", \"\"]],\n    template: function MdcTextarea_Template(rf, ctx) {\n      if (rf & 1) {\n        ɵngcc0.ɵɵtemplate(0, MdcTextarea_div_0_Template, 1, 0, \"div\", 0);\n        ɵngcc0.ɵɵelementStart(1, \"textarea\", 1, 2);\n        ɵngcc0.ɵɵlistener(\"mousedown\", function MdcTextarea_Template_textarea_mousedown_1_listener($event) {\n          return ctx.onInputInteraction($event);\n        })(\"touchstart\", function MdcTextarea_Template_textarea_touchstart_1_listener($event) {\n          return ctx.onInputInteraction($event);\n        })(\"focus\", function MdcTextarea_Template_textarea_focus_1_listener() {\n          return ctx.onFocus();\n        })(\"input\", function MdcTextarea_Template_textarea_input_1_listener($event) {\n          return ctx.onInput($event);\n        })(\"change\", function MdcTextarea_Template_textarea_change_1_listener($event) {\n          return ctx.onChange($event);\n        })(\"blur\", function MdcTextarea_Template_textarea_blur_1_listener() {\n          return ctx.onBlur();\n        });\n        ɵngcc0.ɵɵelementEnd();\n        ɵngcc0.ɵɵelement(3, \"mdc-notched-outline\", 3);\n      }\n\n      if (rf & 2) {\n        ɵngcc0.ɵɵproperty(\"ngIf\", ctx.characterCounter);\n        ɵngcc0.ɵɵadvance(1);\n        ɵngcc0.ɵɵproperty(\"id\", ctx.id)(\"rows\", ctx.rows)(\"cols\", ctx.cols)(\"tabindex\", ctx.tabIndex)(\"disabled\", ctx.disabled)(\"required\", ctx.required)(\"readonly\", ctx.readonly);\n        ɵngcc0.ɵɵattribute(\"name\", ctx.name)(\"aria-invalid\", ctx.errorState)(\"maxlength\", ctx.maxlength)(\"minlength\", ctx.minlength);\n        ɵngcc0.ɵɵadvance(2);\n        ɵngcc0.ɵɵproperty(\"label\", ctx.label)(\"for\", ctx.id);\n      }\n    },\n    directives: [ɵngcc5.NgIf, ɵngcc2.MdcCharacterCounter, ɵngcc8.MdcNotchedOutline],\n    encapsulation: 2,\n    changeDetection: 0\n  });\n  return MdcTextarea;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n/**\n * @fileoverview added by tsickle\n * Generated from: textfield/module.ts\n * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n\n/** @type {?} */\n\n\nconst TEXTFIELD_DECLARATIONS = [MdcTextarea, MdcTextField, MdcTextFieldIcon];\nlet MdcTextFieldModule = /*#__PURE__*/(() => {\n  class MdcTextFieldModule {}\n\n  MdcTextFieldModule.ɵfac = function MdcTextFieldModule_Factory(t) {\n    return new (t || MdcTextFieldModule)();\n  };\n\n  MdcTextFieldModule.ɵmod = /*@__PURE__*/ɵngcc0.ɵɵdefineNgModule({\n    type: MdcTextFieldModule\n  });\n  MdcTextFieldModule.ɵinj = /*@__PURE__*/ɵngcc0.ɵɵdefineInjector({\n    imports: [[CommonModule, MdcFormFieldModule, MdcLineRippleModule, MdcFloatingLabelModule, MdcNotchedOutlineModule], MdcFormFieldModule]\n  });\n  return MdcTextFieldModule;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\n(function () {\n  (typeof ngJitMode === \"undefined\" || ngJitMode) && ɵngcc0.ɵɵsetNgModuleScope(MdcTextFieldModule, {\n    declarations: function () {\n      return [MdcTextarea, MdcTextField, MdcTextFieldIcon];\n    },\n    imports: function () {\n      return [CommonModule, MdcFormFieldModule, MdcLineRippleModule, MdcFloatingLabelModule, MdcNotchedOutlineModule];\n    },\n    exports: function () {\n      return [MdcFormFieldModule, MdcTextarea, MdcTextField, MdcTextFieldIcon];\n    }\n  });\n})();\n\nexport { MDC_TEXT_FIELD_DEFAULT_OPTIONS, MdcTextField, MdcTextFieldIcon, MdcTextFieldModule, MdcTextarea }; //# sourceMappingURL=textfield.js.map","map":null,"metadata":{},"sourceType":"module"}